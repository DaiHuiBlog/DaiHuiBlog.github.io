<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac远程连接谷歌云VM实例]]></title>
    <url>%2F2019%2F02%2F19%2FMac%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%B0%B7%E6%AD%8C%E4%BA%91VM%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[官方网站的教程很详细，但是表达方式不是很好理解，并且有的功能在操作上第一次用GCP的我来说有点陌生，这里就Linux或Mac连接VM实例方式作一个简要记录（全是大白话） 第一步:生成密钥对1ssh-keygen -t rsa -f ~/.ssh/秘钥名称 -C "邮箱" 这样就在主目录下的.ssh目录中生成了两个文件“秘钥名称”和“秘钥名称.pub”。“秘钥名称”中保存的是私钥，”秘钥名称.pub“中保存的是公钥。 第二步:添加公钥拷贝公钥到剪切板:1pbcopy &lt; 秘钥名称.pub 在GPC导航菜单中找到”元数据“连接，选择”SSH秘钥“选项卡-&gt;点击”修改“按钮-&gt;”添加一项“，粘贴公钥，保存，就添加完成了。 第三步:测试1ssh -i ~/.ssh/秘钥名称 用户名@VM外部IP 用户名，在第二部添加公钥时，粘贴之后会在第一列出现你的用户名 如果没问题的话你已经进入到VM实例终端了 同样的方式gitlab和GitHub也是支持的]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>GCP</tag>
        <tag>谷歌云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下利用GCP和v2ray搭建无限使用梯子]]></title>
    <url>%2F2019%2F02%2F18%2FMac%E4%B8%8B%E5%88%A9%E7%94%A8GCP%E5%92%8Cv2ray%E6%90%AD%E5%BB%BA%E6%97%A0%E9%99%90%E4%BD%BF%E7%94%A8%E6%A2%AF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[前言妈妈再也不用为我担心没梯子用了 新用户申请GCP(Google Cloud Platform) 这一步很蛋疼，需要先fq，所以小伙伴们可以先借同事或朋友的梯子注册一下来搞。总之，先注册上GCP 进去之后按照步骤填写信息。在最后需要小伙伴填写一个信用卡号，用来验证和今后扣取费用（我们这里只需要验证，右边的提示也说不会自动扣费） 关于信用卡，小伙伴们可以上某宝买一个，直接搜“虚拟信用卡”，大概在25元左右一个。一般来说店小二会给你提供包括：持卡人、卡号、卡有效期、CVV和账单地址等信息。这些信息在注册GCP时按照店小二给你发的如实填写即可。注：地区最好和店小二发给你的保持一致。 假设到这里没问题的话，点击注册，你就会得到一个为期365天的试用期，里面有300刀。 创建MV实例 进入 “导航菜单”-&gt;“Compute Engine”-&gt;”VM 实例”，选择“VM 实例”。首次进来可能需要初始化一下，初始化后点击“创建”来创建我们的VM；如果以前用过的话直接点击创建实例即可。 进入到创建实例界面，按照步骤填写即可，这里给个建议： 区域，最好选一个里你进的地方，比如香港，台湾，东京等地；机器类型 机器类型，选择微型即可，够用且便宜 启动磁盘，默认即可 防火墙，“允许HTTP流量”和“允许HTTPS流量”都勾上 展开防火墙管理，选择“网络”，并在“网络标记”处填入防火墙出入站规则名称，分别为“ruzhan”和”chuzhan“（咱们先填写，后面再创建） 点击创建，完成MV创建 安装v2ray 点击新创建的实例的连接“SSH”，登入远程连接。登入后做一下几个准备操作： 切换为管理员，sudo -i 执行”date -R”查看当前时间和服务器是否一致（一般都不一致） 以服务器在上海的为例，执行一下命令将时间同步一下 “cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime“，执行后查看当前时间是否一致“date -R”，这个时候发现时间已经同步了 接下来开始安装v2ray，咱们直接执行官方提供的脚本命令”bash &lt;(curl -L -s https://install.direct/go.sh)“ 等待安装完毕，配置v2ray的配置文件位置在”/etc/v2ray/config.json”，里面已经有一个官方默认配置好的配置，我们先把内容删除，都是基本vi操作。打开”vi /etc/v2ray/config.json“，按”dd“删除了第一行，后面的可以直接按”.”把剩下的内容删完。 此时咱们打开v2ray配置生成器，设置填写建议如下： 服务种类：默认 用户设置-&gt;用户uuid：多点几下 用户设置-&gt;使用的alterID数量：随意，我填了101 端口设置-&gt;端口号：随意，找一个不太会被占用的 点击服务端配置的复制配置，将该配置粘贴到”/etc/v2ray/config.json“，在删完内容的配置文件里按下”i”，直接command+v粘贴即可 依次按下 ”ESC“+”:wq“+回车，保存退出 重启v2ray服务，”sudo systemctl restart v2ray“ 查看v2ray运行状态，”service v2ray status“，看到此时已经是”Active: active (running)“ 到此MV基本配置完成，接下来配置两个出入站规则 出入站防火墙搭建 进入 “导航菜单”-&gt;“VPC网络”-&gt;”防火墙规则”，点击”创建防火墙规则“，分别创建出站和入站规则，如下图： 出站规则 入站规则 回到MV实例，单击MV实例的名称，进入到MV实例详情页面，点击”修改“，如果在创建VM实例步骤没有配置”网络标记“选项，在这里把出入站规则名称填入其中，保存即可；因为在创建VM实例时已经把出入站名称填好了，这里就不用设置了 配置Mac端v2ray客户端配置信息 没有客户端的小伙伴可以自行下载，Mac端可以用brew安装”brew cask install v2rayx“ 安装完毕，打开软件配置。点击”Configure…“，配置可参考我的： 配置完成，选择”Global Mode“，再点击”local core“，完成！剩下的你懂的 续命 当你试用账号快到期的时候，进入“导航菜单”-&gt;“结算”-&gt;”显示信息面板“，将结算账号管理员删除，过个5、6分钟后再次申请试用账号即可，而且你的VM也还在]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>梯子</tag>
        <tag>v2ray</tag>
        <tag>GCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win2008R2磁盘脱机和写入保护解决办法]]></title>
    <url>%2F2018%2F10%2F22%2Fwin2008R2%E7%A3%81%E7%9B%98%E8%84%B1%E6%9C%BA%E5%92%8C%E5%86%99%E5%85%A5%E4%BF%9D%E6%8A%A4%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[打开cmd命令行，输入：diskpart，进入diskpart工具 输入：list disk，查看到所有磁盘 找到脱机的磁盘，输入：select disk 1 接着输入：online disk 查看此时磁盘联机状态 清除只读属性，输入：attribute disk clear readonly 查看此时的清盘情况，输入：attribute disk]]></content>
      <categories>
        <category>OS</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows磁盘脱机</tag>
        <tag>写入保护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8中的StreamsAPI详解]]></title>
    <url>%2F2018%2F09%2F30%2FJava8%E4%B8%AD%E7%9A%84StreamsAPI%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Java 8 中的 Streams API 详解为什么需要 StreamStream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。 Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。 所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。 什么是聚合操作在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如： 客户每月平均消费金额 最昂贵的在售商品 本周完成的有效订单（排除了无效的） 取十个数据样本作为首页推荐 这类的操作。 但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写： 清单 1. Java 7 的排序、取值实现 123456789101112131415List&lt;Transaction&gt; groceryTransactions = new Arraylist&lt;&gt;();for(Transaction t: transactions)&#123; if(t.getType() == Transaction.GROCERY)&#123; groceryTransactions.add(t); &#125;&#125;Collections.sort(groceryTransactions, new Comparator()&#123; public int compare(Transaction t1, Transaction t2)&#123; return t2.getValue().compareTo(t1.getValue()); &#125;&#125;);List&lt;Integer&gt; transactionIds = new ArrayList&lt;&gt;();for(Transaction t: groceryTransactions)&#123; transactionsIds.add(t.getId());&#125; 而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。 清单 2. Java 8 的排序、取值实现 12345List&lt;Integer&gt; transactionsIds = transactions.parallelStream(). filter(t -&gt; t.getType() == Transaction.GROCERY). sorted(comparing(Transaction::getValue).reversed()). map(Transaction::getId). collect(toList()); Stream 总览什么是流Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。 Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。 而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下： 1 1.0-1.4 中的 java.lang.Thread 2 5.0 中的 java.util.concurrent 3 6.0 中的 Phasers 等 4 7.0 中的 Fork/Join 框架 5 8.0 中的 Lambda Stream 的另外一大特点是，数据源本身可以是无限的。 流的构成当我们使用一个流的时候，通常包括三个基本步骤： 获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。 图 1. 流管道 (Stream Pipeline) 的构成 有多种方式生成 Stream Source： 从 Collection 和数组 Collection.stream() Collection.parallelStream() Arrays.stream(T array) or Stream.of() 从 BufferedReader java.io.BufferedReader.lines() 静态工厂 java.util.stream.IntStream.range() java.nio.file.Files.walk() 自己构建 java.util.Spliterator 其它 Random.ints() BitSet.stream() Pattern.splitAsStream(java.lang.CharSequence) JarFile.stream() 流的操作类型分为两种： Intermediate：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。 Terminal：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。 在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。 还有一种操作被称为 short-circuiting。用以指： 对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。 对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。 当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。 清单 3. 一个流操作的示例 1234int sum = widgets.stream().filter(w -&gt; w.getColor() == RED) .mapToInt(w -&gt; w.getWeight()) .sum(); stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。 流的使用详解简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。 流的构造与转换下面提供最常见的几种构造 Stream 的样例。 清单 4. 构造流的几种常见方法 123456789// 1. Individual valuesStream stream = Stream.of("a", "b", "c");// 2. ArraysString [] strArray = new String[] &#123;"a", "b", "c"&#125;;stream = Stream.of(strArray);stream = Arrays.stream(strArray);// 3. CollectionsList&lt;String&gt; list = Arrays.asList(strArray);stream = list.stream(); 需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream： IntStream、LongStream、DoubleStream。当然我们也可以用 Stream&lt;Integer>、Stream&lt;Long>、Stream&lt;Double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。 Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。 清单 5. 数值流的构造 123IntStream.of(new int[]&#123;1, 2, 3&#125;).forEach(System.out::println);IntStream.range(1, 3).forEach(System.out::println);IntStream.rangeClosed(1, 3).forEach(System.out::println); 清单 6. 流转换为其它数据结构 123456789// 1. ArrayString[] strArray1 = stream.toArray(String[]::new);// 2. CollectionList&lt;String&gt; list1 = stream.collect(Collectors.toList());List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));Set set1 = stream.collect(Collectors.toSet());Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));// 3. StringString str = stream.collect(Collectors.joining()).toString(); 一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。 流的操作接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。 Intermediate： map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered Terminal： forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator Short-circuiting： anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit 我们下面看一下 Stream 的比较典型用法。 map/flatMap 我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。 清单 7. 转换大写 123List&lt;String&gt; output = wordList.stream().map(String::toUpperCase).collect(Collectors.toList()); 这段代码把所有的单词转换为大写。 清单 8. 平方数 1234List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4);List&lt;Integer&gt; squareNums = nums.stream().map(n -&gt; n * n).collect(Collectors.toList()); 这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。 从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。 清单 9. 一对多 1234567Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of( Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6) );Stream&lt;Integer&gt; outputStream = inputStream.flatMap((childList) -&gt; childList.stream()); flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。 filter filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。 清单 10. 留下偶数 123Integer[] sixNums = &#123;1, 2, 3, 4, 5, 6&#125;;Integer[] evens =Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new); 经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。 清单 11. 把单词挑出来 1234List&lt;String&gt; output = reader.lines(). flatMap(line -&gt; Stream.of(line.split(REGEXP))). filter(word -&gt; word.length() &gt; 0). collect(Collectors.toList()); 这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。 forEach forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。 清单 12. 打印姓名（forEach 和 pre-java8 的对比） 12345678910// Java 8roster.stream() .filter(p -&gt; p.getGender() == Person.Sex.MALE) .forEach(p -&gt; System.out.println(p.getName()));// Pre-Java 8for (Person p : roster) &#123; if (p.getGender() == Person.Sex.MALE) &#123; System.out.println(p.getName()); &#125;&#125; 对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。 但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。 另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的： 12stream.forEach(element -&gt; doOneThing(element));stream.forEach(element -&gt; doAnotherThing(element)); 相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。 清单 13. peek 对每个元素执行操作并返回一个新的 Stream 123456Stream.of("one", "two", "three", "four") .filter(e -&gt; e.length() &gt; 3) .peek(e -&gt; System.out.println("Filtered value: " + e)) .map(String::toUpperCase) .peek(e -&gt; System.out.println("Mapped value: " + e)) .collect(Collectors.toList()); forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。 findFirst 这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。 这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。 清单 14. Optional 的两个用例 123456789101112131415161718192021String strA = " abcd ", strB = null;print(strA);print("");print(strB);getLength(strA);getLength("");getLength(strB);public static void print(String text) &#123; // Java 8 Optional.ofNullable(text).ifPresent(System.out::println); // Pre-Java 8 if (text != null) &#123; System.out.println(text); &#125; &#125;public static int getLength(String text) &#123; // Java 8return Optional.ofNullable(text).map(String::length).orElse(-1); // Pre-Java 8// return if (text != null) ? text.length() : -1; &#125;; 在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。 Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。 reduce 这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于 Integer sum = integers.reduce(0, (a, b) -&gt; a+b); 或 Integer sum = integers.reduce(0, Integer::sum); 也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。 清单 15. reduce 的用例 123456789101112// 字符串连接，concat = "ABCD"String concat = Stream.of("A", "B", "C", "D").reduce("", String::concat); // 求最小值，minValue = -3.0double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); // 求和，sumValue = 10, 有起始值int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);// 求和，sumValue = 10, 无起始值sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();// 过滤，字符串连接，concat = "ace"concat = Stream.of("a", "B", "c", "D", "e", "F"). filter(x -&gt; x.compareTo("Z") &gt; 0). reduce("", String::concat); 上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。 limit/skip limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。 清单 16. limit 和 skip 对运行次数的影响 12345678910111213141516171819202122public void testLimitAndSkip() &#123; List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 10000; i++) &#123; Person person = new Person(i, "name" + i); persons.add(person); &#125;List&lt;String&gt; personList2 = persons.stream().map(Person::getName).limit(10).skip(3).collect(Collectors.toList()); System.out.println(personList2);&#125;private class Person &#123; public int no; private String name; public Person (int no, String name) &#123; this.no = no; this.name = name; &#125; public String getName() &#123; System.out.println(name); return name; &#125;&#125; 输出结果为： 1234567891011name1name2name3name4name5name6name7name8name9name10[name4, name5, name6, name7, name8, name9, name10] 这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。 有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。 清单 17. limit 和 skip 对 sorted 后的运行次数无影响 12345678List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) &#123; Person person = new Person(i, "name" + i); persons.add(person); &#125;List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());System.out.println(personList2); 上面的示例对清单 13 做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为： 123456789name2name1name3name2name4name3name5name4[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27] 即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。 最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。 sorted 对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化： 清单 18. 优化：排序前进行 limit 和 skip 1234567List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) &#123; Person person = new Person(i, "name" + i); persons.add(person); &#125;List&lt;Person&gt; personList2 = persons.stream().limit(2).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());System.out.println(personList2); 结果会简单很多： 123name2name1[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a] 当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。 min/max/distinct min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。 清单 19. 找出最长一行的长度 1234567BufferedReader br = new BufferedReader(new FileReader("c:\\SUService.log"));int longest = br.lines(). mapToInt(String::length). max(). getAsInt();br.close();System.out.println(longest); 下面的例子则使用 distinct 来找出不重复的单词。 清单 20. 找出全文的单词，转小写，并排序 123456789List&lt;String&gt; words = br.lines(). flatMap(line -&gt; Stream.of(line.split(" "))). filter(word -&gt; word.length() &gt; 0). map(String::toLowerCase). distinct(). sorted(). collect(Collectors.toList());br.close();System.out.println(words); Match Stream 有三个 match 方法，从语义上说： allMatch：Stream 中全部元素符合传入的 predicate，返回 true anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true 它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。 清单 21. 使用 Match 123456789101112List&lt;Person&gt; persons = new ArrayList();persons.add(new Person(1, "name" + 1, 10));persons.add(new Person(2, "name" + 2, 21));persons.add(new Person(3, "name" + 3, 34));persons.add(new Person(4, "name" + 4, 6));persons.add(new Person(5, "name" + 5, 55));boolean isAllAdult = persons.stream(). allMatch(p -&gt; p.getAge() &gt; 18);System.out.println("All are adult? " + isAllAdult);boolean isThereAnyChild = persons.stream(). anyMatch(p -&gt; p.getAge() &lt; 12);System.out.println("Any child? " + isThereAnyChild); 输出结果： 12All are adult? falseAny child? true 进阶：自己生成流Stream.generate 通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。 清单 22. 生成 10 个随机整数 123456Random seed = new Random();Supplier&lt;Integer&gt; random = seed::nextInt;Stream.generate(random).limit(10).forEach(System.out::println);//Another wayIntStream.generate(() -&gt; (int) (System.nanoTime() % 100)).limit(10).forEach(System.out::println); Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。 清单 23. 自实现 Supplier 1234567891011Stream.generate(new PersonSupplier()).limit(10).forEach(p -&gt; System.out.println(p.getName() + ", " + p.getAge()));private class PersonSupplier implements Supplier&lt;Person&gt; &#123; private int index = 0; private Random random = new Random(); @Override public Person get() &#123; return new Person(index++, "StormTestUser" + index, random.nextInt(100)); &#125;&#125; 输出结果： 12345678910StormTestUser1, 9StormTestUser2, 12StormTestUser3, 88StormTestUser4, 51StormTestUser5, 22StormTestUser6, 28StormTestUser7, 81StormTestUser8, 51StormTestUser9, 4StormTestUser10, 76 Stream.iterate iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。 清单 24. 生成一个等差数列 1Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + " "));. 输出结果： 10 3 6 9 12 15 18 21 24 27 与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。 进阶：用 Collectors 来进行 reduction 操作java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。groupingBy/partitioningBy 清单 25. 按照年龄归组 12345678Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.groupingBy(Person::getAge));Iterator it = personGroups.entrySet().iterator();while (it.hasNext()) &#123; Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next(); System.out.println("Age " + persons.getKey() + " = " + persons.getValue().size());&#125; 上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出： 1234567Age 0 = 2Age 1 = 2Age 5 = 2Age 8 = 1Age 9 = 1Age 11 = 2…… 清单 26. 按照未成年人和成年人归组 12345Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()).limit(100). collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));System.out.println("Children number: " + children.get(true).size());System.out.println("Adult number: " + children.get(false).size()); 输出结果： 12Children number: 23 Adult number: 77 在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。 结束语总之，Stream 的特性可以归纳为： 不是数据结构 它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。 它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。 所有 Stream 的操作必须以 lambda 表达式为参数 不支持索引访问 你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。 很容易生成数组或者 List 惰性化 很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。 Intermediate 操作永远是惰性化的。 并行能力 当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。 可以是无限的 集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。]]></content>
      <categories>
        <category>Java</category>
        <category>Stream</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Streams API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装软件时提示已损坏的解决方法]]></title>
    <url>%2F2018%2F09%2F27%2FMac%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%97%B6%E6%8F%90%E7%A4%BA%E5%B7%B2%E6%8D%9F%E5%9D%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[从网上下载的常用软件，安装时总是提示“已损坏，移至废纸篓”这类信息，无法打开。如下图： 这是新系统（macOS Sierra 10.12.X）惹的祸。新系统加强了安全机制，默认不允许用户自行下载安装应用程序，只能从Mac App Store里安装应用。 解决办法：打开终端，在终端中输入：1sudo spctl --master-disable 输入密码，回车。搞定]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>文件损坏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机Linux的root或普通用户密码忘记找回]]></title>
    <url>%2F2018%2F07%2F31%2F%E8%99%9A%E6%8B%9F%E6%9C%BALinux%E7%9A%84root%E6%88%96%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E5%BF%98%E8%AE%B0%E6%89%BE%E5%9B%9E%2F</url>
    <content type="text"><![CDATA[启动VMware的Linux 进入GRUB界面后，有几秒钟时间给你。进入GRUB出现： Red Hat Enterprise Linux Server (2.6.18-8.e15xen) 倒计时结束前，键入e出现：root（hd0,0）kernel /xen.gz-2.6.28-8.e15module /vmlinux-2.6.18.e15xen ro root=/dev/VolGroup00/LogVo100 rhgb quietmodule /initrd-2.6.18-8.e15xen.img上下键移到quiet那一行，按e进入，加上 linux single或者1即可，回车 按b后进入重启模式，一定注意出现： Starting udev: 在后面输入boot回车 之后出现命令行： sh-3.2# 输入passwd，回车即可修改root密码，输入两次密码 完成之后reboot即可重启。 普通用户密码忘记了，比较简单 在root账户下，打开/etc/shadow (不是passwd文件，因为密码实际上经过加密后放在了“影子口令”文件shadow中了。passwd文件每个用户均可见，但是shadow只有root可以见)。 找到普通用户名cicikasa，然后删除第二个域即可，域之间用“:”隔开的，如下：cicikasa:TdkakkkYUukkjkjk:14672:0:99999:7:::上述红色部分就是经过加密的密码，删除即可 在普通用户下，输入passwd即可输入新密码 如果想修改VMware的bios在VMWare中将BIOS设成光驱启动:启动时(点击启动虚拟机按钮),按F2 ,进入BIOS 设置,找到 BOOT—把CDROM光驱，移动到最上面即可。根据提示进行设置，一般按“-”号进行设置。注意：启动时，点了启动虚拟机按钮后一定要在点一下窗口（或者Ctrl +G），然后快按F2。否则，窗口没激活，F2是不起作用的.]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>密码找回</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo下NexT主题添加Gitment评论插件]]></title>
    <url>%2F2018%2F06%2F20%2FHexo%E4%B8%8BNexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Gitment%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最终效果图大概是这个样子： Gitment 是作者imsun实现的一款基于 GitHub Issues 的评论系统。 支持在前端直接引入， 不需要任何后端代码。 可以在页面进行登录， 查看，评论，点赞等操作。 同时有完整的 Markdown / GFM 和代码高亮支持。 尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 这篇文章仅介绍如果在 hexo-NexT 中添加 Gitment 评论插件，并且增加一个点开显示评论的按钮，对于 Gitment 的使用请参考 imsun 的博客。 另外，本教程的按钮样式和代码均直接取自 ehlxr 博主。 注册OAuth Application因为 Gitment 评论插件是基于Github Issues评论系统，这类评论系统都需要一个OAuth Application，所以咱们没有注册OAuth Application的同学先注册一个。博客咱们已经有啦，例如我的：DaiHuiBlog.github.io。没有的同学以自己GitHub用户新建一个仓库就行：你的用户名.github.io接下来创建 OAuth Application，没有的同学可以新建一个。 其中 Application name 为仓库名，例：DaiHuiBlog.github.io Homepage URL 填你的博客网址，例：blog.daihui888.com Application description 描述，随便写 Authorization callback URL 填你的博客网址，例：blog.daihui888.com 完成后会生成相应的 clientID 和 clientSecret。 接下来开始配置Gitment “显示 Gitment 评论” 的按钮样式在 next/source/css/_common/components 目录中新建一个 gitment.styl 的 css 样式文件, 复制以下代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.gitment_title:hover &#123; color: #fff; background: #0a9caf; background-image: initial; background-position-x: initial; background-position-y: initial; background-size: initial; background-repeat-x: initial; background-repeat-y: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: rgb(10, 156, 175);&#125;.gitment_title &#123; border: 1px solid #0a9caf; border-top-color: rgb(10, 156, 175); border-top-style: solid; border-top-width: 1px; border-right-color: rgb(10, 156, 175); border-right-style: solid; border-right-width: 1px; border-bottom-color: rgb(10, 156, 175); border-bottom-style: solid; border-bottom-width: 1px; border-left-color: rgb(10, 156, 175); border-left-style: solid; border-left-width: 1px; border-image-source: initial; border-image-slice: initial; border-image-width: initial; border-image-outset: initial; border-image-repeat: initial; border-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px;&#125;.gitment_title &#123; display: inline-block; padding: 0 15px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; color: #0a9caf; cursor: pointer; font-size: 14px;&#125; 然后打开同目录中的 components.styl 文件, 找个顺眼的位置添加一句 1@import &quot;gitment&quot; 添加 Gitment 插件打开 /next/layout/_partials/comments.swig 文件, 在最后一个 elseif 代码块下面添加 Gitment 的内容. 1234567891011121314151617181920212223242526272829303132333435363738// 前面的略... ...&#123;% elseif theme.changyan.appid and theme.changyan.appkey %&#125; &lt;div id="SOHUCS"&gt;&lt;/div&gt;&#123;% elseif theme.gitment.enable %&#125; &lt;div onclick="showGitment()" id="gitment_title" class="gitment_title"&gt;显示 Gitment 评论&lt;/div&gt; &lt;div id="container" style="display:none"&gt;&lt;/div&gt; &lt;link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"&gt; &lt;script src="https://imsun.github.io/gitment/dist/gitment.browser.js"&gt;&lt;/script&gt; &lt;script&gt; const myTheme = &#123; render(state, instance) &#123; const container = document.createElement('div'); container.lang = "en-US"; container.className = 'gitment-container gitment-root-container'; container.appendChild(instance.renderHeader(state, instance)); container.appendChild(instance.renderEditor(state, instance)); container.appendChild(instance.renderComments(state, instance)); container.appendChild(instance.renderFooter(state, instance)); return container; &#125; &#125; function showGitment() &#123; $("#gitment_title").attr("style", "display:none"); $("#container").attr("style", "").addClass("gitment_container"); var gitment = new Gitment(&#123; id: decodeURI(window.location.pathname), theme: myTheme, owner: '&#123;&#123; theme.gitment.owner &#125;&#125;', repo: '&#123;&#123; theme.gitment.repo &#125;&#125;', oauth: &#123; client_id: '&#123;&#123; theme.gitment.client_id &#125;&#125;', client_secret: '&#123;&#123; theme.gitment.client_secret &#125;&#125;' &#125; &#125;); gitment.render('container'); &#125; &lt;/script&gt;&#123;% endif %&#125; 然后打开 NexT 主题的_config.yml 文件，在评论相关设置的区域添加下面的代码，并根据 Gitment 文档说明来添加相应的值 12345678# Gitment commentsgitment: enable: true owner: xxx repo: xxx client_id: xxx client_secret: xxx lazy: true #lazy属性为是否直接显示评论模块，true会显示”显示评论”按钮，false会直接显示 另外，Gitment需要自己手动初始化一下来创建一个issues，不喜欢他的同学可以用Gitalk]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Gitment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置mac自带的vim语法高亮]]></title>
    <url>%2F2018%2F06%2F15%2F%E8%AE%BE%E7%BD%AEmac%E8%87%AA%E5%B8%A6%E7%9A%84vim%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[最终效果图大概是这个样子： 设置vimrcvimrc文件是vim的环境设置文件。整体的vim的设置是在 /etc/vimrc 文件中。不建议修改/etc/vimrc 文件，每个用户可以在用户根目录中设置vim，新建 ~/.vimrc touch .vimrc 在.vimrc中添加以下内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285"=========================================================================" DesCRiption: 适合自己使用的vimrc文件，for Mac/Linux/Windows, GUI/Console"" Last Change: 2017年09月11日 "" Version: 1.80""=========================================================================set nocompatible " 关闭 vi 兼容模式syntax on " 自动语法高亮colorscheme molokai " 设定配色方案set number " 显示行号set cursorline " 突出显示当前行set ruler " 打开状态栏标尺set shiftwidth=4 " 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4set softtabstop=4 " 使得按退格键时可以一次删掉 4 个空格set tabstop=4 " 设定 tab 长度为 4set nobackup " 覆盖文件时不备份set autochdir " 自动切换当前目录为当前文件所在的目录filetype plugin indent on " 开启插件set backupcopy=yes " 设置备份时的行为为覆盖set ignorecase smartcase " 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感set nowrapscan " 禁止在搜索到文件两端时重新搜索set incsearch " 输入搜索内容时就显示搜索结果set hlsearch " 搜索时高亮显示被找到的文本set noerrorbells " 关闭错误信息响铃set novisualbell " 关闭使用可视响铃代替呼叫set t_vb= " 置空错误铃声的终端代码" set showmatch " 插入括号时，短暂地跳转到匹配的对应括号" set matchtime=2 " 短暂跳转到匹配括号的时间set magic " 设置魔术set hidden " 允许在有未保存的修改时切换缓冲区，此时的修改由 vim 负责保存set guioptions-=T " 隐藏工具栏set guioptions-=m " 隐藏菜单栏set smartindent " 开启新行时使用智能自动缩进set backspace=indent,eol,start" 不设定在插入状态无法用退格键和 Delete 键删除回车符set cmdheight=1 " 设定命令行的行数为 1set laststatus=2 " 显示状态栏 (默认值为 1, 无法显示状态栏)set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\" 设置在状态行显示的信息set foldenable " 开始折叠set foldmethod=syntax " 设置语法折叠set foldcolumn=0 " 设置折叠区域的宽度setlocal foldlevel=1 " 设置折叠层数为" set foldclose=all " 设置为自动关闭折叠" nnoremap &lt;space&gt; @=((foldclosed(line('.')) &lt; 0) ? 'zc' : 'zo')&lt;CR&gt;" 用空格键来开关折叠" return OS type, eg: windows, or linux, mac, et.st..function! MySys()if has("win16") || has("win32") || has("win64") || has("win95")return "windows"elseif has("unix")return "linux"endifendfunction" 用户目录变量$VIMFILESif MySys() == "windows"let $VIMFILES = $VIM.'/vimfiles'elseif MySys() == "linux"let $VIMFILES = $HOME.'/.vim'endif" 设定doc文档目录let helptags=$VIMFILES.'/doc'" 设置字体 以及中文支持if has("win32")set guifont=Inconsolata:h12:cANSIendif" 配置多语言环境if has("multi_byte")" UTF-8 编码set encoding=utf-8set termencoding=utf-8set formatoptions+=mMset fencs=utf-8,gbkif v:lang =~? '^\(zh\)\|\(ja\)\|\(ko\)'set ambiwidth=doubleendifif has("win32")source $VIMRUNTIME/delmenu.vimsource $VIMRUNTIME/menu.vimlanguage messages zh_CN.utf-8endifelseechoerr "Sorry, this version of (g)vim was not compiled with +multi_byte"endif" Buffers操作快捷方式!nnoremap &lt;C-RETURN&gt; :bnext&lt;CR&gt;nnoremap &lt;C-S-RETURN&gt; :bprevious&lt;CR&gt;" Tab操作快捷方式!nnoremap &lt;C-TAB&gt; :tabnext&lt;CR&gt;nnoremap &lt;C-S-TAB&gt; :tabprev&lt;CR&gt;"关于tab的快捷键" map tn :tabnext&lt;cr&gt;" map tp :tabprevious&lt;cr&gt;" map td :tabnew .&lt;cr&gt;" map te :tabedit" map tc :tabclose&lt;cr&gt;"窗口分割时,进行切换的按键热键需要连接两次,比如从下方窗口移动"光标到上方窗口,需要&lt;c-w&gt;&lt;c-w&gt;k,非常麻烦,现在重映射为&lt;c-k&gt;,切换的"时候会变得非常方便.nnoremap &lt;C-h&gt; &lt;C-w&gt;hnnoremap &lt;C-j&gt; &lt;C-w&gt;jnnoremap &lt;C-k&gt; &lt;C-w&gt;knnoremap &lt;C-l&gt; &lt;C-w&gt;l"一些不错的映射转换语法（如果在一个文件中混合了不同语言时有用）nnoremap &lt;leader&gt;1 :set filetype=xhtml&lt;CR&gt;nnoremap &lt;leader&gt;2 :set filetype=css&lt;CR&gt;nnoremap &lt;leader&gt;3 :set filetype=javascript&lt;CR&gt;nnoremap &lt;leader&gt;4 :set filetype=php&lt;CR&gt;" set fileformats=unix,dos,mac" nmap &lt;leader&gt;fd :se fileformat=dos&lt;CR&gt;" nmap &lt;leader&gt;fu :se fileformat=unix&lt;CR&gt;" use Ctrl+[l|n|p|cc] to list|next|previous|jump to count the result" map &lt;C-x&gt;l &lt;ESC&gt;:cl&lt;CR&gt;" map &lt;C-x&gt;n &lt;ESC&gt;:cn&lt;CR&gt;" map &lt;C-x&gt;p &lt;ESC&gt;:cp&lt;CR&gt;" map &lt;C-x&gt;c &lt;ESC&gt;:cc&lt;CR&gt;" 让 Tohtml 产生有 CSS 语法的 html" syntax/2html.vim，可以用:runtime! syntax/2html.vimlet html_use_css=1" Python 文件的一般设置，比如不要 tab 等autocmd FileType python set tabstop=4 shiftwidth=4 expandtabautocmd FileType python map &lt;F12&gt; :!python %&lt;CR&gt;" 选中状态下 Ctrl+c 复制vmap &lt;C-c&gt; "+y" 打开javascript折叠let b:javascript_fold=1" 打开javascript对dom、html和css的支持let javascript_enable_domhtmlcss=1" 设置字典 ~/.vim/dict/文件的路径autocmd filetype javascript set dictionary=$VIMFILES/dict/javascript.dictautocmd filetype css set dictionary=$VIMFILES/dict/css.dictautocmd filetype php set dictionary=$VIMFILES/dict/php.dict"-----------------------------------------------------------------" plugin - bufexplorer.vim Buffers切换" \be 全屏方式查看全部打开的文件列表" \bv 左右方式查看 \bs 上下方式查看"-----------------------------------------------------------------"-----------------------------------------------------------------" plugin - taglist.vim 查看函数列表，需要ctags程序" F4 打开隐藏taglist窗口"-----------------------------------------------------------------if MySys() == "windows" " 设定windows系统中ctags程序的位置let Tlist_Ctags_Cmd = '"'.$VIMRUNTIME.'/ctags.exe"'elseif MySys() == "linux" " 设定windows系统中ctags程序的位置let Tlist_Ctags_Cmd = '/usr/bin/ctags'endifnnoremap &lt;silent&gt;&lt;F4&gt; :TlistToggle&lt;CR&gt;let Tlist_Show_One_File = 1 " 不同时显示多个文件的tag，只显示当前文件的let Tlist_Exit_OnlyWindow = 1 " 如果taglist窗口是最后一个窗口，则退出vimlet Tlist_Use_Right_Window = 1 " 在右侧窗口中显示taglist窗口let Tlist_File_Fold_Auto_Close=1 " 自动折叠当前非编辑文件的方法列表let Tlist_Auto_Open = 0let Tlist_Auto_Update = 1let Tlist_Hightlight_Tag_On_BufEnter = 1let Tlist_Enable_Fold_Column = 0let Tlist_Process_File_Always = 1let Tlist_Display_Prototype = 0let Tlist_Compact_Format = 1"-----------------------------------------------------------------" plugin - mark.vim 给各种tags标记不同的颜色，便于观看调式的插件。" \m mark or unmark the word under (or before) the cursor" \r manually input a regular expression. 用于搜索." \n clear this mark (i.e. the mark under the cursor), or clear all highlighted marks ." \* 当前MarkWord的下一个 \# 当前MarkWord的上一个" \/ 所有MarkWords的下一个 \? 所有MarkWords的上一个"-----------------------------------------------------------------"-----------------------------------------------------------------" plugin - NERD_tree.vim 以树状方式浏览系统中的文件和目录" :ERDtree 打开NERD_tree :NERDtreeClose 关闭NERD_tree" o 打开关闭文件或者目录 t 在标签页中打开" T 在后台标签页中打开 ! 执行此文件" p 到上层目录 P 到根目录" K 到第一个节点 J 到最后一个节点" u 打开上层目录 m 显示文件系统菜单（添加、删除、移动操作）" r 递归刷新当前目录 R 递归刷新当前根目录"-----------------------------------------------------------------" F3 NERDTree 切换map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;imap &lt;F3&gt; &lt;ESC&gt;:NERDTreeToggle&lt;CR&gt;"-----------------------------------------------------------------" plugin - NERD_commenter.vim 注释代码用的，" [count],cc 光标以下count行逐行添加注释(7,cc)" [count],cu 光标以下count行逐行取消注释(7,cu)" [count],cm 光标以下count行尝试添加块注释(7,cm)" ,cA 在行尾插入 ,并且进入插入模式。 这个命令方便写注释。" 注：count参数可选，无则默认为选中行或当前行"-----------------------------------------------------------------let NERDSpaceDelims=1 " 让注释符与语句之间留一个空格let NERDCompactSexyComs=1 " 多行注释时样子更好看"-----------------------------------------------------------------" plugin - DoxygenToolkit.vim 由注释生成文档，并且能够快速生成函数标准注释"-----------------------------------------------------------------let g:DoxygenToolkit_authorName="Asins - asinsimple AT gmail DOT com"let g:DoxygenToolkit_briefTag_funcName="yes"map &lt;leader&gt;da :DoxAuthor&lt;CR&gt;map &lt;leader&gt;df :Dox&lt;CR&gt;map &lt;leader&gt;db :DoxBlock&lt;CR&gt;map &lt;leader&gt;dc a &lt;LEFT&gt;&lt;LEFT&gt;&lt;LEFT&gt;"-----------------------------------------------------------------" plugin – ZenCoding.vim 很酷的插件，HTML代码生成" 插件最新版：http://github.com/mattn/zencoding-vim" 常用命令可看：http://nootn.com/blog/Tool/23/"-----------------------------------------------------------------"-----------------------------------------------------------------" plugin – checksyntax.vim JavaScript常见语法错误检查" 默认快捷方式为 F5"-----------------------------------------------------------------let g:checksyntax_auto = 0 " 不自动检查"-----------------------------------------------------------------" plugin - NeoComplCache.vim 自动补全插件"-----------------------------------------------------------------let g:AutoComplPop_NotEnableAtStartup = 1let g:NeoComplCache_EnableAtStartup = 1let g:NeoComplCache_SmartCase = 1let g:NeoComplCache_TagsAutoUpdate = 1let g:NeoComplCache_EnableInfo = 1let g:NeoComplCache_EnableCamelCaseCompletion = 1let g:NeoComplCache_MinSyntaxLength = 3let g:NeoComplCache_EnableSkipCompletion = 1let g:NeoComplCache_SkipInputTime = '0.5'let g:NeoComplCache_SnippetsDir = $VIMFILES.'/snippets'" &lt;TAB&gt; completion.inoremap &lt;expr&gt;&lt;TAB&gt; pumvisible() ? "\&lt;C-n&gt;" : "\&lt;TAB&gt;"" snippets expand keyimap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)smap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)"-----------------------------------------------------------------" plugin - matchit.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转" % 正向匹配 g% 反向匹配" [% 定位块首 ]% 定位块尾"-----------------------------------------------------------------"-----------------------------------------------------------------" plugin - vcscommand.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转" SVN/git管理工具"-----------------------------------------------------------------"-----------------------------------------------------------------" plugin – a.vim"----------------------------------------------------------------- 设置颜色主题进入对应目录准备颜色文件，没有就创建对应目录和文件 1234567daihui@daihuideMBP ~ cd .vim/colorsdaihui@daihuideMBP ~/.vim/colors pwd/Users/daihui/.vim/colors# 在~/.vim/colors目录下新建一个颜色文件daihui@daihuideMBP ~/.vim/colors touch molokai.vim molokai.vim 文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212" Vim color file"" Author: Tomas Restrepo &lt;tomas@winterdom.com&gt;"" Note: Based on the monokai theme for textmate" by Wimer Hazenberg and its darker variant" by Hamish Stuart Macpherson"hi clearset background=darkif version &gt; 580 " no guarantees for version 5.8 and below, but this makes it stop " complaining hi clear if exists("syntax_on") syntax reset endifendiflet g:colors_name="molokai"if exists("g:molokai_original") let s:molokai_original = g:molokai_originalelse let s:molokai_original = 0endifhi Boolean guifg=#AE81FFhi Character guifg=#E6DB74hi Number guifg=#AE81FFhi String guifg=#E6DB74hi Conditional guifg=#F92672 gui=boldhi Constant guifg=#AE81FF gui=boldhi Cursor guifg=#000000 guibg=#F8F8F0hi Debug guifg=#BCA3A3 gui=boldhi Define guifg=#66D9EFhi Delimiter guifg=#8F8F8Fhi DiffAdd guibg=#13354Ahi DiffChange guifg=#89807D guibg=#4C4745hi DiffDelete guifg=#960050 guibg=#1E0010hi DiffText guibg=#4C4745 gui=italic,boldhi Directory guifg=#A6E22E gui=boldhi Error guifg=#960050 guibg=#1E0010hi ErrorMsg guifg=#F92672 guibg=#232526 gui=boldhi Exception guifg=#A6E22E gui=boldhi Float guifg=#AE81FFhi FoldColumn guifg=#465457 guibg=#000000hi Folded guifg=#465457 guibg=#000000hi Function guifg=#A6E22Ehi Identifier guifg=#FD971Fhi Ignore guifg=#808080 guibg=bghi IncSearch guifg=#C4BE89 guibg=#000000hi Keyword guifg=#F92672 gui=boldhi Label guifg=#E6DB74 gui=nonehi Macro guifg=#C4BE89 gui=italichi SpecialKey guifg=#66D9EF gui=italichi MatchParen guifg=#000000 guibg=#FD971F gui=boldhi ModeMsg guifg=#E6DB74hi MoreMsg guifg=#E6DB74hi Operator guifg=#F92672" complete menuhi Pmenu guifg=#66D9EF guibg=#000000hi PmenuSel guibg=#808080hi PmenuSbar guibg=#080808hi PmenuThumb guifg=#66D9EFhi PreCondit guifg=#A6E22E gui=boldhi PreProc guifg=#A6E22Ehi Question guifg=#66D9EFhi Repeat guifg=#F92672 gui=boldhi Search guifg=#FFFFFF guibg=#455354" marks columnhi SignColumn guifg=#A6E22E guibg=#232526hi SpecialChar guifg=#F92672 gui=boldhi SpecialComment guifg=#465457 gui=boldhi Special guifg=#66D9EF guibg=bg gui=italichi SpecialKey guifg=#888A85 gui=italicif has("spell") hi SpellBad guisp=#FF0000 gui=undercurl hi SpellCap guisp=#7070F0 gui=undercurl hi SpellLocal guisp=#70F0F0 gui=undercurl hi SpellRare guisp=#FFFFFF gui=undercurlendifhi Statement guifg=#F92672 gui=boldhi StatusLine guifg=#455354 guibg=fghi StatusLineNC guifg=#808080 guibg=#080808hi StorageClass guifg=#FD971F gui=italichi Structure guifg=#66D9EFhi Tag guifg=#F92672 gui=italichi Title guifg=#ef5939hi Todo guifg=#FFFFFF guibg=bg gui=boldhi Typedef guifg=#66D9EFhi Type guifg=#66D9EF gui=nonehi Underlined guifg=#808080 gui=underlinehi VertSplit guifg=#808080 guibg=#080808 gui=boldhi VisualNOS guibg=#403D3Dhi Visual guibg=#403D3Dhi WarningMsg guifg=#FFFFFF guibg=#333333 gui=boldhi WildMenu guifg=#66D9EF guibg=#000000if s:molokai_original == 1 hi Normal guifg=#F8F8F2 guibg=#272822 hi Comment guifg=#75715E hi CursorLine guibg=#3E3D32 hi CursorColumn guibg=#3E3D32 hi LineNr guifg=#BCBCBC guibg=#3B3A32 hi NonText guifg=#BCBCBC guibg=#3B3A32else hi Normal guifg=#F8F8F2 guibg=#1B1D1E hi Comment guifg=#465457 hi CursorLine guibg=#293739 hi CursorColumn guibg=#293739 hi LineNr guifg=#BCBCBC guibg=#232526 hi NonText guifg=#BCBCBC guibg=#232526end"" Support for 256-color terminal"if &amp;t_Co &gt; 255 hi Boolean ctermfg=135 hi Character ctermfg=144 hi Number ctermfg=135 hi String ctermfg=144 hi Conditional ctermfg=161 cterm=bold hi Constant ctermfg=135 cterm=bold hi Cursor ctermfg=16 ctermbg=253 hi Debug ctermfg=225 cterm=bold hi Define ctermfg=81 hi Delimiter ctermfg=241 hi DiffAdd ctermbg=24 hi DiffChange ctermfg=181 ctermbg=239 hi DiffDelete ctermfg=162 ctermbg=53 hi DiffText ctermbg=102 cterm=bold hi Directory ctermfg=118 cterm=bold hi Error ctermfg=219 ctermbg=89 hi ErrorMsg ctermfg=199 ctermbg=16 cterm=bold hi Exception ctermfg=118 cterm=bold hi Float ctermfg=135 hi FoldColumn ctermfg=67 ctermbg=16 hi Folded ctermfg=67 ctermbg=16 hi Function ctermfg=118 hi Identifier ctermfg=208 hi Ignore ctermfg=244 ctermbg=232 hi IncSearch ctermfg=193 ctermbg=16 hi Keyword ctermfg=161 cterm=bold hi Label ctermfg=229 cterm=none hi Macro ctermfg=193 hi SpecialKey ctermfg=81 hi MatchParen ctermfg=16 ctermbg=208 cterm=bold hi ModeMsg ctermfg=229 hi MoreMsg ctermfg=229 hi Operator ctermfg=161 " complete menu hi Pmenu ctermfg=81 ctermbg=16 hi PmenuSel ctermbg=244 hi PmenuSbar ctermbg=232 hi PmenuThumb ctermfg=81 hi PreCondit ctermfg=118 cterm=bold hi PreProc ctermfg=118 hi Question ctermfg=81 hi Repeat ctermfg=161 cterm=bold hi Search ctermfg=253 ctermbg=66 " marks column hi SignColumn ctermfg=118 ctermbg=235 hi SpecialChar ctermfg=161 cterm=bold hi SpecialComment ctermfg=245 cterm=bold hi Special ctermfg=81 ctermbg=232 hi SpecialKey ctermfg=245 hi Statement ctermfg=161 cterm=bold hi StatusLine ctermfg=238 ctermbg=253 hi StatusLineNC ctermfg=244 ctermbg=232 hi StorageClass ctermfg=208 hi Structure ctermfg=81 hi Tag ctermfg=161 hi Title ctermfg=166 hi Todo ctermfg=231 ctermbg=232 cterm=bold hi Typedef ctermfg=81 hi Type ctermfg=81 cterm=none hi Underlined ctermfg=244 cterm=underline hi VertSplit ctermfg=244 ctermbg=232 cterm=bold hi VisualNOS ctermbg=238 hi Visual ctermbg=235 hi WarningMsg ctermfg=231 ctermbg=238 cterm=bold hi WildMenu ctermfg=81 ctermbg=16 hi Normal ctermfg=252 ctermbg=233 hi Comment ctermfg=59 hi CursorLine ctermbg=234 cterm=none hi CursorColumn ctermbg=234 hi LineNr ctermfg=250 ctermbg=234 hi NonText ctermfg=250 ctermbg=234end 重启vim再进来看看原文]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下删除launchpad还有残留图标的应用]]></title>
    <url>%2F2018%2F05%2F16%2FMac%E4%B8%8B%E5%88%A0%E9%99%A4launchpad%E8%BF%98%E6%9C%89%E6%AE%8B%E7%95%99%E5%9B%BE%E6%A0%87%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[有时候用户在删除自己应用的时候在应用程序里直接右键“移到废纸楼”，有的应用这样删除后在launchpad里还有残留的图标，按住option键也没有删除标记可以删除该图标。这让人很蛋疼，但是可以通过下面这个小技巧将该图标删除，方法如下： 打开launchpad下列三个放都可以打开launchpad fn + F4（F1-F12是正常使用情况） F4（F1-F12使用需要借助fn键使用） 四个指头抓一下 具体操作1. 长按control+option+command，看到图标抖动2. 单击待删除图标，图标中心出现白色问号3. 松开按住的三个快捷键（control+option+command）4. 再次按下这三个快捷键，图标左上角会出现“✘”，点击删除]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac删除</tag>
        <tag>launchpad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git简明指南]]></title>
    <url>%2F2018%2F04%2F24%2FGit%E7%AE%80%E6%98%8E%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[安装下载 git OSX 版下载 git Windows 版下载 git Linux 版创建新仓库创建新文件夹，打开，然后执行1git init 以创建新的 git 仓库。 检出仓库执行如下命令以创建一个本地仓库的克隆版本：1git clone /path/to/repository 如果是远端服务器上的仓库，你的命令会是这个样子：1git clone username@host:/path/to/repository 工作流你的本地仓库由 git 维护的三棵“树”组成。第一个是你的工作目录，它持有实际文件；第二个是暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。 添加和提交你可以提出更改（把它们添加到暂存区），使用如下命令：12git add &lt;filename&gt;git add * 这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：1git commit -m &quot;代码提交信息&quot; 现在，你的改动已经提交到了HEAD，但是还没到你的远端仓库。 推送改动你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：1git push origin master 可以把 master 换成你想要推送的任何分支。 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：1git remote add origin &lt;server&gt; 如此你就能够将你的改动推送到所添加的服务器上去了。 分支分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。 创建一个叫做“feature_x”的分支，并切换过去：1git checkout -b feature_x 切换回主分支：1git checkout master 再把新建的分支删掉：1git branch -d feature_x 除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：1git push origin &lt;branch&gt; 更新与合并要更新你的本地仓库至最新改动，执行：1git pull 以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。要合并其他分支到你的当前分支（例如 master），执行：1git merge &lt;branch&gt; 在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。这时候就需要你修改这些文件来手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功：1git add &lt;filename&gt; 在合并改动之前，你可以使用如下命令预览差异：1git diff &lt;source_branch&gt; &lt;target_branch&gt; 标签为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 1.0.0 的标签：1git tag 1.0.0 1b2e1d63ff 1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID：1git log 你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。 log如果你想了解本地仓库的历史记录，最简单的命令就是使用:1git log 你可以添加一些参数来修改他的输出，从而得到自己想要的结果。 只看某一个人的提交记录:1git log --author=bob 一个压缩后的每一条提交记录只占一行的输出:1git log --pretty=oneline 或者你想通过ASCII艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签:1git log --graph --oneline --decorate --all 看看哪些文件改变了:1git log --name-status 这些只是你可以使用的参数中很小的一部分。更多的信息，参考：1git log --help 替换本地改动假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：1git checkout -- &lt;filename&gt; 此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。 假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：12git fetch origingit reset --hard origin/master 实用小贴士内建的图形化 git：1gitk 彩色的 git 输出：1git config color.ui true 显示历史记录时，每个提交的信息只显示一行：1git config format.pretty oneline 交互式添加文件到暂存区：1git add -i 链接与资源图形化客户端GitX (L) (OSX, 开源软件)Tower (OSX)Source Tree (OSX, 免费)GitHub for Mac (OSX, 免费)GitBox (OSX, App Store) 指南和手册Git 社区参考书专业 Git像 git 那样思考GitHub 帮助图解 Git git命令大全：]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios基本使用说明]]></title>
    <url>%2F2018%2F04%2F11%2FAxios%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[Axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 特点 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 浏览器支持 Latest ✔ Latest ✔ Latest ✔ Latest ✔ Latest ✔ 8+ ✔ 安装使用 npm: 1$ npm install axios 使用 bower: 1$ bower install axios 使用 cdn: 1&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; 示例执行 GET 请求 12345678910111213141516171819202122232425262728293031// 为给定 ID 的 user 创建请求axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 可选地，上面的请求可以这样做axios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 想使用异步/等待？将`async`关键字添加到外部函数/方法中。async function getUser() &#123; try &#123; const response = await axios.get('/user?ID=12345'); console.log(response); &#125; catch (error) &#123; console.error(error); &#125;&#125; 注意: async/await是ECMAScript 2017的一部分，在Internet Explorer和旧版浏览器中不支持，因此请谨慎使用。 执行 POST 请求 12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行多个并发请求 123456789101112function getUserAccount() &#123; return axios.get('/user/12345');&#125;function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; //两个请求均已完成 &#125;)); axios API请求可以通过传递相关配置来完成 axios. axios(config) 123456789// 发送一个POST请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;); 123456789// GET请求远程图像axios(&#123; method:'get', url:'http://bit.ly/2mTM3nY', responseType:'stream'&#125;) .then(function(response) &#123; response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))&#125;); axios(url[, config]) 12// 发送GET请求（默认方法）axios('/user/12345'); 请求方法别名为方便起见，为所有支持的请求方法提供了别名 axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.options(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]]) 注意: 在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 并发处理并发请求的助手函数 axios.all(iterable)axios.spread(callback) 创建一个实例您可以使用自定义配置创建一个新的axios实例。 axios.create([config]) 12345const instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-Custom-Header': 'foobar'&#125;&#125;); 实例方法以下是可用的实例方法。指定的配置将与实例的配置合并 axios#request(config)axios#get(url[, config])axios#delete(url[, config])axios#head(url[, config])axios#options(url[, config])axios#post(url[, data[, config]])axios#put(url[, data[, config]])axios#patch(url[, data[, config]]) 请求配置这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&#123; // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // 默认 // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream // 您可以修改headers对象。 transformRequest: [function (data, headers) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个普通对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (例如： https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属： FormData, File, Blob // - Node专属: Stream, Buffer data: &#123; firstName: 'Fred' &#125;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 adapter: function (config) &#123; /* ... */ &#125;, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: 'janedoe', password: 's00pers3cret' &#125;, // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // 默认 // `responseEncoding` 表示用于解码响应的编码 // 注意：忽略'stream'或客户端请求的`responseType` responseEncoding: 'utf8', // 默认 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // 默认 // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // 默认 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。 // 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)， // promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认 &#125;, // `maxRedirects` 定义在 node.js 中遵循的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // default // `socketPath` 定义了一个在Socket.js中使用的UNIX套接字。 // 例如'/var/run/docker.sock'发送请求到docker守护进程。 // 只能指定`socketPath`或`proxy`。 // 如果两者都指定，则使用`socketPath`。 socketPath: null, // 默认 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 'proxy' 定义代理服务器的主机名称和端口 // 使用'false'来禁用代理，忽略环境变量。 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: '127.0.0.1', port: 9000, auth: &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 响应结构某个请求的响应包含以下信息 123456789101112131415161718192021&#123; // `data` 由服务器提供的响应 data: &#123;&#125;, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: 'OK', // `headers` t服务器响应的头 // 所有的 header 都是小写 headers: &#123;&#125;, // `config` 是为请求提供给`axios`的配置 config: &#123;&#125;, // `request` 是生成此响应的请求 // 它是node.js中的最后一个ClientRequest实例和浏览器请求的XMLHttpRequest实例 request: &#123;&#125;&#125; 使用 then 时，你将接收下面这样的响应： 12345678axios.get('/user/12345') .then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); &#125;); 在使用 catch 时，或传递rejection callback 作为 then 的第二个参数时, 响应可以通过 error 对象可被使用，正如在错误处理 这一节所讲. 配置的默认值/defaults你可以指定将被用在各个请求的配置默认值 全局axios默认值123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 自定义实例默认值1234567// 创建实例时设置配置的默认值const instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);// 在实例已创建后修改默认值instance.defaults.headers.common['Authorization'] = AUTH_TOKEN; 配置的优先顺序配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子： 123456789101112// 使用由库提供的配置的默认值来创建实例// 此时超时配置的默认值是 `0`const instance = axios.create();// 覆写库的超时默认值// 现在，在超时前，所有请求都会等待 2.5 秒instance.defaults.timeout = 2500;// 为已知需要花费很长时间的请求覆写超时设置instance.get('/longRequest', &#123; timeout: 5000&#125;); 拦截器在请求或响应被 then 或 catch 处理前拦截它们。 1234567891011121314151617// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); 如果你想在稍后移除拦截器，可以这样： 12const myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器 12const instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 错误处理1234567891011121314151617axios.get('/user/12345') .catch(function (error) &#123; if (error.response) &#123; // 请求已发出，但服务器响应的状态码不在 2xx 范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); &#125; else if (error.request) &#123; // 请求被提出，但没有接收到响应 // `error.request`是在浏览器中一个XMLHttpRequest的实例和node.js中http.ClientRequest的实例 console.log(error.request); &#125; else &#123; // 设置触发错误 console.log('Error', error.message); &#125; console.log(error.config); &#125;); 您可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。 12345axios.get('/user/12345', &#123; validateStatus: function (status) &#123; return status &lt; 500; // 仅当状态码大于或等于500时才拒绝 &#125;&#125;) 取消使用 cancel token 取消请求 Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。 可以使用 CancelToken.source 工厂创建取消令牌，如下所示： 123456789101112131415161718192021const CancelToken = axios.CancelToken;const source = CancelToken.source();axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;);axios.post('/user/12345', &#123; name: 'new name'&#125;, &#123; cancelToken: source.token&#125;)// 取消请求（消息参数是可选的）source.cancel('Operation canceled by the user.'); 还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token： 123456789101112const CancelToken = axios.CancelToken;let cancel;axios.get('/user/12345', &#123; cancelToken: new CancelToken(function executor(c) &#123; // executor 函数接收一个 cancel 函数作为参数 cancel = c; &#125;)&#125;);// 取消请求cancel(); 注意: 可以使用同一个 cancel token 取消多个请求 使用 application/x-www-form-urlencoded 格式默认情况下，axios将JavaScript对象序列化为JSON。要以application/x-www-form-urlencoded 格式发送数据，您可以使用以下选项之一。 浏览器在浏览器中，您可以使用以下URLSearchParams API: 1234const params = new URLSearchParams();params.append('param1', 'value1');params.append('param2', 'value2');axios.post('/foo', params); 请注意， URLSearchParams 并非所有浏览器都支持(请参阅 caniuse.com), 但可以使用 polyfill(请确保填充全局环境)。或者，您可以使用qs 库对数据进行编码： 12const qs = require('qs');axios.post('/foo', qs.stringify(&#123; 'bar': 123 &#125;)); 或者以另一种方式（ES6）， 123456789import qs from 'qs';const data = &#123; 'bar': 123 &#125;;const options = &#123; method: 'POST', headers: &#123; 'content-type': 'application/x-www-form-urlencoded' &#125;, data: qs.stringify(data), url,&#125;;axios(options); Node.js在node.js中，您可以querystring按如下方式使用模块： 12const querystring = require('querystring');axios.post('http://something.com/', querystring.stringify(&#123; foo: 'bar' &#125;)); 您也可以使用该qs库. Semver在axios达到1.0 发布之前，将通过新的次要版本发布重大更改。例如 0.5.1, 和 0.5.4将具有相同的API, 但 0.6.0 会有重大更改。 承诺aaxios依赖于原生ES6 Promise实现的支持。如果您的环境不支持ES6 Promise，则可以polyfill。 TypeScriptaxios包括TypeScript定义。12import axios from 'axios';axios.get('/user?ID=12345'); 资源 更新日志 升级指南 生态系统 C参与指南 行为守则]]></content>
      <categories>
        <category>翻译</category>
        <category>README</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTerm 2和Oh My Zsh代替自带terminal教程简单整理]]></title>
    <url>%2F2018%2F04%2F02%2FiTerm-2%E5%92%8COh-My-Zsh%E4%BB%A3%E6%9B%BF%E8%87%AA%E5%B8%A6terminal%E6%95%99%E7%A8%8B%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[最终效果图大概是这个样子： 但是如果你有用到Atom编辑器的控制台插件的话可能会由于字体原因特殊的符号显示不了，就像我这样： 1. 首先下载iterm22. 打开iTerm 23. 输入下面指令安装oh-my-zsh curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh 4. 接下来安装Powerline在官网有教程，我们只需要执行官网第一条安装指令就行 如果你的终端能够正常执行pip指令，那么直接执行下面的指令可以完成安装 pip install powerline-status 如果没有，则先执行安装pip指令 sudo easy_install pip 5. 下载、安装库字体库1）将工程下载下来后cd到install.sh文件所在目录 2）执行指令安装字体库 执行./install.sh指令安装所有Powerline字体 安装完成后提示所有字体均已下载到/Users/superdanny/Library/Fonts路径下 All Powerline fonts installed to /Users/superdanny/Library/Fonts 6. 设置iTerm 2的Regular Font 和 Non-ASCII Font安装完字体库之后，把iTerm 2的设置里的Profile中的Text 选项卡中里的Regular Font和Non-ASCII Font的字体都设置成 Powerline的字体，我这里设置的字体是12pt Meslo LG S DZ Regular for Powerline 设置iTerm 2设置iTerm 2 7. 配色方案1）安装配色方案 进入刚刚下载的工程的solarized/iterm2-colors-solarized下双击Solarized Dark.itermcolors和Solarized Light.itermcolors两个文件就可以把配置文件导入到 iTerm2 里 2）配置配色方案 通过load presets选择刚刚安装的配色主题即可 配色方案配色方案 8. 使用agnoster主题1）下载agnoster主题 到下载的工程里面运行install文件,主题将安装到~/.oh-my-zsh/themes目录下 2）设置该主题进入~/.zshrc打开.zshrc文件，然后将ZSH_THEME后面的字段改为agnoster。ZSH_THEME=”agnoster”（agnoster即为要设置的主题） 9. 增加指令高亮效果——zsh-syntax-highlighting指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮 1）首先在~/.oh-my-zsh/custom/plugins/路径下执行git clone https://github.com/zsh-users/zsh-syntax-highlighting.git到了此路径:~/.oh-my-zsh/custom/plugins/ 2）然后在~/.zshrc最后添加了下面两句：“plugins=(zsh-syntax-highlighting)source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh” 3）最后执行 source ~/.zshrc 这样就同时配置好了zsh和oh-my-zsh。有两点需要注意(摘自官网):Note the source command must be at the end of ~/.zshrc.Note that zsh-syntax-highlighting must be the last plugin sourced, so make it the last element of the $plugins array. 问题解答区 启动iTerm 2 默认使用dash改用zsh解决方法： chsh -s /bin/zsh 如果想切换回原来的dash： chsh -s /bin/bash 卸载oh my zsh，在命令行输入如下命令，回车即可： uninstall_oh_my_zsh 执行指令pip install powerline-status出错解决方法：需要下载苹果官方的Command line。必須官方工具下载最新版 Command Line ⌘+Q关闭iTerm 2 时每次弹窗提示问题：iTerm 2 中，进入Preference-General-Closing栏目，将Confirm “Quit iTerm2(⌘Q)” command选项勾选去掉就行 找不到.zshrc文件问题：我这里将原作者的.zshrc文件分享出来。供大家下载网盘 路径前缀的XX@XX太长，缩短问题：在此感谢评论区的朋友提供的解决方案。在~/.oh-my-zsh/themes路径下找到agnoster.zsh-theme文件，可使用文本工具打开，将里面的build_prompt下的prompt_context字段在前面加#注释掉即可。 执行指令pip install powerline-status出错，下载了Command Line也没有办法,是权限原因造成的,执行: pip install powerline-status –user 原文]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>iTerm 2</tag>
        <tag>Oh My Zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下安装mysql5.7完整步骤及问题整理]]></title>
    <url>%2F2018%2F03%2F19%2FMac%E4%B8%8B%E5%AE%89%E8%A3%85mysql5-7%E5%AE%8C%E6%95%B4%E6%AD%A5%E9%AA%A4%E5%8F%8A%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[安装参考以下这个博客: Mac下安装mysql5.7完整步骤 问题 “MAC下安装Mysql找不到my.cnf配置文件的问题”，参考：MAC 安装MySQL的my.cnf配置文件 “Warning: World-writable config file ‘/etc/my.cnf’ is ignored”，参考：World-writable]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac安装Mysql</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10下.Net Framework 3.5无法安装【错误代码0x800F081F】]]></title>
    <url>%2F2018%2F03%2F18%2FWin10%E4%B8%8B-Net-Framework-3-5%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[首先下载 .Net Framework 3.5. 将下载的文件复制到复制到 【C盘】 的 【Windows】 文件夹，然后后在“命令提示符（管理员）”中执行下面的命令： dism /online /Enable-Feature /FeatureName:NetFx3 /Source:”%windir%” /LimitAccess 其他: Windows 10下安装有的软件需要 .Net Framework 3.5的环境。默认是没有开启的，一般情况下可以【右键开始】菜单，选择【程序和功能】然后再选择【启用或关闭Windows功能】里的第一项【.Net Framework 3.5(包括.NET 2.0和3.0) 再一个就是去官网下一个手动安装一下也行，这两种方法都不行再用上面那个方法，这样大部分人的问题应该都可以解决了。]]></content>
      <categories>
        <category>OS</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Framework3.5无法安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机VirtualBox中挂载新硬盘]]></title>
    <url>%2F2018%2F03%2F18%2F%E8%99%9A%E6%8B%9F%E6%9C%BAVirtualBox%E4%B8%AD%E6%8C%82%E8%BD%BD%E6%96%B0%E7%A1%AC%E7%9B%98%2F</url>
    <content type="text"><![CDATA[在VirtualBox中装好Linux后，发现硬盘空间太小，怎样才能增加硬盘容量？那就是再建一个硬盘： 添加新硬盘 设置 -&gt; Storage(存储) -&gt; SATA控制器-&gt;右击，选择”添加虚拟硬盘”然后，根据需求创建合适的硬盘 重启虚拟机 查看现有系统的磁盘空间 sudo fdisk -l 可看到新加的虚拟硬盘，一般名为：Disk /dev/sdb 给新加的硬盘分区 fdisk /dev/sdb 键入m,可看到帮助信息 command (m for help):m 增加新分区 command (m for help):n 选择基本分区，输入：p 建一个分区 Partition number(1-4): 回车 First cylinder (1-15908,default 1):Enter 写入并退出 command (m for help):w 格式化磁盘分区 用ext4格式对/dev/sdb1进入格式化 sudo mkfs.ext4 /dev/sdb1 挂载分区 创建新的挂载点 sudo mkdir /work 将新磁盘分区挂载到/work目录下 sudo mount -t ext4 /dev/sdb1 /work 查看挂载 df -h 可以看到新加的硬盘：/dev/sdb1 开机自动挂载 修改文件 sudo vim /etc/fstab 在最后一行加入： /dev/sdb1 /work ext4 errors=remount-ro 0 1 完成! 补充：为挂载点扩容假设之前我们有一个挂载点为 /mydata ，但该 /mydata 已经写满，但依然想在 /mydata 下添加新的数据，这时可以使用软链接将 /mydata 软链接到一个新挂载的磁盘分区上以实现扩容。具体步骤如下。 1. 创建一个目录，以便稍后作为挂载点： mkdir /newdata 2. 将 /dev/sdb1 分区挂载到 /newdata 下： mount /dev/sdb1 /newdata 3. 新建 /mydata 到 /newdata 的软链接： ln -s /newdata /mydata 此时在 /mydata 目录下会有一个软链接文件 newdata 指向 /newdata/ ，即 newdata-&gt; /newdata/ 。这样一来，只要我们向 /mydata/newdata 下写文件，实际就写入了 /newdata/ 目录下，相当于我们为原 /mydata 挂载点新增加了一部分使用空间。 也可以手动指定该软链接文件的名称： ln -s /newdata /mydata/customed_name 这样就有 /mydata/customed_name -&gt; /newdata 注： 我们也可以利用软链接的这一用途，将比较大的日志文件链接到存储空间充足的磁盘分区的挂载点上。 举例来说，如果 /opt/tomcat/logs/catalina.out 日志文件输入很多，占用空间很大，而 /opt 挂载点中所剩空间已经不多，存在溢出风险，通过下面两步就可以将该日志文件软链接到另一个磁盘分区的挂载点上： touch /newdata/catalina_link.outln -sf /newdata/catalina_link.out /opt/tomcat/logs/catalina.out 这里还需要注意三点： 一是必须先创建一个被链接的文件，否则软链接后失败； 二是强制软链接会清空之前 /opt/tomcat/logs/catalina.out 日志文件中的全部内容清空； 三是需要重启 tomcat 目录后才能继续向 /opt/tomcat/logs/catalina.out 写入。]]></content>
      <categories>
        <category>OS</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>Linux挂载硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常见异常总结]]></title>
    <url>%2F2018%2F03%2F18%2FJava%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[java.lang.NullPointerException(空指针异常) 调用了未经初始化的对象或者是不存在的对象 经常出现在创建图片，调用数组这些操作中，比如图片未经初始化，或者图片创建时的路径错误等等。对数组操作中出现空指针，即把数组的初始化和数组元素的初始化混淆起来了。数组的初始化是对数组分配需要的空间，而初始化后的数组，其中的元素并没有实例化，依然是空的，所以还需要对每个元素都进行初始化（如果要调用的话）。 java.lang.ClassNotFoundException 指定的类不存在 这里主要考虑一下类的名称和路径是否正确即可，通常都是程序试图通过字符串来加载某个类时可能引发 异常 比如：调用Class.forName(); 或者调用ClassLoad的finaSystemClass();或者LoadClass(); java.lang.NumberFormatException 字符串转换为数字异常 当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常.如现在讲字符型的数据“123456”转换为数值型数据时，是允许的。但是如果字符型数据中包含了非数字型的字符，如123#56，此时转换为数值型时就会出现异常。系统就会捕捉到这个异常，并进行处理. java.lang.IndexOutOfBoundsException 数组下标越界异常 查看调用的数组或者字符串的下标值是不是超出了数组的范围，一般来说，显示（即直接用常数当下标）调用不太容易出这样的错，但隐式（即用变量表示下标）调用就经常出错了，还有一种情况，是程序中定义的数组的长度是通过某些特定方法决定的，不是事先声明的，这个时候，最好先查看一下数组的length，以免出现这个异常。 java.lang.IllegalArgumentException 方法的参数错误 比如g.setColor(int red,int green,int blue)这个方法中的三个值，如果有超过２５５的也会出现这个异常，因此一旦发现这个异常，我们要做的，就是赶紧去检查一下方法调用中的参数传递是不是出现了错误。 java.lang.IllegalAccessException 没有访问权限 当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。对程序中用了Package的情况下要注意这个异常 java.lang.ArithmeticException 数学运算异常 当算术运算中出现了除以零这样的运算就会出这样的异常。 java.lang.ClassCastException 数据类型转换异常 当试图将对某个对象强制执行向下转型，但该对象又不可转换又不可转换为其子类的实例时将引发该异常，如下列代码。 123Object obj = new Integer(0);String str = obj;java.lang.FileNotFoundException java.lang.FileNotFoundException 文件未找到异常 当程序试图打开一个不存在的文件进行读写时将会引发该异常。该异常由FileInputStream,FileOutputStream,RandomAccessFile的构造器声明抛出即使被操作的文件存在，但是由于某些原因不可访问，比如打开一个只读文件进行写入，这些构造方法仍然会引发异常 java.lang.ArrayStoreException 数组存储异常 当试图将类型不兼容类型的对象存入一个Object[]数组时将引发异常 123Object[] obj = new String[3];obj[0] = new Integer(0);java.lang.NoSuchMethodException java.lang.NoSuchMethodException 方法不存在异常 当程序试图通过反射来创建对象，访问(修改或读取)某个方法，但是该方法不存在就会引发异常 java.lang.NoSuchFiledException 方法不存在异常 当程序试图通过反射来创建对象，访问(修改或读取)某个filed，但是该filed不存在就会引发异常 java.lang.EOFException 文件已结束异常 当程序在输入的过程中遇到文件或流的结尾时，引发异常。因此该异常用于检查是否达到文件或流的结尾 java.lang.InstantiationException 实例化异常 当试图通过Class的newInstance()方法创建某个类的实例,但程序无法通过该构造器来创建该对象时引发Class对象表示一个抽象类，接口，数组类，基本类型该Class表示的类没有对应的构造器 java.lang.InterruptedException 被中止异常 当某个线程处于长时间的等待、休眠或其他暂停状态，而此时其他的线程通过Thread的interrupt方法终止该线程时抛出该异常。 java.lang.CloneNotSupportedException 不支持克隆异常 当没有实现Cloneable接口或者不支持克隆方法时,调用其clone()方法则抛出该异常。 java.lang.OutOfMemoryException 内存不足错误 当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。 java.lang.NoClassDefFoundException 未找到类定义错误 当Java虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误。 违背安全原则异常：SecturityException 操作数据库异常：SQLException 输入输出异常：IOException 通信异常：SocketException]]></content>
      <categories>
        <category>Java</category>
        <category>异常</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop伪分布式搭建-(4)]]></title>
    <url>%2F2018%2F03%2F18%2FHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-4%2F</url>
    <content type="text"><![CDATA[生成ssh免登陆密钥 进入到/dh/下的home目录(隐藏) cd ~/.sshssh-keygen -t rsa （一直回车） 执行完这个命令后，会生成两个文件id_rsa（私钥）、id_rsa.pub（公钥） 将公钥拷贝到要免登陆的机器上 ssh-copy-id -i localhost (ssh-copy-id -i 要免登陆的机器的IP)或者cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop伪分布式搭建-(3)]]></title>
    <url>%2F2018%2F03%2F18%2FHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-3%2F</url>
    <content type="text"><![CDATA[安装hadoop2.4.1（或其他更高版本&lt;最好用更高的64位版本，免得重新编译&gt;）注意：hadoop2.x的配置文件$HADOOP_HOME/etc/hadoop伪分布式需要修改5个配置文件 上传hadoop并解压到指定目录同jdk一样,上传Hadoop的包到本目录,并在root目录下创建/dh/这个目录,将Hadoop解压到该目录 配置hadoop hadoop-env.sh文件 vim hadoop-env.sh 1export JAVA_HOME=/usr/java/jdk1.7.0_79 core-site.xml文件 vim core-site.xml 12345678910&lt;!--设定NameNode地址 --&gt;&lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://dh01:9000&lt;/value&gt; &lt;!--或者把dh01换成对应IP--&gt;&lt;/property&gt;&lt;!-- 指定hadoop运行时产生文件的存储目录 --&gt;&lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/dh/hadoop-2.4.1/tmp&lt;/value&gt;&lt;/property&gt; hdfs-site.xml文件 vim hdfs-site.xml 12345&lt;!-- 指定HDFS副本的数量 --&gt;&lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt;&lt;!--因为为伪分布式,所以只有一个副本--&gt;&lt;/property&gt; mapred-site.xml文件 #重命名mv mapred-site.xml.template mapred-site.xml#打开重命名后的文件vim mapred-site.xml 12345&lt;!-- 指定mapreduce运行在YARN上 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt; yarn-site.xml文件 12345678910&lt;!-- 指定YARN的老大（ResourceManager）的地址 --&gt;&lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;dh01&lt;/value&gt;&lt;/property&gt;&lt;!-- mapreduce获取数据的方式 --&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt; 将hadoop添加到环境变量 vim /etc/proflie 123export JAVA_HOME=/usr/java/jdk1.7.0_79export HADOOP_HOME=/dh/hadoop-2.4.1export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$HADOOP_HOME/lib 刷新配置文件 source /etc/profile 格式化namenode（是对namenode进行初始化） hdfs namenode -format (hadoop namenode -format) 启动hadoop先启动HDFS sbin/start-dfs.sh 再启动YARN sbin/start-yarn.sh 验证是否启动成功使用jps命令验证 jsp 12345627408 NameNode28218 Jps27643 SecondaryNameNode28066 NodeManager27803 ResourceManager27512 DataNode http://192.168.8.88:50070 （HDFS管理界面） 在这个文件中添加linux主机名和IP的映射关系C:\Windows\System32\drivers\etc\hosts下添加:1192.168.1.66 dh01 打开：http://192.168.8.88:8088验证 （mapreduce管理界面）]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop伪分布式搭建-(2)]]></title>
    <url>%2F2018%2F03%2F18%2FHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-2%2F</url>
    <content type="text"><![CDATA[安装JDK 从Windows上传jdk到虚拟机 你可以用FlashFXP/FileZilla/SecureCRT将jdk-7u79-linux-x64.gz传到Linux上。假设现在你已经传到了虚拟机的root目录下 解压jdk mkdir /usr/javatar -zxvf jdk-7u79-linux-x64.gz -C /usr/java/ 将java添加到环境变量中 vim /etc/profile 12export JAVA_HOME=/usr/java/jdk1.7.0_79 export PATH=$PATH:$JAVA_HOME/bin 刷新配置 source /etc/profile]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop伪分布式搭建-(1)]]></title>
    <url>%2F2018%2F03%2F18%2FHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-1%2F</url>
    <content type="text"><![CDATA[配置虚拟机子网网段(hostonly模式时) 配置网段 点击VMware快捷方式，右键打开文件所在位置 -&gt; 双击vmnetcfg.exe -&gt; VMnet1 host-only -&gt;修改subnet ip 设置网段：192.168.8.0 子网掩码：255.255.255.0 -&gt; apply -&gt; ok 设置本地机器IP 回到windows –&gt; 打开网络和共享中心 -&gt; 更改适配器设置 -&gt; 右键VMnet1 -&gt; 属性 -&gt; 双击IPv4 -&gt;设置windows的IP：192.168.8.100 子网掩码：255.255.255.0 -&gt; 点击确定 设置为hostonly模式 在虚拟软件上 –My Computer -&gt; 选中虚拟机 -&gt; 右键 -&gt; settings -&gt; network adapter -&gt; host only -&gt; ok 另:桥接模式 桥接模式直接将本地机器的当前正在使用的网卡(无线/非无线网卡)IP改为静态IP即可.设置windows的IP：192.168.8.100 子网掩 码：255.255.255.0 -&gt; 网关:192.168.1.1 -&gt; 若为无线网卡,设置前先查看路由分配的DNS是多少,直接照着填进来就行.-&gt;点击确定 修改主机名 vim /etc/sysconfig/network 12NETWORKING=yesHOSTNAME=dh01 #随便设置一个名字 修改虚拟机IP(这里是centos7)两种方式： 第一种：通过Linux图形界面进行修改（推荐） 进入Linux图形界面 -&gt; 右键点击右上方的两个小电脑 -&gt;点击Edit connections -&gt; 选中当前网络System eth0 -&gt;点击edit按钮 -&gt; 选择IPv4 -&gt; method选择为manual -&gt;点击add按钮 -&gt;添加IP：192.168.8.88子网掩码：255.255.255.0 网关：192.168.8.1 -&gt; apply 第二种：修改配置文件方式 vim /etc/sysconfig/network-scripts/ifcfg-eth0 (不一定一定是ifcfg-eth0) 1234567891011DEVICE=&quot;eth0&quot;BOOTPROTO=&quot;static&quot; #修改HWADDR=&quot;00:0C:29:3C:BF:E7&quot;IPV6INIT=&quot;yes&quot;NM_CONTROLLED=&quot;yes&quot;ONBOOT=&quot;yes&quot;TYPE=&quot;Ethernet&quot;UUID=&quot;ce22eeca-ecde-4536-8cc2-ef0dc36d4a8c&quot;IPADDR=&quot;192.168.8.88&quot; #修改NETMASK=&quot;255.255.255.0&quot; #修改GATEWAY=&quot;192.168.8.1&quot; #修改 修改主机名和IP的映射关系 vim /etc/hosts 1192.168.8.88 dh01 关闭防火墙(以下为centos7以前命令,centos7) #查看防火墙状态service iptables status #关闭防火墙service iptables stop #查看防火墙开机启动状态chkconfig iptables –list #关闭防火墙开机启动chkconfig iptables off CentOS 7.0默认使用的是firewall作为防火墙 systemctl start firewalld.service #启动firewallsystemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动 也可以改成使用iptables：systemctl start iptables.service 重启Linux reboot]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse下JSP中使用UEditor（以富文本编辑器为例）]]></title>
    <url>%2F2017%2F02%2F20%2FEclipse%E4%B8%8BJSP%E4%B8%AD%E4%BD%BF%E7%94%A8UEditor(%E4%BB%A5%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%BA%E4%BE%8B)%2F</url>
    <content type="text"><![CDATA[1.下载UEditorhttp://ueditor.baidu.com/website/download.html 版本如下： 2.解压，简单暴力地将\ueditor1_4_3-utf8-jsp\jsp\lib目录下的文件拷贝到项目的/WEB-INF/lib目录下如图所示： 3.将除index.html文件外的文件拷贝到项目中，例如： 4.在要使用富文本编辑器的页面引入脚本：12345&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&lt;%=path%&gt;/js/ueditor/ueditor.config.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&lt;%=path%&gt;/js/ueditor/ueditor.all.min.js&quot;&gt; &lt;/script&gt;&lt;!--建议手动加在语言，避免在ie下有时因为加载语言失败导致编辑器加载失败--&gt;&lt;!--这里加载的语言文件会覆盖你在配置项目里添加的语言类型，比如你在配置项目里配置的是英文，这里加载的中文，那最后就是中文--&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&lt;%=path%&gt;/js/ueditor/lang/zh-cn/zh-cn.js&quot;&gt;&lt;/script&gt; 如图： 5.在需要用富文本编辑器的区域添加以下脚本：1&lt;script id=&quot;editor&quot; type=&quot;text/plain&quot; style=&quot;width:486px;height:300px;&quot;&gt;&lt;/script&gt; 如图： 6.在页面最下端写以下javascript脚本：12345&lt;script type=&quot;text/javascript&quot;&gt; //实例化编辑器 //建议使用工厂方法getEditor创建和引用编辑器实例，如果在某个闭包下引用该编辑器，直接调用UE.getEditor(&apos;editor&apos;)就能拿到相关的实例 var ue = UE.getEditor(&apos;editor&apos;);&lt;/script&gt; 如图： 7.添加提交按钮的js脚本，用来提交内容脚本文件：代码：12345678function check_post_msg_valid()&#123; if(false==UE.getEditor(&apos;editor&apos;).hasContents())&#123; alert(&apos;请输入内容！&apos;); return false; &#125; document.getElementById(&quot;msg&quot;).value=UE.getEditor(&apos;editor&apos;).getContent(); document.forms[0].submit(); &#125; 8.其他：]]></content>
      <categories>
        <category>Java</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>UEditor</tag>
        <tag>富文本编辑器</tag>
      </tags>
  </entry>
</search>
