<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Axios基本使用说明]]></title>
    <url>%2F2018%2F04%2F11%2FAxios%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 特点 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 浏览器支持 Latest ✔ Latest ✔ Latest ✔ Latest ✔ Latest ✔ 8+ ✔ 安装使用 npm: 1$ npm install axios 使用 bower: 1$ bower install axios 使用 cdn: 1&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; 示例执行 GET 请求 12345678910111213141516171819202122232425262728293031// 为给定 ID 的 user 创建请求axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 可选地，上面的请求可以这样做axios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 想使用异步/等待？将`async`关键字添加到外部函数/方法中。async function getUser() &#123; try &#123; const response = await axios.get('/user?ID=12345'); console.log(response); &#125; catch (error) &#123; console.error(error); &#125;&#125; 注意: async/await是ECMAScript 2017的一部分，在Internet Explorer和旧版浏览器中不支持，因此请谨慎使用。 执行 POST 请求 12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行多个并发请求 123456789101112function getUserAccount() &#123; return axios.get('/user/12345');&#125;function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; //两个请求均已完成 &#125;)); axios API请求可以通过传递相关配置来完成 axios. axios(config) 123456789// 发送一个POST请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;); 123456789// GET请求远程图像axios(&#123; method:'get', url:'http://bit.ly/2mTM3nY', responseType:'stream'&#125;) .then(function(response) &#123; response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))&#125;); axios(url[, config]) 12// 发送GET请求（默认方法）axios('/user/12345'); 请求方法别名为方便起见，为所有支持的请求方法提供了别名 axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.options(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]]) 注意: 在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 并发处理并发请求的助手函数 axios.all(iterable)axios.spread(callback) 创建一个实例您可以使用自定义配置创建一个新的axios实例。 axios.create([config]) 12345const instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-Custom-Header': 'foobar'&#125;&#125;); 实例方法以下是可用的实例方法。指定的配置将与实例的配置合并 axios#request(config)axios#get(url[, config])axios#delete(url[, config])axios#head(url[, config])axios#options(url[, config])axios#post(url[, data[, config]])axios#put(url[, data[, config]])axios#patch(url[, data[, config]]) 请求配置这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&#123; // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // 默认 // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream // 您可以修改headers对象。 transformRequest: [function (data, headers) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个普通对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (例如： https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属： FormData, File, Blob // - Node专属: Stream, Buffer data: &#123; firstName: 'Fred' &#125;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 adapter: function (config) &#123; /* ... */ &#125;, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: 'janedoe', password: 's00pers3cret' &#125;, // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // 默认 // `responseEncoding` 表示用于解码响应的编码 // 注意：忽略'stream'或客户端请求的`responseType` responseEncoding: 'utf8', // 默认 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // 默认 // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // 默认 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。 // 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)， // promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认 &#125;, // `maxRedirects` 定义在 node.js 中遵循的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // default // `socketPath` 定义了一个在Socket.js中使用的UNIX套接字。 // 例如'/var/run/docker.sock'发送请求到docker守护进程。 // 只能指定`socketPath`或`proxy`。 // 如果两者都指定，则使用`socketPath`。 socketPath: null, // 默认 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 'proxy' 定义代理服务器的主机名称和端口 // 使用'false'来禁用代理，忽略环境变量。 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: '127.0.0.1', port: 9000, auth: &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 响应结构某个请求的响应包含以下信息 123456789101112131415161718192021&#123; // `data` 由服务器提供的响应 data: &#123;&#125;, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: 'OK', // `headers` t服务器响应的头 // 所有的 header 都是小写 headers: &#123;&#125;, // `config` 是为请求提供给`axios`的配置 config: &#123;&#125;, // `request` 是生成此响应的请求 // 它是node.js中的最后一个ClientRequest实例和浏览器请求的XMLHttpRequest实例 request: &#123;&#125;&#125; 使用 then 时，你将接收下面这样的响应： 12345678axios.get('/user/12345') .then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); &#125;); 在使用 catch 时，或传递rejection callback 作为 then 的第二个参数时, 响应可以通过 error 对象可被使用，正如在错误处理 这一节所讲. 配置的默认值/defaults你可以指定将被用在各个请求的配置默认值 全局axios默认值123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 自定义实例默认值1234567// 创建实例时设置配置的默认值const instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);// 在实例已创建后修改默认值instance.defaults.headers.common['Authorization'] = AUTH_TOKEN; 配置的优先顺序配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子： 123456789101112// 使用由库提供的配置的默认值来创建实例// 此时超时配置的默认值是 `0`const instance = axios.create();// 覆写库的超时默认值// 现在，在超时前，所有请求都会等待 2.5 秒instance.defaults.timeout = 2500;// 为已知需要花费很长时间的请求覆写超时设置instance.get('/longRequest', &#123; timeout: 5000&#125;); 拦截器在请求或响应被 then 或 catch 处理前拦截它们。 1234567891011121314151617// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); 如果你想在稍后移除拦截器，可以这样： 12const myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器 12const instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 错误处理1234567891011121314151617axios.get('/user/12345') .catch(function (error) &#123; if (error.response) &#123; // 请求已发出，但服务器响应的状态码不在 2xx 范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); &#125; else if (error.request) &#123; // 请求被提出，但没有接收到响应 // `error.request`是在浏览器中一个XMLHttpRequest的实例和node.js中http.ClientRequest的实例 console.log(error.request); &#125; else &#123; // 设置触发错误 console.log('Error', error.message); &#125; console.log(error.config); &#125;); 您可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。 12345axios.get('/user/12345', &#123; validateStatus: function (status) &#123; return status &lt; 500; // 仅当状态码大于或等于500时才拒绝 &#125;&#125;) 取消使用 cancel token 取消请求 Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。 可以使用 CancelToken.source 工厂创建取消令牌，如下所示： 123456789101112131415161718192021const CancelToken = axios.CancelToken;const source = CancelToken.source();axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;);axios.post('/user/12345', &#123; name: 'new name'&#125;, &#123; cancelToken: source.token&#125;)// 取消请求（消息参数是可选的）source.cancel('Operation canceled by the user.'); 还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token： 123456789101112const CancelToken = axios.CancelToken;let cancel;axios.get('/user/12345', &#123; cancelToken: new CancelToken(function executor(c) &#123; // executor 函数接收一个 cancel 函数作为参数 cancel = c; &#125;)&#125;);// 取消请求cancel(); 注意: 可以使用同一个 cancel token 取消多个请求 使用 application/x-www-form-urlencoded 格式默认情况下，axios将JavaScript对象序列化为JSON。要以application/x-www-form-urlencoded 格式发送数据，您可以使用以下选项之一。 浏览器在浏览器中，您可以使用以下URLSearchParams API: 1234const params = new URLSearchParams();params.append('param1', 'value1');params.append('param2', 'value2');axios.post('/foo', params); 请注意， URLSearchParams 并非所有浏览器都支持(请参阅 caniuse.com), 但可以使用 polyfill(请确保填充全局环境)。或者，您可以使用qs 库对数据进行编码： 12const qs = require('qs');axios.post('/foo', qs.stringify(&#123; 'bar': 123 &#125;)); 或者以另一种方式（ES6）， 123456789import qs from 'qs';const data = &#123; 'bar': 123 &#125;;const options = &#123; method: 'POST', headers: &#123; 'content-type': 'application/x-www-form-urlencoded' &#125;, data: qs.stringify(data), url,&#125;;axios(options); Node.js在node.js中，您可以querystring按如下方式使用模块： 12const querystring = require('querystring');axios.post('http://something.com/', querystring.stringify(&#123; foo: 'bar' &#125;)); 您也可以使用该qs库. Semver在axios达到1.0 发布之前，将通过新的次要版本发布重大更改。例如 0.5.1, 和 0.5.4将具有相同的API, 但 0.6.0 会有重大更改。 承诺aaxios依赖于原生ES6 Promise实现的支持。如果您的环境不支持ES6 Promise，则可以polyfill。 TypeScriptaxios包括TypeScript定义。12import axios from 'axios';axios.get('/user?ID=12345'); 资源 更新日志 升级指南 生态系统 C参与指南 行为守则]]></content>
      <categories>
        <category>翻译</category>
        <category>README</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTerm 2和Oh My Zsh代替自带terminal教程简单整理]]></title>
    <url>%2F2018%2F04%2F02%2FiTerm-2%E5%92%8COh-My-Zsh%E4%BB%A3%E6%9B%BF%E8%87%AA%E5%B8%A6terminal%E6%95%99%E7%A8%8B%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[最终效果图大概是这个样子： 但是如果你有用到Atom编辑器的控制台插件的话可能会由于字体原因特殊的符号显示不了，就像我这样： 1. 首先下载iterm22. 打开iTerm 23. 输入下面指令安装oh-my-zsh curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh 4. 接下来安装Powerline在官网有教程，我们只需要执行官网第一条安装指令就行 如果你的终端能够正常执行pip指令，那么直接执行下面的指令可以完成安装 pip install powerline-status 如果没有，则先执行安装pip指令 sudo easy_install pip 5. 下载、安装库字体库1）将工程下载下来后cd到install.sh文件所在目录 2）执行指令安装字体库 执行./install.sh指令安装所有Powerline字体 安装完成后提示所有字体均已下载到/Users/superdanny/Library/Fonts路径下 All Powerline fonts installed to /Users/superdanny/Library/Fonts 6. 设置iTerm 2的Regular Font 和 Non-ASCII Font安装完字体库之后，把iTerm 2的设置里的Profile中的Text 选项卡中里的Regular Font和Non-ASCII Font的字体都设置成 Powerline的字体，我这里设置的字体是12pt Meslo LG S DZ Regular for Powerline 设置iTerm 2设置iTerm 2 7. 配色方案1）安装配色方案 进入刚刚下载的工程的solarized/iterm2-colors-solarized下双击Solarized Dark.itermcolors和Solarized Light.itermcolors两个文件就可以把配置文件导入到 iTerm2 里 2）配置配色方案 通过load presets选择刚刚安装的配色主题即可 配色方案配色方案 8. 使用agnoster主题1）下载agnoster主题 到下载的工程里面运行install文件,主题将安装到~/.oh-my-zsh/themes目录下 2）设置该主题进入~/.zshrc打开.zshrc文件，然后将ZSH_THEME后面的字段改为agnoster。ZSH_THEME=”agnoster”（agnoster即为要设置的主题） 9. 增加指令高亮效果——zsh-syntax-highlighting指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮 1）首先在~/.oh-my-zsh/custom/plugins/路径下执行git clone https://github.com/zsh-users/zsh-syntax-highlighting.git到了此路径:~/.oh-my-zsh/custom/plugins/ 2）然后在~/.zshrc最后添加了下面两句：“plugins=(zsh-syntax-highlighting)source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh” 3）最后执行 source ~/.zshrc 这样就同时配置好了zsh和oh-my-zsh。有两点需要注意(摘自官网):Note the source command must be at the end of ~/.zshrc.Note that zsh-syntax-highlighting must be the last plugin sourced, so make it the last element of the $plugins array. 问题解答区 启动iTerm 2 默认使用dash改用zsh解决方法：chsh -s /bin/zsh 如果想切换回原来的dash：chsh -s /bin/bash 卸载oh my zsh，在命令行输入如下命令，回车即可：uninstall_oh_my_zsh 执行指令pip install powerline-status出错解决方法：需要下载苹果官方的Command line。必須官方工具下载最新版 Command Line ⌘+Q关闭iTerm 2 时每次弹窗提示问题：iTerm 2 中，进入Preference-General-Closing栏目，将Confirm “Quit iTerm2(⌘Q)” command选项勾选去掉就行 找不到.zshrc文件问题：我这里将原作者的.zshrc文件分享出来。供大家下载网盘 路径前缀的XX@XX太长，缩短问题：在此感谢评论区的朋友提供的解决方案。在~/.oh-my-zsh/themes路径下找到agnoster.zsh-theme文件，可使用文本工具打开，将里面的build_prompt下的prompt_context字段在前面加#注释掉即可。 原文]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>iTerm 2</tag>
        <tag>Oh My Zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下安装mysql5.7完整步骤及问题整理]]></title>
    <url>%2F2018%2F03%2F19%2FMac%E4%B8%8B%E5%AE%89%E8%A3%85mysql5-7%E5%AE%8C%E6%95%B4%E6%AD%A5%E9%AA%A4%E5%8F%8A%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[安装参考以下这个博客: Mac下安装mysql5.7完整步骤 问题 “MAC下安装Mysql找不到my.cnf配置文件的问题”，参考：MAC 安装MySQL的my.cnf配置文件 “Warning: World-writable config file ‘/etc/my.cnf’ is ignored”，参考：World-writable]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac安装Mysql</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10下.Net Framework 3.5无法安装【错误代码0x800F081F】]]></title>
    <url>%2F2018%2F03%2F18%2FWin10%E4%B8%8B-Net-Framework-3-5%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E3%80%90%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%810x800F081F%E3%80%91%2F</url>
    <content type="text"><![CDATA[首先下载 .Net Framework 3.5. 将下载的文件复制到复制到 【C盘】 的 【Windows】 文件夹，然后后在“命令提示符（管理员）”中执行下面的命令： dism /online /Enable-Feature /FeatureName:NetFx3 /Source:”%windir%” /LimitAccess 其他: Windows 10下安装有的软件需要 .Net Framework 3.5的环境。默认是没有开启的，一般情况下可以【右键开始】菜单，选择【程序和功能】然后再选择【启用或关闭Windows功能】里的第一项【.Net Framework 3.5(包括.NET 2.0和3.0) 再一个就是去官网下一个手动安装一下也行，这两种方法都不行再用上面那个方法，这样大部分人的问题应该都可以解决了。]]></content>
      <categories>
        <category>OS</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Framework3.5无法安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机VirtualBox中挂载新硬盘]]></title>
    <url>%2F2018%2F03%2F18%2F%E8%99%9A%E6%8B%9F%E6%9C%BAVirtualBox%E4%B8%AD%E6%8C%82%E8%BD%BD%E6%96%B0%E7%A1%AC%E7%9B%98%2F</url>
    <content type="text"><![CDATA[在VirtualBox中装好Linux后，发现硬盘空间太小，怎样才能增加硬盘容量？那就是再建一个硬盘： 添加新硬盘 设置 -&gt; Storage(存储) -&gt; SATA控制器-&gt;右击，选择”添加虚拟硬盘”然后，根据需求创建合适的硬盘 重启虚拟机 查看现有系统的磁盘空间 sudo fdisk -l 可看到新加的虚拟硬盘，一般名为：Disk /dev/sdb 给新加的硬盘分区 fdisk /dev/sdb 键入m,可看到帮助信息 command (m for help):m 增加新分区 command (m for help):n 选择基本分区，输入：p 建一个分区 Partition number(1-4): 回车 First cylinder (1-15908,default 1):Enter 写入并退出 command (m for help):w 格式化磁盘分区 用ext4格式对/dev/sdb1进入格式化 sudo mkfs.ext4 /dev/sdb1 挂载分区 创建新的挂载点 sudo mkdir /work 将新磁盘分区挂载到/work目录下 sudo mount -t ext4 /dev/sdb1 /work 查看挂载 df -h 可以看到新加的硬盘：/dev/sdb1 开机自动挂载 修改文件 sudo vim /etc/fstab 在最后一行加入： /dev/sdb1 /work ext4 errors=remount-ro 0 1 完成! 补充：为挂载点扩容假设之前我们有一个挂载点为 /mydata ，但该 /mydata 已经写满，但依然想在 /mydata 下添加新的数据，这时可以使用软链接将 /mydata 软链接到一个新挂载的磁盘分区上以实现扩容。具体步骤如下。 1. 创建一个目录，以便稍后作为挂载点： mkdir /newdata 2. 将 /dev/sdb1 分区挂载到 /newdata 下： mount /dev/sdb1 /newdata 3. 新建 /mydata 到 /newdata 的软链接： ln -s /newdata /mydata 此时在 /mydata 目录下会有一个软链接文件 newdata 指向 /newdata/ ，即 newdata-&gt; /newdata/ 。这样一来，只要我们向 /mydata/newdata 下写文件，实际就写入了 /newdata/ 目录下，相当于我们为原 /mydata 挂载点新增加了一部分使用空间。 也可以手动指定该软链接文件的名称： ln -s /newdata /mydata/customed_name 这样就有 /mydata/customed_name -&gt; /newdata 注： 我们也可以利用软链接的这一用途，将比较大的日志文件链接到存储空间充足的磁盘分区的挂载点上。 举例来说，如果 /opt/tomcat/logs/catalina.out 日志文件输入很多，占用空间很大，而 /opt 挂载点中所剩空间已经不多，存在溢出风险，通过下面两步就可以将该日志文件软链接到另一个磁盘分区的挂载点上： touch /newdata/catalina_link.outln -sf /newdata/catalina_link.out /opt/tomcat/logs/catalina.out 这里还需要注意三点： 一是必须先创建一个被链接的文件，否则软链接后失败； 二是强制软链接会清空之前 /opt/tomcat/logs/catalina.out 日志文件中的全部内容清空； 三是需要重启 tomcat 目录后才能继续向 /opt/tomcat/logs/catalina.out 写入。]]></content>
      <categories>
        <category>OS</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>Linux挂载硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常见异常总结]]></title>
    <url>%2F2018%2F03%2F18%2FJava%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[java.lang.NullPointerException(空指针异常) 调用了未经初始化的对象或者是不存在的对象 经常出现在创建图片，调用数组这些操作中，比如图片未经初始化，或者图片创建时的路径错误等等。对数组操作中出现空指针，即把数组的初始化和数组元素的初始化混淆起来了。数组的初始化是对数组分配需要的空间，而初始化后的数组，其中的元素并没有实例化，依然是空的，所以还需要对每个元素都进行初始化（如果要调用的话）。 java.lang.ClassNotFoundException 指定的类不存在 这里主要考虑一下类的名称和路径是否正确即可，通常都是程序试图通过字符串来加载某个类时可能引发 异常 比如：调用Class.forName(); 或者调用ClassLoad的finaSystemClass();或者LoadClass(); java.lang.NumberFormatException 字符串转换为数字异常 当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常.如现在讲字符型的数据“123456”转换为数值型数据时，是允许的。但是如果字符型数据中包含了非数字型的字符，如123#56，此时转换为数值型时就会出现异常。系统就会捕捉到这个异常，并进行处理. java.lang.IndexOutOfBoundsException 数组下标越界异常 查看调用的数组或者字符串的下标值是不是超出了数组的范围，一般来说，显示（即直接用常数当下标）调用不太容易出这样的错，但隐式（即用变量表示下标）调用就经常出错了，还有一种情况，是程序中定义的数组的长度是通过某些特定方法决定的，不是事先声明的，这个时候，最好先查看一下数组的length，以免出现这个异常。 java.lang.IllegalArgumentException 方法的参数错误 比如g.setColor(int red,int green,int blue)这个方法中的三个值，如果有超过２５５的也会出现这个异常，因此一旦发现这个异常，我们要做的，就是赶紧去检查一下方法调用中的参数传递是不是出现了错误。 java.lang.IllegalAccessException 没有访问权限 当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。对程序中用了Package的情况下要注意这个异常 java.lang.ArithmeticException 数学运算异常 当算术运算中出现了除以零这样的运算就会出这样的异常。 java.lang.ClassCastException 数据类型转换异常 当试图将对某个对象强制执行向下转型，但该对象又不可转换又不可转换为其子类的实例时将引发该异常，如下列代码。 123Object obj = new Integer(0);String str = obj;java.lang.FileNotFoundException java.lang.FileNotFoundException 文件未找到异常 当程序试图打开一个不存在的文件进行读写时将会引发该异常。该异常由FileInputStream,FileOutputStream,RandomAccessFile的构造器声明抛出即使被操作的文件存在，但是由于某些原因不可访问，比如打开一个只读文件进行写入，这些构造方法仍然会引发异常 java.lang.ArrayStoreException 数组存储异常 当试图将类型不兼容类型的对象存入一个Object[]数组时将引发异常 123Object[] obj = new String[3];obj[0] = new Integer(0);java.lang.NoSuchMethodException java.lang.NoSuchMethodException 方法不存在异常 当程序试图通过反射来创建对象，访问(修改或读取)某个方法，但是该方法不存在就会引发异常 java.lang.NoSuchFiledException 方法不存在异常 当程序试图通过反射来创建对象，访问(修改或读取)某个filed，但是该filed不存在就会引发异常 java.lang.EOFException 文件已结束异常 当程序在输入的过程中遇到文件或流的结尾时，引发异常。因此该异常用于检查是否达到文件或流的结尾 java.lang.InstantiationException 实例化异常 当试图通过Class的newInstance()方法创建某个类的实例,但程序无法通过该构造器来创建该对象时引发Class对象表示一个抽象类，接口，数组类，基本类型该Class表示的类没有对应的构造器 java.lang.InterruptedException 被中止异常 当某个线程处于长时间的等待、休眠或其他暂停状态，而此时其他的线程通过Thread的interrupt方法终止该线程时抛出该异常。 java.lang.CloneNotSupportedException 不支持克隆异常 当没有实现Cloneable接口或者不支持克隆方法时,调用其clone()方法则抛出该异常。 java.lang.OutOfMemoryException 内存不足错误 当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。 java.lang.NoClassDefFoundException 未找到类定义错误 当Java虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误。 违背安全原则异常：SecturityException 操作数据库异常：SQLException 输入输出异常：IOException 通信异常：SocketException]]></content>
      <categories>
        <category>Java</category>
        <category>异常</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop伪分布式搭建-(4)]]></title>
    <url>%2F2018%2F03%2F18%2FHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-4%2F</url>
    <content type="text"><![CDATA[生成ssh免登陆密钥 进入到/dh/下的home目录(隐藏) cd ~/.sshssh-keygen -t rsa （一直回车） 执行完这个命令后，会生成两个文件id_rsa（私钥）、id_rsa.pub（公钥） 将公钥拷贝到要免登陆的机器上 ssh-copy-id -i localhost (ssh-copy-id -i 要免登陆的机器的IP)或者cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop伪分布式搭建-(3)]]></title>
    <url>%2F2018%2F03%2F18%2FHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-3%2F</url>
    <content type="text"><![CDATA[安装hadoop2.4.1（或其他更高版本&lt;最好用更高的64位版本，免得重新编译&gt;）注意：hadoop2.x的配置文件$HADOOP_HOME/etc/hadoop伪分布式需要修改5个配置文件 上传hadoop并解压到指定目录同jdk一样,上传Hadoop的包到本目录,并在root目录下创建/dh/这个目录,将Hadoop解压到该目录 配置hadoop hadoop-env.sh文件 vim hadoop-env.sh 1export JAVA_HOME=/usr/java/jdk1.7.0_79 core-site.xml文件 vim core-site.xml 12345678910&lt;!--设定NameNode地址 --&gt;&lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://dh01:9000&lt;/value&gt; &lt;!--或者把dh01换成对应IP--&gt;&lt;/property&gt;&lt;!-- 指定hadoop运行时产生文件的存储目录 --&gt;&lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/dh/hadoop-2.4.1/tmp&lt;/value&gt;&lt;/property&gt; hdfs-site.xml文件 vim hdfs-site.xml 12345&lt;!-- 指定HDFS副本的数量 --&gt;&lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt;&lt;!--因为为伪分布式,所以只有一个副本--&gt;&lt;/property&gt; mapred-site.xml文件 #重命名mv mapred-site.xml.template mapred-site.xml#打开重命名后的文件vim mapred-site.xml 12345&lt;!-- 指定mapreduce运行在YARN上 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt; yarn-site.xml文件 12345678910&lt;!-- 指定YARN的老大（ResourceManager）的地址 --&gt;&lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;dh01&lt;/value&gt;&lt;/property&gt;&lt;!-- mapreduce获取数据的方式 --&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt; 将hadoop添加到环境变量 vim /etc/proflie 123export JAVA_HOME=/usr/java/jdk1.7.0_79export HADOOP_HOME=/dh/hadoop-2.4.1export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$HADOOP_HOME/lib 刷新配置文件 source /etc/profile 格式化namenode（是对namenode进行初始化） hdfs namenode -format (hadoop namenode -format) 启动hadoop先启动HDFS sbin/start-dfs.sh 再启动YARN sbin/start-yarn.sh 验证是否启动成功使用jps命令验证 jsp 12345627408 NameNode28218 Jps27643 SecondaryNameNode28066 NodeManager27803 ResourceManager27512 DataNode http://192.168.8.88:50070 （HDFS管理界面） 在这个文件中添加linux主机名和IP的映射关系C:\Windows\System32\drivers\etc\hosts下添加:1192.168.1.66 dh01 打开：http://192.168.8.88:8088验证 （mapreduce管理界面）]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop伪分布式搭建-(2)]]></title>
    <url>%2F2018%2F03%2F18%2FHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-2%2F</url>
    <content type="text"><![CDATA[安装JDK 从Windows上传jdk到虚拟机 你可以用FlashFXP/FileZilla/SecureCRT将jdk-7u79-linux-x64.gz传到Linux上。假设现在你已经传到了虚拟机的root目录下 解压jdk mkdir /usr/javatar -zxvf jdk-7u79-linux-x64.gz -C /usr/java/ 将java添加到环境变量中 vim /etc/profile 12export JAVA_HOME=/usr/java/jdk1.7.0_79 export PATH=$PATH:$JAVA_HOME/bin 刷新配置 source /etc/profile]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop伪分布式搭建-(1)]]></title>
    <url>%2F2018%2F03%2F18%2FHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-1%2F</url>
    <content type="text"><![CDATA[配置虚拟机子网网段(hostonly模式时) 配置网段 点击VMware快捷方式，右键打开文件所在位置 -&gt; 双击vmnetcfg.exe -&gt; VMnet1 host-only -&gt;修改subnet ip 设置网段：192.168.8.0 子网掩码：255.255.255.0 -&gt; apply -&gt; ok 设置本地机器IP 回到windows –&gt; 打开网络和共享中心 -&gt; 更改适配器设置 -&gt; 右键VMnet1 -&gt; 属性 -&gt; 双击IPv4 -&gt;设置windows的IP：192.168.8.100 子网掩码：255.255.255.0 -&gt; 点击确定 设置为hostonly模式 在虚拟软件上 –My Computer -&gt; 选中虚拟机 -&gt; 右键 -&gt; settings -&gt; network adapter -&gt; host only -&gt; ok 另:桥接模式 桥接模式直接将本地机器的当前正在使用的网卡(无线/非无线网卡)IP改为静态IP即可.设置windows的IP：192.168.8.100 子网掩 码：255.255.255.0 -&gt; 网关:192.168.1.1 -&gt; 若为无线网卡,设置前先查看路由分配的DNS是多少,直接照着填进来就行.-&gt;点击确定 修改主机名 vim /etc/sysconfig/network 12NETWORKING=yesHOSTNAME=dh01 #随便设置一个名字 修改虚拟机IP(这里是centos7)两种方式： 第一种：通过Linux图形界面进行修改（推荐） 进入Linux图形界面 -&gt; 右键点击右上方的两个小电脑 -&gt;点击Edit connections -&gt; 选中当前网络System eth0 -&gt;点击edit按钮 -&gt; 选择IPv4 -&gt; method选择为manual -&gt;点击add按钮 -&gt;添加IP：192.168.8.88子网掩码：255.255.255.0 网关：192.168.8.1 -&gt; apply 第二种：修改配置文件方式 vim /etc/sysconfig/network-scripts/ifcfg-eth0 (不一定一定是ifcfg-eth0) 1234567891011DEVICE=&quot;eth0&quot;BOOTPROTO=&quot;static&quot; #修改HWADDR=&quot;00:0C:29:3C:BF:E7&quot;IPV6INIT=&quot;yes&quot;NM_CONTROLLED=&quot;yes&quot;ONBOOT=&quot;yes&quot;TYPE=&quot;Ethernet&quot;UUID=&quot;ce22eeca-ecde-4536-8cc2-ef0dc36d4a8c&quot;IPADDR=&quot;192.168.8.88&quot; #修改NETMASK=&quot;255.255.255.0&quot; #修改GATEWAY=&quot;192.168.8.1&quot; #修改 修改主机名和IP的映射关系 vim /etc/hosts 1192.168.8.88 dh01 关闭防火墙(以下为centos7以前命令,centos7) #查看防火墙状态service iptables status #关闭防火墙service iptables stop #查看防火墙开机启动状态chkconfig iptables –list #关闭防火墙开机启动chkconfig iptables off CentOS 7.0默认使用的是firewall作为防火墙 systemctl start firewalld.service #启动firewallsystemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动 也可以改成使用iptables：systemctl start iptables.service 重启Linux reboot]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse下JSP中使用UEditor（以富文本编辑器为例）]]></title>
    <url>%2F2017%2F02%2F20%2FEclipse%E4%B8%8BJSP%E4%B8%AD%E4%BD%BF%E7%94%A8UEditor(%E4%BB%A5%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%BA%E4%BE%8B)%2F</url>
    <content type="text"><![CDATA[1.下载UEditorhttp://ueditor.baidu.com/website/download.html 版本如下： 2.解压，简单暴力地将\ueditor1_4_3-utf8-jsp\jsp\lib目录下的文件拷贝到项目的/WEB-INF/lib目录下如图所示： 3.将除index.html文件外的文件拷贝到项目中，例如： 4.在要使用富文本编辑器的页面引入脚本：12345&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&lt;%=path%&gt;/js/ueditor/ueditor.config.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&lt;%=path%&gt;/js/ueditor/ueditor.all.min.js&quot;&gt; &lt;/script&gt;&lt;!--建议手动加在语言，避免在ie下有时因为加载语言失败导致编辑器加载失败--&gt;&lt;!--这里加载的语言文件会覆盖你在配置项目里添加的语言类型，比如你在配置项目里配置的是英文，这里加载的中文，那最后就是中文--&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&lt;%=path%&gt;/js/ueditor/lang/zh-cn/zh-cn.js&quot;&gt;&lt;/script&gt; 如图： 5.在需要用富文本编辑器的区域添加以下脚本：1&lt;script id=&quot;editor&quot; type=&quot;text/plain&quot; style=&quot;width:486px;height:300px;&quot;&gt;&lt;/script&gt; 如图： 6.在页面最下端写以下javascript脚本：12345&lt;script type=&quot;text/javascript&quot;&gt; //实例化编辑器 //建议使用工厂方法getEditor创建和引用编辑器实例，如果在某个闭包下引用该编辑器，直接调用UE.getEditor(&apos;editor&apos;)就能拿到相关的实例 var ue = UE.getEditor(&apos;editor&apos;);&lt;/script&gt; 如图： 7.添加提交按钮的js脚本，用来提交内容脚本文件：代码：12345678function check_post_msg_valid()&#123; if(false==UE.getEditor(&apos;editor&apos;).hasContents())&#123; alert(&apos;请输入内容！&apos;); return false; &#125; document.getElementById(&quot;msg&quot;).value=UE.getEditor(&apos;editor&apos;).getContent(); document.forms[0].submit(); &#125; 8.其他：]]></content>
      <categories>
        <category>Java</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>UEditor</tag>
        <tag>富文本编辑器</tag>
      </tags>
  </entry>
</search>
