<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何超过大多数人]]></title>
    <url>%2F2019%2F07%2F22%2F%E5%A6%82%E4%BD%95%E8%B6%85%E8%BF%87%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[当你看到这篇文章的标题，你一定对这篇文章产生了巨大的兴趣，因为你的潜意识在告诉你，这是一本人生的 “武林秘籍”，而且还是左耳朵写的，一定有干货满满，只要读完，一定可以练就神功并找到超过大多数人的快车道和捷径…… 然而…… 当你看到我这样开篇时，你一定会觉得我马上就要有个转折，告诉你这是不可能的，一切都需要付出和努力…… 然而，你错了，这篇文章还真就是一篇“秘籍”，只要你把这些“秘籍” 用起来，你就一定可以超过大多数人。而且，这篇文章只有我这个 “人生导师” 可以写得好。毕竟，我的生命过到了十六进制 2B 的年纪，踏入这个社会已超过 20 年，舍我其谁呢？！ P.S. 这篇文章借鉴于《如何写出无法维护的代码》一文的风格…… 嘿嘿 相关技巧和最佳实践 要超过别人其实还是比较简单的，尤其在今天的中国，更是简单。因为，你只看看中国的互联网，你就会发现，他们基本上全部都是在消费大众，让大众变得更为地愚蠢和傻瓜。所以，在今天的中国，你基本上不用做什么，只需要不使用中国互联网，你就很自然地超过大多数人了。当然，如果你还想跟他们彻底拉开，甩他们几个身位，把别人打到底层，下面的这些 “技巧” 你要多多了解一下。 在信息获取上，你要不断地向大众鼓吹下面的这些事： 让大家都用百度搜索引擎查找信息，订阅微信公众号或是到知乎上学习知识…… 要做到这一步，你就需要把 “百度一下” 挂在嘴边，然后要经常在群或朋友圈中转发微信公众号的文章，并且转发知乎里的各种 “如何看待……” 这样的文章，让他们爱上八卦，爱上转发，爱上碎片。 让大家到微博或是知识星球上粉一些大咖，密切关注他们的言论和动向…… 是的，告诉大家，大咖的任何想法一言一行都可以在微博、朋友圈或是知识星球上获得，让大家相信，你的成长和大咖的见闻和闲扯非常有关系，你跟牛人在一个圈子里你也会变牛。 把今日头条和抖音这样的 APP 推荐给大家…… 你只需要让你有朋友成功地安装这两个 APP，他们就会花大量的时间在上面，而不能自拔，要让他们安装其实还是很容易的，你要不信你就装一个试玩一会看看（嘿嘿嘿）。 让大家热爱八卦，八卦并不一定是明星的八卦，还可以是你身边的人，比如，公司的同事，自己的同学，职场见闻，社会热点，争议话题，…… 这些东西总有一些东西会让人心态有很多微妙的变化，甚至花大量的时间去搜索和阅读大量的观点，以及花大量时间与人辩论争论，这个过程会让人上瘾，让人欲罢不能，然而这些事却和自己没有半毛钱关系。你要做的事就是转发其中一些 SB 或是很极端的观点，造成大家的一睦讨论后，就早早离场…… 利用爱国主义，让大家觉得不用学英文，不要出国，不要翻墙，咱们已经是强国了…… 这点其实还是很容易做到的，因为学习是比较逆人性的，所以，只要你鼓吹那些英文无用论，出国活得更惨，国家和民族都变得很强大，就算自己过得很底层，也有大国人民的感觉。 然后，在知识学习和技能训练上，让他们不得要领并产生幻觉 让他们混淆认识和知识，以为开阔认知就是学习，让他们有学习和成长的幻觉…… 培养他们要学会使用碎片时间学习。等他们习惯利用碎片时间吃快餐后，他们就会失去精读一本书的耐性…… 不断地给他们各种各样 “有价值的学习资料”，让他们抓不住重点，成为一个微信公众号或电子书 “收藏家”…… 让他们看一些枯燥无味的基础知识和硬核知识，这样让他们只会用 “死记硬背” 的方式来学习，甚至直接让他们失去信心，直接放弃…… 玩具手枪是易用的，重武器是难以操控的，多给他们一些玩具，这样他们就会对玩具玩地得心应手，觉得玩玩具就是自己的专业…… 让他们喜欢直接得到答案的工作和学习方式，成为一个伸手党，从此学习再也不思考…… 告诉他们东西做出来就好了，不要追求做漂亮，做优雅，这样他们就会慢慢地变成劳动密集型…… 让他们觉得自己已经很努力了，剩下的就是运气，并说服他们去‘及时行乐’，然后再也找不到高阶和高效率学习的感觉…… 让他们觉得 “读完书”、“读过书” 就行了，不需要对书中的东西进行思考，进行总结，或是实践，只要囫囵吞枣尽快读完就等同于学好了…… 最后，在认知和格局上，彻底打垮他们，让他们变成韭菜。 让他们不要看到大的形势，只看到眼前的一亩三分地，做好一个井底之蛙。其实这很简单，比如，你不要让他们看到整个计算机互联网技术改变人类社会的趋势，你要多让他看到，从事这一行业的人有多苦逼，然后再说一下其它行业或职业有多好…… 宣扬一夜暴富以及快速挣钱的案例，最好让他们进入 “赌博类” 或是 “传销类” 的地方，比如：股市、数字货币…… 要让他们相信各种财富神话，相信他们就是那个幸运儿，他们也可以成为巴菲特，可以成为马云…… 告诉他们，一些看上去很难的事都是有捷径的，比如：21 天就能学会机器学习，用区块链就能颠覆以及重构整个世界等等…… 多跟他们讲一些小人物的励志的故事，这样让他们相信，不需要学习高级知识，不需要掌握高级技能，只需要用低等的知识和低级的技能，再加上持续不断拼命重复现有的工作，终有一天就会成功…… 多让他们跟别人比较，人比人不会气死人，但是会让人变得浮躁，变得心急，变得焦虑，当一个人没有办法控制自己的情绪，没有办法让自己静下心来，人会失去耐性和坚持，开始好大喜欢功，开始装逼，开始歪门邪道剑走偏锋…… 让他们到体制内的一些非常稳定的地方工作，这样他们拥有不思进取、怕承担责任、害怕犯错、喜欢偷懒、得过且过的素质…… 让他们到体制外的那些喜欢拼命喜欢加班的地方工作，告诉他们爱拼才会赢，努力加班是一种福报，青春就是用来拼的，让他们喜欢上使蛮力的感觉…… 告诉他们你的行业太累太辛苦，干不到 30 岁。让他们早点转行，不要耽误人生和青春…… 当他们要做决定的时候，一定要让他们更多的关注自己会失去的东西，而不是会得到的东西。培养他们患得患失心态，让他们认识不到事物真正的价值，失去判断能力……（比如：让他们觉得跟对人拍领导的马屁忠于公司比自我的成长更有价值） 告诉他们，你现有的技能和知识不用更新，就能过好一辈子，新出来的东西没有生命力的…… 这样他们就会像我们再也不学习的父辈一样很快就会被时代所抛弃…… 每个人都喜欢在一些自己做不到的事上找理由，这种能力不教就会，比如，事情太多没有时间，因为工作上没有用到，等等，你要做的就是帮他们为他们做不到的事找各种非常合理的理由，比如：没事的，一切都是最好的安排；你得不到的那个事没什么意思；你没有面好主要原因是那个面试官问的问题都是可以上网查得到的知识，而不没有问到你真正的能力上；这些东西学了不用很快会忘了，等有了环境再学也不迟…… 最后友情提示一下，上述的这些 “最佳实践” 你要小心，是所谓，贩毒的人从来不吸毒，开赌场的人从来不赌博！所以，你要小心别自己也掉进去了！这就是 “欲练神功，必先自宫” 的道理。 相关原理和思维模型 对于上面的这些技巧还有很多很多，你自己也可以发明或是找到很多。所以，我来讲讲这其中的一些原理。 一般来说，超过别人一般来说就是两个维度： 在认知、知识和技能上。 这是一个人赖以立足社会的能力（参看《程序员的荒谬之言还是至理名言？》和《21 天教你学会 C++》） 在领导力上。 所谓领导力就是你跑在别人前面，你得要有比别人更好的能力更高的标准（参看《技术人员发展之路》） 首先，我们要明白，人的技能是从认识开始，然后通过学校、培训或是书本把 “零碎的认知” 转换成“系统的知识”，而有要把知识转换成技能，就需要训练和实践，这样才能完成从：认识 -&gt; 知识 -&gt; 技能 的转换。这个转换过程是需要耗费很多时间和精力的，而且其中还需要有强大的学习能力和动手能力，这条路径上有很多的“关卡”，每道关卡都会过滤掉一大部分人。比如：对于一些比较枯燥的硬核知识来说，90% 的人基本上就倒下来，不是因为他们没有智商，而是他们没有耐心。 认知 要在认知上超过别人，就要在下面几个方面上做足功夫： 1）信息渠道。 试想如果别人的信息源没有你的好，那么，这些看不见信息源的人，只能接触得到二手信息甚至三手信息，只能获得被别人解读过的信息，这些信息被三传两递后必定会有错误和失真，甚至会被传递信息的中间人 hack 其中的信息（也就是 “中间人攻击”），而这些找不出信息源的人，只能 “被人喂养”，于是，他们最终会被困在信息的底层，永世不得翻身。（比如：学习 C 语言，放着原作者 K&amp;R 的不用，硬要用错误百出谭浩强的书，能有什么好呢？） 2）信息质量。 信息质量主要表现在两个方面，一个是信息中的燥音，另一个是信息中的质量等级，我们都知道，在大数据处理中有一句名言，叫 garbage in garbage out，你天天看的都是垃圾，你的思想和认识也只有垃圾。所以，如果你的信息质量并不好的话，你的认知也不会好，而且你还要花大量的时间来进行有价值信息的挖掘和处理。 3）信息密度。 优质的信息，密度一般都很大，因为这种信息会逼着你去干这么几件事，a）搜索并学习其关联的知识，b）沉思和反省，c）亲手去推理、验证和实践…… 一般来说，经验性的文章会比知识性的文章会更有这样的功效。比如，类似于像 Effiective C++/Java，设计模式，Unix 编程艺术，算法导论等等这样的书就是属于这种密度很大的书，而像 Netflix 的官方 blog 和 AWS CTO 的 blog 等等地方也会经常有一些这样的文章。 知识 要在知识上超过别人，你就需要在下面几个方面上做足功夫： 1）知识树（图）。 任何知识，只在点上学习不够的，需要在面上学习，这叫系统地学习，这需要我们去总结并归纳知识树或知识图，一个知识面会有多个知识板块组成，一个板块又有各种知识点，一个知识点会导出另外的知识点，各种知识点又会交叉和依赖起来，学习就是要系统地学习整个知识树（图）。而我们都知道，对于一棵树来说，“根基” 是非常重要的，所以，学好基础知识也是非常重要的，对于一个陌生的地方，有一份地图是非常重要的，没有地图的你只会乱窜，只会迷路、练路、走冤枉路！ 2）知识缘由。 任何知识都是有缘由的，了解一个知识的来龙去脉和前世今生，会让你对这个知识有非常强的掌握，而不再只是靠记忆去学习。靠记忆去学习是一件非常糟糕的事。而对于一些操作性的知识（不需要了解由来的），我把其叫操作知识，就像一些函数库一样，这样的知识只要学会查文档就好了。能够知其然，知其所以然的人自然会比识知识到表皮的人段位要高很多。 3）方法套路。 学习不是为了找到答案，而是找到方法。就像数学一样，你学的是方法，是解题思路，是套路，会用方程式解题的和不会用方程式解题的在解题效率上不可比较，而在微积分面前，其它的解题方法都变成了渣渣。你可以看到，掌握高级方法的人比别人的优势有多大，学习的目的就是为了掌握更为高级的方法和解题思路。 技能 要在技能上超过别人，你就需要在下面几个方面做足功夫： 1）精益求精。 如果你想拥有专业的技能，你要做不仅仅是拼命地重复一遍又一遍的训练，而是在每一次重复训练时你都要找到更好的方法，总结经验，让新的一遍能够更好，更漂亮，更有效率，否则，用相同的方法重复，那你只不过在搬砖罢了。 2）让自己犯错。 犯错是有利于成长的，这是因为出错会让人反思，反思更好的方法，反思更完美的方案，总结教训，寻求更好更完美的过程，是技能升级的最好的方式。尤其是当你在出错后，被人鄙视，被人嘲笑后，你会有更大的动力提升自己，这样的动力才是进步的源动力。当然，千万不要同一个错误重复地犯！ 3）找高手切磋。 下过棋，打个球的人都知道，你要想提升自己的技艺，你必需找高手切磋，在和高手切磋的过程中你会感受到高手的技能和方法，有时候你会情不自禁地哇地一下，我靠，还可以这么玩！ 领导力 最后一个是领导力，要有领导力或是影响力这个事并不容易，这跟你的野心有多大，好胜心有多强 ，你愿意付出多少很有关系，因为一个人的领导力跟他的标准很有关系，因为有领导力的人的标准比绝大多数人都要高。 1）识别自己的特长和天赋。 首先，每个人 DNA 都可能或多或少都会有一些比大多数人 NB 的东西（当然，也可能没有），如果你有了，那么在你过去的人生中就一定会表现出来了，就是那种大家遇到这个事会来请教你的寻求你帮助的现象。那种，别人要非常努力，而且毫不费劲的事。一旦你有了这样的特长或天赋，那你就要大力地扩大你的领先优势，千万不要进到那些会限制你优势的地方。你是一条鱼，你就一定要把别人拉到水里来玩，绝对不要去陆地上跟别人拼，不断地在自己的特长和天赋上扩大自己的领先优势，彻底一骑绝尘。 2）识别自己的兴趣和事业。 没有天赋也没有问题，还有兴趣点，都说兴趣是最好的老师，当年，Linus 就是在学校里对 minx 着迷了，于是整出个 Linux 来，这就是兴趣驱动出的东西，一般来说，兴趣驱动的事总是会比那些被动驱动的更好。但是，这里我想说明一下什么叫 “真∙兴趣”，真正的兴趣不是那种三天热度的东西，而是那种，你愿意为之付出一辈子的事，是那种无论有多大困难有多难受你都要死磕的事，这才是“真∙兴趣”，这也就是你的“野心” 和“好胜心”所在，其实上升到了你的事业。相信我，绝大多数人只有职业而没有事业的。 3）建立高级的习惯和方法。 没有天赋没有野心，也还是可以跟别人拼习惯拼方法的，只要你有一些比较好的习惯和方法，那么你一样可以超过大多数人。对此，在习惯上你要做到比较大多数人更自律，更有计划性，更有目标性，比如，每年学习一门新的语言或技术，并可以参与相关的顶级开源项目，每个月训练一个类算法，掌握一种算法，每周阅读一篇英文论文，并把阅读笔记整理出来…… 自律的是非常可怕的。除此之外，你还需要在方法上超过别人，你需要满世界的找各种高级的方法，其中包括，思考的方法，学习的方法、时间管理的方法、沟通的方法这类软实力的，还有，解决问题的方法（trouble shooting 和 problem solving），设计的方法，工程的方法，代码的方法等等硬实力的，一开始照猫画虎，时间长了就可能会自己发明或推导新的方法。 4）勤奋努力执着坚持。 如果上面三件事你都没有也没有能力，那还有最后一件事了，那就是勤奋努力了，就是所谓的 “一万小时定律” 了（参看《21 天教你学会 C++》中的十年学编程一节），我见过很多不聪明的人，悟性也不够（比如我就是一个），别人学一个东西，一个月就好了，而我需要 1 年甚至更长，但是很多东西都是死的，只要肯花时间就有一天你会搞懂的，耐不住我坚持十年二十年，聪明的人发明个飞机飞过去了，笨一点的人愚公移山也过得去，因为更多的人是懒人，我不用拼过聪明人，我只用拼过那些懒人就好了。 好了，就这么多，如果哪天你变得消极和不自信，你要来读读我的这篇文章，子曰：温故而知新。 （全文完） 本文转自：CoolShell 的《如何超过大多数人》]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>超过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员工作中常见的英语词汇]]></title>
    <url>%2F2019%2F06%2F20%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87%2F</url>
    <content type="text"><![CDATA[程序员工作中常见的英语词汇本列表中的单词是英语类计算机书籍、文档、文章中高频常见的技术词汇，最终目的是希望程序员集合自身的英语基础，在掌握列表中的词汇后，可以无障碍阅读英语技术文章和文档。 本文内容来自Wei-Xia的项目most-frequent-technology-english-words，并加了一些音标 文末是网上搜集的资料 列表 单词 词性 意思 音标 aggregate verb 聚合 英 [‘ægrɪgət; (for v.) ˈægrɪgeɪt] 美 [‘æɡrɪɡət; (for v.) æɡrɪˌɡet] aggregation noun 聚合 英 [,æɡrɪ’ɡeɪʃən] 美 [,ægrɪ’geʃən] analyze verb 分析 英 [‘ænə,laɪz] 美 [‘ænə,laɪz] architecture noun 架构 英 [‘ɑːkɪtektʃə] 美 [‘ɑrkə’tɛktʃɚ] asynchronous adjective 异步的 英 [ə’sɪŋkrənəs; eɪ-] 美 [e’sɪŋkrənəs] capacity noun 能力、容量 英 [kə’pæsɪtɪ] 美 [kə’pæsəti] caveats noun 注意事项 单数：英 [‘kævɪæt; ‘keɪ-] 美 [‘kævɪæt; ‘ke-] complexity noun 复杂性 英 [kəm’pleksətɪ] 美 [kəm’plɛksəti] concatenate verb 连接 英 [kən’kætɪneɪt] 美 [kɑn’kætə,net] concurrent adjective 并发的 英 [kən’kʌr(ə)nt] 美 [kən’kɝənt] consumption noun 消耗 英 [kən’sʌm(p)ʃ(ə)n] 美 [kən’sʌmpʃən] differentiate verb 区别 英 [,dɪfə’renʃɪeɪt] 美 [,dɪfə’rɛnʃɪet] efficiency noun 效率 英 [ɪ’fɪʃ(ə)nsɪ] 美 [ɪˈfɪʃənsɪ] elastic adjective 灵活有弹性的 英 [ɪ’læstɪk] 美 [ɪ’læstɪk] encapsulate verb 压缩、封装 英 [ɪn’kæpsjʊleɪt; en-] 美 [ɪn’kæpsjə’let] expenditure noun 支出，经费 英 [ɪk’spendɪtʃə; ek-] 美 [ɪk’spɛndɪtʃɚ] explicit adjective 明确清楚的 英 [ɪk’splɪsɪt; ek-] 美 [ɪk’splɪsɪt] failover noun 故障切换 英 美 [feil’əuvər] hierarchical adjective 分层的 英 [haɪə’rɑːkɪk(ə)l] 美 [,haɪə’rɑrkɪkl] incident noun 事故 英 [‘ɪnsɪd(ə)nt] 美 [‘ɪnsɪdənt] inexplicit adjective 含糊不清的 英 [ɪnɪk’splɪsɪt; ɪnek-] 美 [ɪnɪk’splɪsɪt; ɪnek-] infrastructure noun 基础结构 英 [‘ɪnfrəstrʌktʃə] 美 [‘ɪnfrə’strʌktʃɚ] intrusive adjective 侵入式的 英 [ɪn’truːsɪv] 美 [ɪn’trusɪv] intuitive adjective 直觉的 英 [ɪn’tjuːɪtɪv] 美 [ɪn’tuɪtɪv] latency noun 延迟 英 [‘leɪtənsɪ] 美 [‘letnsi] mechanism noun 机制 英 [‘mek(ə)nɪz(ə)m] 美 [‘mɛkənɪzəm] metrics noun 度量指标 英 [‘metrɪks] 美 [‘mɛtrɪks] miscellaneous adjective 混杂、各式各样的 英 [,mɪsə’leɪnɪəs] 美 [‘mɪsə’lenɪəs] notation noun 注释、标注 英 [nəʊ’teɪʃ(ə)n] 美 [noʊˈteɪʃən] optimization noun 优化 英 [,ɒptɪmaɪ’zeɪʃən] 美 [,ɑptəmɪ’zeʃən] optimize verb 优化 英 [‘ɒptɪmaɪz] 美 [‘ɑptɪmaɪz] polyfill noun 填充物 populate verb 输入数据 英 [‘pɒpjʊleɪt] 美 [‘pɑpjulet] privilege noun 特权 英 [ˈprɪvəlɪdʒ] 美 [ˈprɪvəlɪdʒ] protocol noun 协议 英 [‘prəʊtəkɒl] 美 [‘protə’kɔl] provision noun 规定、条款 英 [prə’vɪʒ(ə)n] 美 [prə’vɪʒn] redundancy noun 冗余 英 [rɪ’dʌnd(ə)nsɪ] 美 [rɪ’dʌndənsi] reliability noun 可靠性 英 [rɪ,laɪə’bɪlətɪ] 美 [rɪ,laɪə’bɪləti] resilience noun 回弹性 英 [rɪ’zɪlɪəns] 美 [rɪˈzɪliəns] retain verb 保持 英 [rɪ’teɪn] 美 [rɪ’ten] robust adjective 强健的 英 [rə(ʊ)’bʌst] 美 [ro’bʌst] roll off verb 渐渐地退出 - scalability noun 可扩展性 英 美 [,skeilə’biliti] scenarios noun 场景 英 美 [sɪ’nɛrɪ,o] scope noun 范围 英 [skəʊp] 美 [skop] simultaneously adverb 同时地 英 [,sɪml’teɪnɪəslɪ] 美 [saɪməl’tenɪəsli] subsidiary noun 子公司 英 [səb’sɪdɪərɪ] 美 [səb’sɪdɪɛri] sustainable adjective 可持续的 英 [sə’steɪnəb(ə)l] 美 [sə’stenəbl] takeaway noun 收获、学到什么 英 [‘teɪkəweɪ] 美 [‘tekə’we] threshold noun 阈值 英 [‘θreʃəʊld; ‘θreʃ,həʊld] 美 [‘θrɛʃhold] thrilled adjective 非常兴奋的 英 [θrɪld] 美 [θrɪld] throughput noun 吞吐量 英 [‘θruːpʊt] 美 [‘θrʊ’pʊt] tilde noun 波浪号～ 英 [‘tɪldə] 美 [‘tɪldə] tolerance noun 容忍 英 [‘tɒl(ə)r(ə)ns] 美 [‘tɑlərəns] traceability noun 可追溯性 英 [,treɪsə’bɪlətɪ] 美 [,tresə’bɪləti] undertake verb 承担 英 [ʌndə’teɪk] 美 [,ʌndɚ’tek] utilization noun 利用，使用 英 [,juːtɪlaɪ’zeɪʃən] 美 [ˌjuːtəlaɪ’zeɪʃn] workaround noun 解决方案 英 美 [‘wə:kə,raund] 其他网站程序员常用英语词汇]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>英语词汇</tag>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker命令大全整理]]></title>
    <url>%2F2019%2F04%2F24%2FDocker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[目录容器生命周期管理 run start/stop/restart kill∏ rm pause/unpause create exec 容器操作 ps inspect top attach events logs wait export port 容器rootfs命令 commit cp diff 镜像仓库 login pull push search 本地镜像管理 images rmi tag build history save import info|version info version 容器生命周期管理 Docker run 命令 docker run : 创建一个新的容器并运行一个命令 语法 docker run [OPTIONS] IMAGE [COMMAND] [ARG…] OPTIONS说明： -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -p: 端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –name=”nginx-lb”: 为容器指定一个名称； –dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； –dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h “mars”: 指定容器的hostname； -e username=”ritchie”: 设置环境变量； –env-file=[]: 从指定文件读入环境变量； –cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行； -m :设置容器使用内存最大值； –net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； –link=[]: 添加链接到另一个容器； –expose=[]: 开放一个端口或一组端口； 实例 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx 1docker run --name mynginx -d nginx:latest 使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。 1docker run -P -d nginx:latest 使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。 1docker run -p 80:80 -v /data:/data -d nginx:latest 绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。 1$ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash 使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。 12runoob@runoob:~$ docker run -it nginx:latest /bin/bashroot@b8573233d675:/# Docker start/stop/restart 命令 docker start : 启动一个或多个已经被停止的容器 docker stop : 停止一个运行中的容器 docker restart : 重启容器 语法 docker start [OPTIONS] CONTAINER [CONTAINER…] docker stop [OPTIONS] CONTAINER [CONTAINER…] docker restart [OPTIONS] CONTAINER [CONTAINER…] 实例 启动已被停止的容器myrunoob 1docker start myrunoob 停止运行中的容器myrunoob 1docker stop myrunoob 重启容器myrunoob 1docker restart myrunoob Docker kill 命令 docker kill :杀掉一个运行中的容器 语法 docker kill [OPTIONS] CONTAINER [CONTAINER…] OPTIONS说明： -s :向容器发送一个信号 实例 杀掉运行中的容器nginx 12daihui@daihuideMBP:~$ docker kill -s KILL nginxnginx Docker rm 命令 docker rm ： 删除一个或多少容器 语法 docker rm [OPTIONS] CONTAINER [CONTAINER…] OPTIONS说明： -f :通过SIGKILL信号强制删除一个运行中的容器 -l :移除容器间的网络连接，而非容器本身 -v :-v 删除与容器关联的卷 实例 强制删除容器db01、db02 1docker rm -f db01 db02 移除容器nginx01对容器db01的连接，连接名db 1docker rm -l db 删除容器nginx01,并删除容器挂载的数据卷 1docker rm -v nginx01 Docker pause/unpause 命令 docker pause : 暂停容器中所有的进程 docker unpause : 恢复容器中所有的进程 语法 12docker pause [OPTIONS] CONTAINER [CONTAINER...]docker unpause [OPTIONS] CONTAINER [CONTAINER...] 实例 暂停数据库容器db01提供服务 1docker pause db01 恢复数据库容器db01提供服务 1docker unpause db01 Docker create 命令 docker create ： 创建一个新的容器但不启动它 用法同 docker run 语法 docker create [OPTIONS] IMAGE [COMMAND] [ARG…] 语法同 docker run 实例 使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob 12runoob@runoob:~$ docker create --name myrunoob nginx:latest 09b93464c2f75b7b69f83d56a9cfc23ceb50a48a9db7652ee4c27e3e2cb1961e Docker exec 命令 docker exec ： 在运行的容器中执行命令 语法 docker exec [OPTIONS] CONTAINER COMMAND [ARG…] OPTIONS说明： -d :分离模式: 在后台运行 -i :即使没有附加也保持STDIN 打开 -t :分配一个伪终端 实例 在容器 mynginx 中以交互模式执行容器内 /root/runoob.sh 脚本: 12runoob@runoob:~$ docker exec -it mynginx /bin/sh /root/runoob.shhttp://www.runoob.com/ 在容器 mynginx 中开启一个交互模式的终端: 12runoob@runoob:~$ docker exec -i -t mynginx /bin/bashroot@b1a0703e41e7:/# 也可以通过docker ps -a 命令查看已经在运行的容器，然后使用容器 ID 进入容器。 查看已经在运行的容器 ID： 1234# docker ps -a ...9df70f9a0714 openjdk "/usercode/script.sh…" ... 第一列的 9df70f9a0714 就是容器 ID 通过 exec 命令对指定的容器执行 bash: 1# docker exec -it 9df70f9a0714 /bin/bash 容器操作 Docker ps 命令 docker ps : 列出容器 语法 docker ps [OPTIONS] OPTIONS说明： -a :显示所有的容器，包括未运行的。 -f :根据条件过滤显示的内容。 –format :指定返回值的模板文件。 -l :显示最近创建的容器。 -n :列出最近创建的n个容器。 –no-trunc :不截断输出。 -q :静默模式，只显示容器编号。 -s :显示总的文件大小。 实例 列出所有在运行的容器信息 1234runoob@runoob:~$ docker psCONTAINER ID IMAGE COMMAND ... PORTS NAMES09b93464c2f7 nginx:latest "nginx -g 'daemon off" ... 80/tcp, 443/tcp myrunoob96f7f14e99ab mysql:5.6 "docker-entrypoint.sh" ... 0.0.0.0:3306-&amp;gt;3306/tcp mymysql 列出最近创建的5个容器信息。 1234567runoob@runoob:~$ docker ps -n 5CONTAINER ID IMAGE COMMAND CREATED 09b93464c2f7 nginx:latest "nginx -g 'daemon off" 2 days ago ... b8573233d675 nginx:latest "/bin/bash" 2 days ago ... b1a0703e41e7 nginx:latest "nginx -g 'daemon off" 2 days ago ... f46fb1dec520 5c6e1090e771 "/bin/sh -c 'set -x \t" 2 days ago ... a63b4a5597de 860c279d2fec "bash" 2 days ago ... 列出所有创建的容器ID。 123456789101112runoob@runoob:~$ docker ps -a -q09b93464c2f7b8573233d675b1a0703e41e7f46fb1dec520a63b4a5597de6a4aa42e947bde7bb36e796843a432b73776664a8ab1a585ba52eb632bbd... Docker inspect 命令 docker inspect : 获取容器/镜像的元数据 语法 docker inspect [OPTIONS] NAME|ID [NAME|ID…] OPTIONS说明： -f :指定返回值的模板文件 -s :显示总的文件大小 –type :为指定类型返回JSON 实例 获取镜像mysql:5.6的元信息 1234567891011121314151617181920212223runoob@runoob:~$ docker inspect mysql:5.6[ &#123; "Id": "sha256:2c0964ec182ae9a045f866bbc2553087f6e42bfc16074a74fb820af235f070ec", "RepoTags": [ "mysql:5.6" ], "RepoDigests": [], "Parent": "", "Comment": "", "Created": "2016-05-24T04:01:41.168371815Z", "Container": "e0924bc460ff97787f34610115e9363e6363b30b8efa406e28eb495ab199ca54", "ContainerConfig": &#123; "Hostname": "b0cf605c7757", "Domainname": "", "User": "", "AttachStdin": false, "AttachStdout": false, "AttachStderr": false, "ExposedPorts": &#123; "3306/tcp": &#123;&#125; &#125;,... 获取正在运行的容器mymysql的 IP 12runoob@runoob:~$ docker inspect --format='&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' mymysql172.17.0.3 Docker top 命令 docker top : 查看容器中运行的进程信息，支持 ps 命令参数 语法 docker top [OPTIONS] CONTAINER [ps OPTIONS] 容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。 实例 查看容器mymysql的进程信息 123runoob@runoob:~/mysql$ docker top mymysqlUID PID PPID C STIME TTY TIME CMD999 40347 40331 18 00:58 ? 00:00:02 mysqld 查看所有运行容器的进程信息。 1for i in `docker ps |grep Up|awk '&#123;print $1&#125;'`;do echo \ &amp;amp;&amp;amp;docker top $i; done Docker attach 命令 docker attach : 连接到正在运行中的容器 语法 docker attach [OPTIONS] CONTAINER 要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。 实例 容器mynginx将访问日志指到标准输出，连接到容器查看访问信息 12runoob@runoob:~$ docker attach --sig-proxy=false mynginx192.168.239.1 - - [10/Jul/2016:16:54:26 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-" Docker events 命令 docker events : 从服务器获取实时事件 语法 docker events [OPTIONS] OPTIONS说明： -f ：根据条件过滤事件； –since ：从指定的时间戳后显示所有事件； –until ：流水时间显示到指定的时间为止； 实例 显示docker 2016年7月1日后的所有事件 123456runoob@runoob:~/mysql$ docker events --since="1467302400"2016-07-08T19:44:54.501277677+08:00 network connect 66f958fd13dc4314ad20034e576d5c5eba72e0849dcc38ad9e8436314a4149d4 (container=b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64, name=bridge, type=bridge)2016-07-08T19:44:54.723876221+08:00 container start b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (image=nginx:latest, name=elegant_albattani)2016-07-08T19:44:54.726110498+08:00 container resize b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (height=39, image=nginx:latest, name=elegant_albattani, width=167)2016-07-08T19:46:22.137250899+08:00 container die b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (exitCode=0, image=nginx:latest, name=elegant_albattani)... 显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件 1234567891011121314runoob@runoob:~/mysql$ docker events -f "image"="mysql:5.6" --since="1467302400" 2016-07-11T00:38:53.975174837+08:00 container start 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql)2016-07-11T00:51:17.022572452+08:00 container kill 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql, signal=9)2016-07-11T00:51:17.132532080+08:00 container die 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (exitCode=137, image=mysql:5.6, name=mymysql)2016-07-11T00:51:17.514661357+08:00 container destroy 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql)2016-07-11T00:57:18.551984549+08:00 container create c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)2016-07-11T00:57:18.557405864+08:00 container attach c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)2016-07-11T00:57:18.844134112+08:00 container start c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)2016-07-11T00:57:19.140141428+08:00 container die c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (exitCode=1, image=mysql:5.6, name=mymysql)2016-07-11T00:58:05.941019136+08:00 container destroy c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)2016-07-11T00:58:07.965128417+08:00 container create a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)2016-07-11T00:58:08.188734598+08:00 container start a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)2016-07-11T00:58:20.010876777+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)2016-07-11T01:06:01.395365098+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql) 如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since=”2017-07-01” Docker logs 命令 docker logs : 获取容器的日志 语法 docker logs [OPTIONS] CONTAINER OPTIONS说明： -f : 跟踪日志输出 –since :显示某个开始时间的所有日志 -t : 显示时间戳 –tail :仅列出最新N条容器日志 实例 跟踪查看容器mynginx的日志输出 123456runoob@runoob:~$ docker logs -f mynginx192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] "GET / HTTP/1.1" 200 612 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-"2016/07/10 16:53:33 [error] 5#5: *1 open() "/usr/share/nginx/html/favicon.ico" failed (2: No such file or directory), client: 192.168.239.1, server: localhost, request: "GET /favicon.ico HTTP/1.1", host: "192.168.239.130", referrer: "http://192.168.239.130/"192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] "GET /favicon.ico HTTP/1.1" 404 571 "http://192.168.239.130/" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-"192.168.239.1 - - [10/Jul/2016:16:53:59 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-"... 查看容器mynginx从2016年7月1日后的最新10条日志 1docker logs --since="2016-07-01" --tail=10 mynginx Docker wait 命令 docker wait : 阻塞运行直到容器停止，然后打印出它的退出代码 语法 docker wait [OPTIONS] CONTAINER [CONTAINER…] 实例 1docker wait CONTAINER Docker export 命令 docker export : 将文件系统作为一个tar归档文件导出到STDOUT 语法 docker export [OPTIONS] CONTAINER OPTIONS说明： -o :将输入内容写到文件。 实例 将id为a404c6c174a2的容器按日期保存为tar文件 123runoob@runoob:~$ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tarmysql-20160711.tar Docker port 命令 docker port : 列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口 语法 docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]] 实例 查看容器mynginx的端口映射情况。 12runoob@runoob:~$ docker port mymysql3306/tcp -&gt; 0.0.0.0:3306 容器rootfs命令 Docker commit 命令 docker commit : 从容器创建一个新的镜像 语法 docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] OPTIONS说明： -a :提交的镜像作者； -c :使用Dockerfile指令来创建镜像； -m :提交时的说明文字； -p :在commit时，将容器暂停 实例 将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息 12345runoob@runoob:~$ docker commit -a "runoob.com" -m "my apache" a404c6c174a2 mymysql:v1 sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057runoob@runoob:~$ docker images mymysql:v1REPOSITORY TAG IMAGE ID CREATED SIZEmymysql v1 37af1236adef 15 seconds ago 329 MB Docker cp 命令 docker cp : 用于容器与主机之间的数据拷贝 语法 docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|- docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH OPTIONS说明： -L :保持源目标中的链接 实例 将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下 1docker cp /www/runoob 96f7f14e99ab:/www/ 将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www 1docker cp /www/runoob 96f7f14e99ab:/www 将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中 1docker cp 96f7f14e99ab:/www /tmp/ Docker diff 命令 docker diff : 检查容器里文件结构的更改 语法 docker diff [OPTIONS] CONTAINER 实例 查看容器mymysql的文件结构更改 12345678runoob@runoob:~$ docker diff mymysqlA /logsA /mysql_dataC /runC /run/mysqldA /run/mysqld/mysqld.pidA /run/mysqld/mysqld.sockC /tmp 镜像仓库 Docker login 命令 docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub docker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub 语法 docker login [OPTIONS] [SERVER] docker logout [OPTIONS] [SERVER] OPTIONS说明： -u :登陆的用户名 -p :登陆的密码 实例 登陆到Docker Hub 1docker login -u 用户名 -p 密码 登出Docker Hub 1docker logout Docker pull 命令 docker pull : 从镜像仓库中拉取或者更新指定镜像 语法 docker pull [OPTIONS] NAME[:TAG|@DIGEST] OPTIONS说明： -a :拉取所有 tagged 镜像 –disable-content-trust :忽略镜像的校验,默认开启 实例 从Docker Hub下载java最新版镜像。 1docker pull java 从Docker Hub下载REPOSITORY为java的所有镜像。 1docker pull -a java Docker push 命令 docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库 语法 docker push [OPTIONS] NAME[:TAG] OPTIONS说明： –disable-content-trust :忽略镜像的校验,默认开启 实例 上传本地镜像myapache:v1到镜像仓库中 1docker push myapache:v1 Docker search 命令 docker search : 从Docker Hub查找镜像 语法 docker search [OPTIONS] TERM OPTIONS说明： –automated :只列出 automated build类型的镜像； –no-trunc :显示完整的镜像描述； -s :列出收藏数不小于指定值的镜像。 实例 从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像 12345678runoob@runoob:~$ docker search -s 10 javaNAME DESCRIPTION STARS OFFICIAL AUTOMATEDjava Java is a concurrent, class-based... 1037 [OK] anapsix/alpine-java Oracle Java 8 (and 7) with GLIBC ... 115 [OK]develar/java 46 [OK]isuper/java-oracle This repository contains all java... 38 [OK]lwieske/java-8 Oracle Java 8 Container - Full + ... 27 [OK]nimmis/java-centos This is docker images of CentOS 7... 13 [OK] 本地镜像管理 Docker images 命令 docker images : 列出本地镜像 语法 docker images [OPTIONS] [REPOSITORY[:TAG]] OPTIONS说明： -a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）； –digests :显示镜像的摘要信息； -f :显示满足条件的镜像； –format :指定返回值的模板文件； –no-trunc :显示完整的镜像信息； -q :只显示镜像ID。 实例 查看本地镜像列表 123456789101112runoob@runoob:~$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmymysql v1 37af1236adef 5 minutes ago 329 MBrunoob/ubuntu v4 1c06aa18edee 2 days ago 142.1 MB&amp;lt;none&amp;gt; &amp;lt;none&amp;gt; 5c6e1090e771 2 days ago 165.9 MBhttpd latest ed38aaffef30 11 days ago 195.1 MBalpine latest 4e38e38c8ce0 2 weeks ago 4.799 MBmongo 3.2 282fd552add6 3 weeks ago 336.1 MBredis latest 4465e4bcad80 3 weeks ago 185.7 MBphp 5.6-fpm 025041cd3aa5 3 weeks ago 456.3 MBpython 3.5 045767ddf24a 3 weeks ago 684.1 MB... 列出本地镜像中REPOSITORY为ubuntu的镜像列表 1234root@runoob:~# docker images ubuntuREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 14.04 90d5884b1ee0 9 weeks ago 188 MBubuntu 15.10 4e3b13c8a266 3 months ago 136.3 MB Docker rmi 命令 docker rmi : 删除本地一个或多少镜像 语法 docker rmi [OPTIONS] IMAGE [IMAGE…] OPTIONS说明： -f :强制删除； –no-prune :不移除该镜像的过程镜像，默认移除； 实例 强制删除本地镜像runoob/ubuntu:v4。 1234root@runoob:~# docker rmi -f runoob/ubuntu:v4Untagged: runoob/ubuntu:v4Deleted: sha256:1c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072beDeleted: sha256:85feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73 Docker tag 命令 docker tag : 标记本地镜像，将其归入某一仓库 语法 docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG] 实例 将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像 1234root@runoob:~# docker tag ubuntu:15.10 runoob/ubuntu:v3root@runoob:~# docker images runoob/ubuntu:v3REPOSITORY TAG IMAGE ID CREATED SIZErunoob/ubuntu v3 4e3b13c8a266 3 months ago 136.3 MB Docker build 命令 docker build 命令用于使用 Dockerfile 创建镜像 语法 docker build [OPTIONS] PATH | URL | - OPTIONS说明： –build-arg=[] :设置镜像创建时的变量； –cpu-shares :设置 cpu 使用权重； –cpu-period :限制 CPU CFS周期； –cpu-quota :限制 CPU CFS配额； –cpuset-cpus :指定使用的CPU id； –cpuset-mems :指定使用的内存 id； –disable-content-trust :忽略校验，默认开启； -f :指定要使用的Dockerfile路径； –force-rm :设置镜像过程中删除中间容器； –isolation :使用容器隔离技术； –label=[] :设置镜像使用的元数据； -m :设置内存最大值； –memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap； –no-cache :创建镜像的过程不使用缓存； –pull :尝试去更新镜像的新版本； –quiet, -q :安静模式，成功后只输出镜像 ID； –rm :设置镜像成功后删除中间容器； –shm-size :设置/dev/shm的大小，默认值是64M； –ulimit :Ulimit配置。 –tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。 –network: 默认 default。在构建期间设置RUN指令的网络模式 实例 使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。 1docker build -t runoob/ubuntu:v1 . 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。 1docker build github.com/creack/docker-firefox 也可以通过 -f Dockerfile 文件的位置： 1$ docker build -f /path/to/a/Dockerfile . 在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回： 123$ docker build -t test/myapp .Sending build context to Docker daemon 2.048 kBError response from daemon: Unknown instruction: RUNCMD Docker history 命令 docker history : 查看指定镜像的创建历史 语法 docker history [OPTIONS] IMAGE OPTIONS说明： -H :以可读的格式打印镜像大小和日期，默认为true； –no-trunc :显示完整的提交记录； -q :仅列出提交记录ID。 实例 查看本地镜像runoob/ubuntu:v3的创建历史 123456root@runoob:~# docker history runoob/ubuntu:v3IMAGE CREATED CREATED BY SIZE COMMENT4e3b13c8a266 3 months ago /bin/sh -c #(nop) CMD ["/bin/bash"] 0 B &amp;lt;missing&amp;gt; 3 months ago /bin/sh -c sed -i 's/^#\s*\(deb.*universe\)$/ 1.863 kB &amp;lt;missing&amp;gt; 3 months ago /bin/sh -c set -xe &amp;amp;&amp;amp; echo '#!/bin/sh' &amp;gt; /u 701 B &amp;lt;missing&amp;gt; 3 months ago /bin/sh -c #(nop) ADD file:43cb048516c6b80f22 136.3 MB Docker save 命令 docker save : 将指定镜像保存成 tar 归档文件 语法 docker save [OPTIONS] IMAGE [IMAGE…] OPTIONS说明： -o :输出到的文件 实例 将镜像runoob/ubuntu:v3 生成my_ubuntu_v3.tar文档 123runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3runoob@runoob:~$ ll my_ubuntu_v3.tar-rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.ta Docker import 命令 docker import : 从归档文件中创建镜像 语法 docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]] OPTIONS说明： -c :应用docker 指令创建镜像； -m :提交时的说明文字； 实例 从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4 12345runoob@runoob:~$ docker import my_ubuntu_v3.tar runoob/ubuntu:v4 sha256:63ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39runoob@runoob:~$ docker images runoob/ubuntu:v4REPOSITORY TAG IMAGE ID CREATED SIZErunoob/ubuntu v4 63ce4a6d6bc3 20 seconds ago 142.1 MB info|version Docker info 命令 docker info : 显示 Docker 系统信息，包括镜像和容器数 语法 docker info [OPTIONS] 实例 查看docker系统信息 12345678910111213141516$ docker infoContainers: 12Images: 41Storage Driver: aufs Root Dir: /var/lib/docker/aufs Backing Filesystem: extfs Dirs: 66 Dirperm1 Supported: falseExecution Driver: native-0.2Logging Driver: json-fileKernel Version: 3.13.0-32-genericOperating System: Ubuntu 14.04.1 LTSCPUs: 1Total Memory: 1.954 GiBName: iZ23mtq8bs1ZID: M5N4:K6WN:PUNC:73ZN:AONJ:AUHL:KSYH:2JPI:CH3K:O4MK:6OCX:5OYW Docker version 命令 docker version : 显示 Docker 版本信息 语法 docker version [OPTIONS] OPTIONS说明： -f :指定返回值的模板文件 实例 显示 Docker 版本信息 12345678910111213141516$ docker versionClient: Version: 1.8.2 API version: 1.20 Go version: go1.4.2 Git commit: 0a8c2e3 Built: Thu Sep 10 19:19:00 UTC 2015 OS/Arch: linux/amd64Server: Version: 1.8.2 API version: 1.20 Go version: go1.4.2 Git commit: 0a8c2e3 Built: Thu Sep 10 19:19:00 UTC 2015 OS/Arch: linux/amd64]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上用QuickTimePlayer和Soundflower插件录制完美视频]]></title>
    <url>%2F2019%2F04%2F10%2FMac%E4%B8%8A%E7%94%A8QuickTimePlayer%E5%92%8CSoundflower%E6%8F%92%E4%BB%B6%E5%BD%95%E5%88%B6%E5%AE%8C%E7%BE%8E%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[前言MacOS自带的QuickTime Player录制视频的时候默认是不会有内部视频里的音频的，默认情况下除非你开到最大声，然后通过内置的麦克风“听到”，又录进到视频。这是很傻X的。今天整理了一下可以录制到音视频的两个方法： 录制只有屏内音频视频的方法 录制有屏内音频和屏外声音视频的方法 前提 软件： Soundflower 小插件操作系统：macOS其他：一个聪明的脑袋 1. 下载Soundflower并安装点击上面这个链接，进入GitHub选择下载Soundflower-2.0b2.dmg(版本可能不一样) 下载完成后，无脑安装，再次期间可能会提示提示来自身份不明的开发者，这个时候不要慌，打开系统偏好设置-&gt;安全性与隐私，选择“仍要打开”（此时我们在“通用”选项卡） 在这里我们顺便检查一下，QuickTime Player的麦克风权限。打开系统偏好设置-&gt;安全性与隐私-&gt;选择“隐私”选项卡，选择左侧的“麦克风”选项，看右侧的“QuickTime Player”有没有勾上对勾，没有的话把它勾上 到这里Soundflower基本就算安装好了，接下来开始设置 2. 设置设置我们需要打开音频 MIDI 设置这个Mac自带的软件： 2.1 创建多输出设备并设置点击左下角“+”，选择“创建多输出设备”，按如图所示设置： 2.2 创建只有屏内音频的配置（创建聚集设备）点击左下角“+”，选择“创建聚集设备”，将默认名称（聚集设备）改为自己的名称，以区分另外一个聚集设备，按如图所示设置： 2.3 创建屏内音频和屏外声音的配置（创建聚集设备）点击左下角“+”，选择“创建聚集设备”，将默认名称（聚集设备）改为自己的名称，以区分另外一个聚集设备，按如图所示设置： 3. 录制录制时因为分为两种不同的方式，所以在录制是设置稍有不同，我大致总结如下： 1234567891011121314151.录制只有内部音频 QuickTime： 选择对应的设置(录屏专用-内部音频) ✔️ 音量最小 （调大会有回音，默认最小即可） 扬声器输出： 多输出设备 ✔️2.录制有内外部音频 QuickTime： 选择对应的设置(录屏专用-内外部音频) ✔️ 音量最小 （调大会有回音，默认最小即可） 扬声器： 多输出设备（内外声音结合很好，效果好） ✔️ 内置扬声器（内部音频不明显，人声大，内部声音小，效果不好） 刚才建的两个选项（自己听不到声音，但是录完屏后视频内有声音） 看不懂的同学请往下看 3.1 录制只有屏内音频视频的方法打开QuickTime Player，右键“新建屏幕录制”，选择“录屏专用-内部音频”，音量选项保持最小(调大会有回音，默认最小即可） 点击右上角“小喇叭”并选择“多输出设备”： 如果没有小喇叭可以打开系统偏好设置-&gt;声音-&gt;选择输出选项卡，选中“多输出设备”。最后把“在菜单栏中显示音量”选中即可，方便以后使用 至此，点击开始，录制你的视频吧 3.2 录制有屏内音频和屏外声音视频的方法打开QuickTime Player，右键“新建屏幕录制”，选择“录屏专用-内外部音频”，音量选项保持最小(调大会有回音，默认最小即可） 点击右上角“小喇叭”并选择“多输出设备”： 剩下的其他选项： 内置扬声器（内部音频不明显，人声大，内部声音小，效果不好）刚才建的两个选项(录屏专用-内部音频/录屏专用-内外部音频)，自己听不到声音，但是录完屏后视频内有声音（感觉这个适合用来夜深人静的时候录~） 至此，点击开始，录制你的视频吧 4. 补充如果同学你机器上装有 homebrew 和 homebrew cask，可以直接用如下命令安装Soundflower： 1brew cask install soundflower]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>录视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派3B+制作视频监控]]></title>
    <url>%2F2019%2F03%2F12%2F%E6%A0%91%E8%8E%93%E6%B4%BE3Bplus%E5%88%B6%E4%BD%9C%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[背景：本人育有一毛，此猫调皮捣蛋，因此想要做个监控放在家里，在公司上班的时候看看它到底在家里捣什么鬼蛋！ 前提 环境：树莓派3B+操作系统：树莓派3B+默认系统摄像头：N年前买的一个USB摄像头（比树莓派官方好点） 1.更新列表这一步可能有点慢，请耐心等待。 12345# 更新软件列表sudo apt-get update# 更新软件sudo apt-get upgrade 2.开启摄像头执行如下命令，进入配置页面，开启摄像头。 1sudo raspi-config 选择: “是” -&gt; “Back” -&gt; “Finish” 重启一下树莓派 3.安装依赖库12345# JPEG支持库sudo apt-get install libjpeg8-dev#下载编译工具sudo apt-get install cmake 4.下载mjpg-streamer随意找个目录执行： 1git clone https://github.com/jacksonliam/mjpg-streamer.git 以常见的Downloads目录为例： 12pi@raspberrypi:~ $ cd Downloads/pi@raspberrypi:~ $ git clone https://github.com/jacksonliam/mjpg-streamer.git 5.编辑源文件（非必须）网上有教程基本都编辑plugins/input_raspicam/input_raspicam.c源码里的几个参数（fps、width和height），这个文件是对应官方的摄像头（RaspiCamera）。 我这里用的是自己的普通USB摄像头，所以这个文件可以不用修改。 如果你的摄像头是普通USB摄像头，可以跳过。 如果你的摄像头是官方的摄像头（RaspiCamera）那么请修改之： 12pi@raspberrypi:/ $ cd /home/pi/Downloads/mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/pi@raspberrypi:~/Downloads/mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/ $ vi input_raspicam.c 6.编译mjpg-streamer进入工程mjpg-streamer-experimental，进行完全编译。 1pi@raspberrypi:~/Downloads/mjpg-streamer/mjpg-streamer-experimental $ make clean all 7.开启mjpg-streamer进入mjpg-streamer-experimental目录，使用一下指令启动摄像头。 启动普通USB摄像头指令： 1./mjpg_streamer -i "./input_uvc.so" -o "./output_http.so -w ./www" 启动树莓派专用摄像头RaspiCamera指令： 1./mjpg_streamer -i "./input_raspicam.so" -o "./output_http.so -w ./www" 8.测试在浏览器里输入： 12345678# 静态图（拍照）http://&lt;IP&gt;：8080/?action=snapshot# 动态图（视频监控）http://&lt;IP&gt;：8080/?action=stream# 这个兼容性好点http://&lt;IP&gt;：8080/javascript_stream.html 9.问题有的同学可能在开启mjpg-streamer的时候会报错，可能是你USB摄像头用了树莓派专用摄像头RaspiCamera指令的指令启动造成的（我就是这样，哈哈哈）]]></content>
      <categories>
        <category>OS</category>
        <category>Raspberry</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac远程连接谷歌云VM实例]]></title>
    <url>%2F2019%2F02%2F19%2FMac%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%B0%B7%E6%AD%8C%E4%BA%91VM%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[一般在管理远程主机时，都用ssh登录，ssh user@host，但是这样每次会使用密码。 使用ssh-keygen生成的密钥对，然后将公钥添加的目标主机的~/.ssh/authorized_keys文件中，当前主机就成为可信任的主机，下次使用ssh登录时，就不用输入密码了官方网站的教程很详细，但是表达方式不是很好理解，并且有的功能在操作上第一次用GCP的我来说有点陌生，这里就Linux或Mac连接VM实例方式作一个简要记录（全是大白话） 第一步:生成密钥对1ssh-keygen -t rsa -f ~/.ssh/秘钥名称 -C "邮箱" 这样就在主目录下的.ssh目录中生成了两个文件“秘钥名称”和“秘钥名称.pub”。“秘钥名称”中保存的是私钥，”秘钥名称.pub“中保存的是公钥。 第二步:添加公钥拷贝公钥到剪切板:1pbcopy &lt; 秘钥名称.pub 在GPC导航菜单中找到”元数据“连接，选择”SSH秘钥“选项卡-&gt;点击”修改“按钮-&gt;”添加一项“，粘贴公钥，保存，就添加完成了。 第三步:测试1ssh -i ~/.ssh/秘钥名称 用户名@VM外部IP 用户名，在第二部添加公钥时，粘贴之后会在第一列出现你的用户名 如果没问题的话你已经进入到VM实例终端了 同样的方式gitlab和GitHub也是支持的]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>GCP</tag>
        <tag>谷歌云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下利用GCP和v2ray搭建无限使用梯子]]></title>
    <url>%2F2019%2F02%2F18%2FMac%E4%B8%8B%E5%88%A9%E7%94%A8GCP%E5%92%8Cv2ray%E6%90%AD%E5%BB%BA%E6%97%A0%E9%99%90%E4%BD%BF%E7%94%A8%E6%A2%AF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[前言妈妈再也不用为我担心没梯子用了 新用户申请GCP(Google Cloud Platform) 这一步很蛋疼，需要先fq，所以小伙伴们可以先借同事或朋友的梯子注册一下来搞。总之，先注册上GCP 进去之后按照步骤填写信息。在最后需要小伙伴填写一个信用卡号，用来验证和今后扣取费用（我们这里只需要验证，右边的提示也说不会自动扣费） 关于信用卡，小伙伴们可以上某宝买一个，直接搜“虚拟信用卡”，大概在25元左右一个。一般来说店小二会给你提供包括：持卡人、卡号、卡有效期、CVV和账单地址等信息。这些信息在注册GCP时按照店小二给你发的如实填写即可。注：地区最好和店小二发给你的保持一致。 假设到这里没问题的话，点击注册，你就会得到一个为期365天的试用期，里面有300刀。 创建MV实例 进入 “导航菜单”-&gt;“Compute Engine”-&gt;”VM 实例”，选择“VM 实例”。首次进来可能需要初始化一下，初始化后点击“创建”来创建我们的VM；如果以前用过的话直接点击创建实例即可。 进入到创建实例界面，按照步骤填写即可，这里给个建议： 区域，最好选一个里你进的地方，比如香港，台湾，东京等地；机器类型 机器类型，选择微型即可，够用且便宜 启动磁盘，默认即可 防火墙，“允许HTTP流量”和“允许HTTPS流量”都勾上 展开防火墙管理，选择“网络”，并在“网络标记”处填入防火墙出入站规则名称，分别为“ruzhan”和”chuzhan“（咱们先填写，后面再创建） 点击创建，完成MV创建 安装v2ray 点击新创建的实例的连接“SSH”，登入远程连接。登入后做一下几个准备操作： 切换为管理员，sudo -i 执行”date -R”查看当前时间和服务器是否一致（一般都不一致） 以服务器在上海的为例，执行一下命令将时间同步一下 “cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime“，执行后查看当前时间是否一致“date -R”，这个时候发现时间已经同步了 接下来开始安装v2ray，咱们直接执行官方提供的脚本命令”bash &lt;(curl -L -s https://install.direct/go.sh)“ 等待安装完毕，配置v2ray的配置文件位置在”/etc/v2ray/config.json”，里面已经有一个官方默认配置好的配置，我们先把内容删除，都是基本vi操作。打开”vi /etc/v2ray/config.json“，按”dd“删除了第一行，后面的可以直接按”.”把剩下的内容删完。 此时咱们打开v2ray配置生成器，设置填写建议如下： 服务种类：默认 用户设置-&gt;用户uuid：多点几下 用户设置-&gt;使用的alterID数量：随意，我填了101 端口设置-&gt;端口号：随意，找一个不太会被占用的 点击服务端配置的复制配置，将该配置粘贴到”/etc/v2ray/config.json“，在删完内容的配置文件里按下”i”，直接command+v粘贴即可 依次按下 ”ESC“+”:wq“+回车，保存退出 重启v2ray服务，”sudo systemctl restart v2ray“ 查看v2ray运行状态，”service v2ray status“，看到此时已经是”Active: active (running)“ 到此MV基本配置完成，接下来配置两个出入站规则 出入站防火墙搭建 进入 “导航菜单”-&gt;“VPC网络”-&gt;”防火墙规则”，点击”创建防火墙规则“，分别创建出站和入站规则，如下图： 出站规则 入站规则 回到MV实例，单击MV实例的名称，进入到MV实例详情页面，点击”修改“，如果在创建VM实例步骤没有配置”网络标记“选项，在这里把出入站规则名称填入其中，保存即可；因为在创建VM实例时已经把出入站名称填好了，这里就不用设置了 配置Mac端v2ray客户端配置信息 没有客户端的小伙伴可以自行下载，Mac端可以用brew安装”brew cask install v2rayx“ 安装完毕，打开软件配置。点击”Configure…“，配置可参考我的： 配置完成，选择”Global Mode“，再点击”local core“，完成！剩下的你懂的 续命 当你试用账号快到期的时候，进入“导航菜单”-&gt;“结算”-&gt;”显示信息面板“，将结算账号管理员删除，过个5、6分钟后再次申请试用账号即可，而且你的VM也还在]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>梯子</tag>
        <tag>v2ray</tag>
        <tag>GCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win2008R2磁盘脱机和写入保护解决办法]]></title>
    <url>%2F2018%2F10%2F22%2Fwin2008R2%E7%A3%81%E7%9B%98%E8%84%B1%E6%9C%BA%E5%92%8C%E5%86%99%E5%85%A5%E4%BF%9D%E6%8A%A4%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[打开cmd命令行，输入：diskpart，进入diskpart工具 输入：list disk，查看到所有磁盘 找到脱机的磁盘，输入：select disk 1 接着输入：online disk 查看此时磁盘联机状态 清除只读属性，输入：attribute disk clear readonly 查看此时的清盘情况，输入：attribute disk]]></content>
      <categories>
        <category>OS</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows磁盘脱机</tag>
        <tag>写入保护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8中的StreamsAPI详解]]></title>
    <url>%2F2018%2F09%2F30%2FJava8%E4%B8%AD%E7%9A%84StreamsAPI%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Java 8 中的 Streams API 详解为什么需要 StreamStream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。 Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。 所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。 什么是聚合操作在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如： 客户每月平均消费金额 最昂贵的在售商品 本周完成的有效订单（排除了无效的） 取十个数据样本作为首页推荐 这类的操作。 但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写： 清单 1. Java 7 的排序、取值实现 123456789101112131415List&lt;Transaction&gt; groceryTransactions = new Arraylist&lt;&gt;();for(Transaction t: transactions)&#123; if(t.getType() == Transaction.GROCERY)&#123; groceryTransactions.add(t); &#125;&#125;Collections.sort(groceryTransactions, new Comparator()&#123; public int compare(Transaction t1, Transaction t2)&#123; return t2.getValue().compareTo(t1.getValue()); &#125;&#125;);List&lt;Integer&gt; transactionIds = new ArrayList&lt;&gt;();for(Transaction t: groceryTransactions)&#123; transactionsIds.add(t.getId());&#125; 而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。 清单 2. Java 8 的排序、取值实现 12345List&lt;Integer&gt; transactionsIds = transactions.parallelStream(). filter(t -&gt; t.getType() == Transaction.GROCERY). sorted(comparing(Transaction::getValue).reversed()). map(Transaction::getId). collect(toList()); Stream 总览什么是流Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。 Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。 而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下： 1 1.0-1.4 中的 java.lang.Thread 2 5.0 中的 java.util.concurrent 3 6.0 中的 Phasers 等 4 7.0 中的 Fork/Join 框架 5 8.0 中的 Lambda Stream 的另外一大特点是，数据源本身可以是无限的。 流的构成当我们使用一个流的时候，通常包括三个基本步骤： 获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。 图 1. 流管道 (Stream Pipeline) 的构成 有多种方式生成 Stream Source： 从 Collection 和数组 Collection.stream() Collection.parallelStream() Arrays.stream(T array) or Stream.of() 从 BufferedReader java.io.BufferedReader.lines() 静态工厂 java.util.stream.IntStream.range() java.nio.file.Files.walk() 自己构建 java.util.Spliterator 其它 Random.ints() BitSet.stream() Pattern.splitAsStream(java.lang.CharSequence) JarFile.stream() 流的操作类型分为两种： Intermediate：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。 Terminal：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。 在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。 还有一种操作被称为 short-circuiting。用以指： 对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。 对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。 当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。 清单 3. 一个流操作的示例 1234int sum = widgets.stream().filter(w -&gt; w.getColor() == RED) .mapToInt(w -&gt; w.getWeight()) .sum(); stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。 流的使用详解简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。 流的构造与转换下面提供最常见的几种构造 Stream 的样例。 清单 4. 构造流的几种常见方法 123456789// 1. Individual valuesStream stream = Stream.of("a", "b", "c");// 2. ArraysString [] strArray = new String[] &#123;"a", "b", "c"&#125;;stream = Stream.of(strArray);stream = Arrays.stream(strArray);// 3. CollectionsList&lt;String&gt; list = Arrays.asList(strArray);stream = list.stream(); 需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream： IntStream、LongStream、DoubleStream。当然我们也可以用 Stream&lt;Integer>、Stream&lt;Long>、Stream&lt;Double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。 Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。 清单 5. 数值流的构造 123IntStream.of(new int[]&#123;1, 2, 3&#125;).forEach(System.out::println);IntStream.range(1, 3).forEach(System.out::println);IntStream.rangeClosed(1, 3).forEach(System.out::println); 清单 6. 流转换为其它数据结构 123456789// 1. ArrayString[] strArray1 = stream.toArray(String[]::new);// 2. CollectionList&lt;String&gt; list1 = stream.collect(Collectors.toList());List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));Set set1 = stream.collect(Collectors.toSet());Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));// 3. StringString str = stream.collect(Collectors.joining()).toString(); 一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。 流的操作接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。 Intermediate： map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered Terminal： forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator Short-circuiting： anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit 我们下面看一下 Stream 的比较典型用法。 map/flatMap 我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。 清单 7. 转换大写 123List&lt;String&gt; output = wordList.stream().map(String::toUpperCase).collect(Collectors.toList()); 这段代码把所有的单词转换为大写。 清单 8. 平方数 1234List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4);List&lt;Integer&gt; squareNums = nums.stream().map(n -&gt; n * n).collect(Collectors.toList()); 这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。 从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。 清单 9. 一对多 1234567Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of( Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6) );Stream&lt;Integer&gt; outputStream = inputStream.flatMap((childList) -&gt; childList.stream()); flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。 filter filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。 清单 10. 留下偶数 123Integer[] sixNums = &#123;1, 2, 3, 4, 5, 6&#125;;Integer[] evens =Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new); 经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。 清单 11. 把单词挑出来 1234List&lt;String&gt; output = reader.lines(). flatMap(line -&gt; Stream.of(line.split(REGEXP))). filter(word -&gt; word.length() &gt; 0). collect(Collectors.toList()); 这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。 forEach forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。 清单 12. 打印姓名（forEach 和 pre-java8 的对比） 12345678910// Java 8roster.stream() .filter(p -&gt; p.getGender() == Person.Sex.MALE) .forEach(p -&gt; System.out.println(p.getName()));// Pre-Java 8for (Person p : roster) &#123; if (p.getGender() == Person.Sex.MALE) &#123; System.out.println(p.getName()); &#125;&#125; 对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。 但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。 另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的： 12stream.forEach(element -&gt; doOneThing(element));stream.forEach(element -&gt; doAnotherThing(element)); 相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。 清单 13. peek 对每个元素执行操作并返回一个新的 Stream 123456Stream.of("one", "two", "three", "four") .filter(e -&gt; e.length() &gt; 3) .peek(e -&gt; System.out.println("Filtered value: " + e)) .map(String::toUpperCase) .peek(e -&gt; System.out.println("Mapped value: " + e)) .collect(Collectors.toList()); forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。 findFirst 这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。 这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。 清单 14. Optional 的两个用例 123456789101112131415161718192021String strA = " abcd ", strB = null;print(strA);print("");print(strB);getLength(strA);getLength("");getLength(strB);public static void print(String text) &#123; // Java 8 Optional.ofNullable(text).ifPresent(System.out::println); // Pre-Java 8 if (text != null) &#123; System.out.println(text); &#125; &#125;public static int getLength(String text) &#123; // Java 8return Optional.ofNullable(text).map(String::length).orElse(-1); // Pre-Java 8// return if (text != null) ? text.length() : -1; &#125;; 在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。 Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。 reduce 这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于 Integer sum = integers.reduce(0, (a, b) -&gt; a+b); 或 Integer sum = integers.reduce(0, Integer::sum); 也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。 清单 15. reduce 的用例 123456789101112// 字符串连接，concat = "ABCD"String concat = Stream.of("A", "B", "C", "D").reduce("", String::concat); // 求最小值，minValue = -3.0double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); // 求和，sumValue = 10, 有起始值int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);// 求和，sumValue = 10, 无起始值sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();// 过滤，字符串连接，concat = "ace"concat = Stream.of("a", "B", "c", "D", "e", "F"). filter(x -&gt; x.compareTo("Z") &gt; 0). reduce("", String::concat); 上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。 limit/skip limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。 清单 16. limit 和 skip 对运行次数的影响 12345678910111213141516171819202122public void testLimitAndSkip() &#123; List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 10000; i++) &#123; Person person = new Person(i, "name" + i); persons.add(person); &#125;List&lt;String&gt; personList2 = persons.stream().map(Person::getName).limit(10).skip(3).collect(Collectors.toList()); System.out.println(personList2);&#125;private class Person &#123; public int no; private String name; public Person (int no, String name) &#123; this.no = no; this.name = name; &#125; public String getName() &#123; System.out.println(name); return name; &#125;&#125; 输出结果为： 1234567891011name1name2name3name4name5name6name7name8name9name10[name4, name5, name6, name7, name8, name9, name10] 这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。 有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。 清单 17. limit 和 skip 对 sorted 后的运行次数无影响 12345678List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) &#123; Person person = new Person(i, "name" + i); persons.add(person); &#125;List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());System.out.println(personList2); 上面的示例对清单 13 做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为： 123456789name2name1name3name2name4name3name5name4[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27] 即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。 最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。 sorted 对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化： 清单 18. 优化：排序前进行 limit 和 skip 1234567List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) &#123; Person person = new Person(i, "name" + i); persons.add(person); &#125;List&lt;Person&gt; personList2 = persons.stream().limit(2).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());System.out.println(personList2); 结果会简单很多： 123name2name1[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a] 当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。 min/max/distinct min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。 清单 19. 找出最长一行的长度 1234567BufferedReader br = new BufferedReader(new FileReader("c:\\SUService.log"));int longest = br.lines(). mapToInt(String::length). max(). getAsInt();br.close();System.out.println(longest); 下面的例子则使用 distinct 来找出不重复的单词。 清单 20. 找出全文的单词，转小写，并排序 123456789List&lt;String&gt; words = br.lines(). flatMap(line -&gt; Stream.of(line.split(" "))). filter(word -&gt; word.length() &gt; 0). map(String::toLowerCase). distinct(). sorted(). collect(Collectors.toList());br.close();System.out.println(words); Match Stream 有三个 match 方法，从语义上说： allMatch：Stream 中全部元素符合传入的 predicate，返回 true anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true 它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。 清单 21. 使用 Match 123456789101112List&lt;Person&gt; persons = new ArrayList();persons.add(new Person(1, "name" + 1, 10));persons.add(new Person(2, "name" + 2, 21));persons.add(new Person(3, "name" + 3, 34));persons.add(new Person(4, "name" + 4, 6));persons.add(new Person(5, "name" + 5, 55));boolean isAllAdult = persons.stream(). allMatch(p -&gt; p.getAge() &gt; 18);System.out.println("All are adult? " + isAllAdult);boolean isThereAnyChild = persons.stream(). anyMatch(p -&gt; p.getAge() &lt; 12);System.out.println("Any child? " + isThereAnyChild); 输出结果： 12All are adult? falseAny child? true 进阶：自己生成流Stream.generate 通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。 清单 22. 生成 10 个随机整数 123456Random seed = new Random();Supplier&lt;Integer&gt; random = seed::nextInt;Stream.generate(random).limit(10).forEach(System.out::println);//Another wayIntStream.generate(() -&gt; (int) (System.nanoTime() % 100)).limit(10).forEach(System.out::println); Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。 清单 23. 自实现 Supplier 1234567891011Stream.generate(new PersonSupplier()).limit(10).forEach(p -&gt; System.out.println(p.getName() + ", " + p.getAge()));private class PersonSupplier implements Supplier&lt;Person&gt; &#123; private int index = 0; private Random random = new Random(); @Override public Person get() &#123; return new Person(index++, "StormTestUser" + index, random.nextInt(100)); &#125;&#125; 输出结果： 12345678910StormTestUser1, 9StormTestUser2, 12StormTestUser3, 88StormTestUser4, 51StormTestUser5, 22StormTestUser6, 28StormTestUser7, 81StormTestUser8, 51StormTestUser9, 4StormTestUser10, 76 Stream.iterate iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。 清单 24. 生成一个等差数列 1Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + " "));. 输出结果： 10 3 6 9 12 15 18 21 24 27 与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。 进阶：用 Collectors 来进行 reduction 操作java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。groupingBy/partitioningBy 清单 25. 按照年龄归组 12345678Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.groupingBy(Person::getAge));Iterator it = personGroups.entrySet().iterator();while (it.hasNext()) &#123; Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next(); System.out.println("Age " + persons.getKey() + " = " + persons.getValue().size());&#125; 上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出： 1234567Age 0 = 2Age 1 = 2Age 5 = 2Age 8 = 1Age 9 = 1Age 11 = 2…… 清单 26. 按照未成年人和成年人归组 12345Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()).limit(100). collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));System.out.println("Children number: " + children.get(true).size());System.out.println("Adult number: " + children.get(false).size()); 输出结果： 12Children number: 23 Adult number: 77 在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。 结束语总之，Stream 的特性可以归纳为： 不是数据结构 它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。 它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。 所有 Stream 的操作必须以 lambda 表达式为参数 不支持索引访问 你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。 很容易生成数组或者 List 惰性化 很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。 Intermediate 操作永远是惰性化的。 并行能力 当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。 可以是无限的 集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。]]></content>
      <categories>
        <category>Java</category>
        <category>Stream</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Streams API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装软件时提示已损坏的解决方法]]></title>
    <url>%2F2018%2F09%2F27%2FMac%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%97%B6%E6%8F%90%E7%A4%BA%E5%B7%B2%E6%8D%9F%E5%9D%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[从网上下载的常用软件，安装时总是提示“已损坏，移至废纸篓”这类信息，无法打开。如下图： 这是新系统（macOS Sierra 10.12.X）惹的祸。新系统加强了安全机制，默认不允许用户自行下载安装应用程序，只能从Mac App Store里安装应用。 解决办法：打开终端，在终端中输入：1sudo spctl --master-disable 输入密码，回车。搞定]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>文件损坏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机Linux的root或普通用户密码忘记找回]]></title>
    <url>%2F2018%2F07%2F31%2F%E8%99%9A%E6%8B%9F%E6%9C%BALinux%E7%9A%84root%E6%88%96%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E5%BF%98%E8%AE%B0%E6%89%BE%E5%9B%9E%2F</url>
    <content type="text"><![CDATA[启动VMware的Linux 进入GRUB界面后，有几秒钟时间给你。进入GRUB出现： Red Hat Enterprise Linux Server (2.6.18-8.e15xen) 倒计时结束前，键入e出现：root（hd0,0）kernel /xen.gz-2.6.28-8.e15module /vmlinux-2.6.18.e15xen ro root=/dev/VolGroup00/LogVo100 rhgb quietmodule /initrd-2.6.18-8.e15xen.img上下键移到quiet那一行，按e进入，加上 linux single或者1即可，回车 按b后进入重启模式，一定注意出现： Starting udev: 在后面输入boot回车 之后出现命令行： sh-3.2# 输入passwd，回车即可修改root密码，输入两次密码 完成之后reboot即可重启。 普通用户密码忘记了，比较简单 在root账户下，打开/etc/shadow (不是passwd文件，因为密码实际上经过加密后放在了“影子口令”文件shadow中了。passwd文件每个用户均可见，但是shadow只有root可以见)。 找到普通用户名cicikasa，然后删除第二个域即可，域之间用“:”隔开的，如下：cicikasa:TdkakkkYUukkjkjk:14672:0:99999:7:::上述红色部分就是经过加密的密码，删除即可 在普通用户下，输入passwd即可输入新密码 如果想修改VMware的bios在VMWare中将BIOS设成光驱启动:启动时(点击启动虚拟机按钮),按F2 ,进入BIOS 设置,找到 BOOT—把CDROM光驱，移动到最上面即可。根据提示进行设置，一般按“-”号进行设置。注意：启动时，点了启动虚拟机按钮后一定要在点一下窗口（或者Ctrl +G），然后快按F2。否则，窗口没激活，F2是不起作用的.]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>密码找回</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo下NexT主题添加Gitment评论插件]]></title>
    <url>%2F2018%2F06%2F20%2FHexo%E4%B8%8BNexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Gitment%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最终效果图大概是这个样子： Gitment 是作者imsun实现的一款基于 GitHub Issues 的评论系统。 支持在前端直接引入， 不需要任何后端代码。 可以在页面进行登录， 查看，评论，点赞等操作。 同时有完整的 Markdown / GFM 和代码高亮支持。 尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 这篇文章仅介绍如果在 hexo-NexT 中添加 Gitment 评论插件，并且增加一个点开显示评论的按钮，对于 Gitment 的使用请参考 imsun 的博客。 另外，本教程的按钮样式和代码均直接取自 ehlxr 博主。 注册OAuth Application因为 Gitment 评论插件是基于Github Issues评论系统，这类评论系统都需要一个OAuth Application，所以咱们没有注册OAuth Application的同学先注册一个。博客咱们已经有啦，例如我的：DaiHuiBlog.github.io。没有的同学以自己GitHub用户新建一个仓库就行：你的用户名.github.io接下来创建 OAuth Application，没有的同学可以新建一个。 其中 Application name 为仓库名，例：DaiHuiBlog.github.io Homepage URL 填你的博客网址，例：blog.daihui888.com Application description 描述，随便写 Authorization callback URL 填你的博客网址，例：blog.daihui888.com 完成后会生成相应的 clientID 和 clientSecret。 接下来开始配置Gitment “显示 Gitment 评论” 的按钮样式在 next/source/css/_common/components 目录中新建一个 gitment.styl 的 css 样式文件, 复制以下代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.gitment_title:hover &#123; color: #fff; background: #0a9caf; background-image: initial; background-position-x: initial; background-position-y: initial; background-size: initial; background-repeat-x: initial; background-repeat-y: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: rgb(10, 156, 175);&#125;.gitment_title &#123; border: 1px solid #0a9caf; border-top-color: rgb(10, 156, 175); border-top-style: solid; border-top-width: 1px; border-right-color: rgb(10, 156, 175); border-right-style: solid; border-right-width: 1px; border-bottom-color: rgb(10, 156, 175); border-bottom-style: solid; border-bottom-width: 1px; border-left-color: rgb(10, 156, 175); border-left-style: solid; border-left-width: 1px; border-image-source: initial; border-image-slice: initial; border-image-width: initial; border-image-outset: initial; border-image-repeat: initial; border-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px;&#125;.gitment_title &#123; display: inline-block; padding: 0 15px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; color: #0a9caf; cursor: pointer; font-size: 14px;&#125; 然后打开同目录中的 components.styl 文件, 找个顺眼的位置添加一句 1@import &quot;gitment&quot; 添加 Gitment 插件打开 /next/layout/_partials/comments.swig 文件, 在最后一个 elseif 代码块下面添加 Gitment 的内容. 1234567891011121314151617181920212223242526272829303132333435363738// 前面的略... ...&#123;% elseif theme.changyan.appid and theme.changyan.appkey %&#125; &lt;div id="SOHUCS"&gt;&lt;/div&gt;&#123;% elseif theme.gitment.enable %&#125; &lt;div onclick="showGitment()" id="gitment_title" class="gitment_title"&gt;显示 Gitment 评论&lt;/div&gt; &lt;div id="container" style="display:none"&gt;&lt;/div&gt; &lt;link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"&gt; &lt;script src="https://imsun.github.io/gitment/dist/gitment.browser.js"&gt;&lt;/script&gt; &lt;script&gt; const myTheme = &#123; render(state, instance) &#123; const container = document.createElement('div'); container.lang = "en-US"; container.className = 'gitment-container gitment-root-container'; container.appendChild(instance.renderHeader(state, instance)); container.appendChild(instance.renderEditor(state, instance)); container.appendChild(instance.renderComments(state, instance)); container.appendChild(instance.renderFooter(state, instance)); return container; &#125; &#125; function showGitment() &#123; $("#gitment_title").attr("style", "display:none"); $("#container").attr("style", "").addClass("gitment_container"); var gitment = new Gitment(&#123; id: decodeURI(window.location.pathname), theme: myTheme, owner: '&#123;&#123; theme.gitment.owner &#125;&#125;', repo: '&#123;&#123; theme.gitment.repo &#125;&#125;', oauth: &#123; client_id: '&#123;&#123; theme.gitment.client_id &#125;&#125;', client_secret: '&#123;&#123; theme.gitment.client_secret &#125;&#125;' &#125; &#125;); gitment.render('container'); &#125; &lt;/script&gt;&#123;% endif %&#125; 然后打开 NexT 主题的_config.yml 文件，在评论相关设置的区域添加下面的代码，并根据 Gitment 文档说明来添加相应的值 12345678# Gitment commentsgitment: enable: true owner: xxx repo: xxx client_id: xxx client_secret: xxx lazy: true #lazy属性为是否直接显示评论模块，true会显示”显示评论”按钮，false会直接显示 另外，Gitment需要自己手动初始化一下来创建一个issues，不喜欢他的同学可以用Gitalk]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Gitment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置mac自带的vim语法高亮]]></title>
    <url>%2F2018%2F06%2F15%2F%E8%AE%BE%E7%BD%AEmac%E8%87%AA%E5%B8%A6%E7%9A%84vim%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[最终效果图大概是这个样子： 设置vimrcvimrc文件是vim的环境设置文件。整体的vim的设置是在 /etc/vimrc 文件中。不建议修改/etc/vimrc 文件，每个用户可以在用户根目录中设置vim，新建 ~/.vimrc touch .vimrc 在.vimrc中添加以下内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285"=========================================================================" DesCRiption: 适合自己使用的vimrc文件，for Mac/Linux/Windows, GUI/Console"" Last Change: 2017年09月11日 "" Version: 1.80""=========================================================================set nocompatible " 关闭 vi 兼容模式syntax on " 自动语法高亮colorscheme molokai " 设定配色方案set number " 显示行号set cursorline " 突出显示当前行set ruler " 打开状态栏标尺set shiftwidth=4 " 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4set softtabstop=4 " 使得按退格键时可以一次删掉 4 个空格set tabstop=4 " 设定 tab 长度为 4set nobackup " 覆盖文件时不备份set autochdir " 自动切换当前目录为当前文件所在的目录filetype plugin indent on " 开启插件set backupcopy=yes " 设置备份时的行为为覆盖set ignorecase smartcase " 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感set nowrapscan " 禁止在搜索到文件两端时重新搜索set incsearch " 输入搜索内容时就显示搜索结果set hlsearch " 搜索时高亮显示被找到的文本set noerrorbells " 关闭错误信息响铃set novisualbell " 关闭使用可视响铃代替呼叫set t_vb= " 置空错误铃声的终端代码" set showmatch " 插入括号时，短暂地跳转到匹配的对应括号" set matchtime=2 " 短暂跳转到匹配括号的时间set magic " 设置魔术set hidden " 允许在有未保存的修改时切换缓冲区，此时的修改由 vim 负责保存set guioptions-=T " 隐藏工具栏set guioptions-=m " 隐藏菜单栏set smartindent " 开启新行时使用智能自动缩进set backspace=indent,eol,start" 不设定在插入状态无法用退格键和 Delete 键删除回车符set cmdheight=1 " 设定命令行的行数为 1set laststatus=2 " 显示状态栏 (默认值为 1, 无法显示状态栏)set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\" 设置在状态行显示的信息set foldenable " 开始折叠set foldmethod=syntax " 设置语法折叠set foldcolumn=0 " 设置折叠区域的宽度setlocal foldlevel=1 " 设置折叠层数为" set foldclose=all " 设置为自动关闭折叠" nnoremap &lt;space&gt; @=((foldclosed(line('.')) &lt; 0) ? 'zc' : 'zo')&lt;CR&gt;" 用空格键来开关折叠" return OS type, eg: windows, or linux, mac, et.st..function! MySys()if has("win16") || has("win32") || has("win64") || has("win95")return "windows"elseif has("unix")return "linux"endifendfunction" 用户目录变量$VIMFILESif MySys() == "windows"let $VIMFILES = $VIM.'/vimfiles'elseif MySys() == "linux"let $VIMFILES = $HOME.'/.vim'endif" 设定doc文档目录let helptags=$VIMFILES.'/doc'" 设置字体 以及中文支持if has("win32")set guifont=Inconsolata:h12:cANSIendif" 配置多语言环境if has("multi_byte")" UTF-8 编码set encoding=utf-8set termencoding=utf-8set formatoptions+=mMset fencs=utf-8,gbkif v:lang =~? '^\(zh\)\|\(ja\)\|\(ko\)'set ambiwidth=doubleendifif has("win32")source $VIMRUNTIME/delmenu.vimsource $VIMRUNTIME/menu.vimlanguage messages zh_CN.utf-8endifelseechoerr "Sorry, this version of (g)vim was not compiled with +multi_byte"endif" Buffers操作快捷方式!nnoremap &lt;C-RETURN&gt; :bnext&lt;CR&gt;nnoremap &lt;C-S-RETURN&gt; :bprevious&lt;CR&gt;" Tab操作快捷方式!nnoremap &lt;C-TAB&gt; :tabnext&lt;CR&gt;nnoremap &lt;C-S-TAB&gt; :tabprev&lt;CR&gt;"关于tab的快捷键" map tn :tabnext&lt;cr&gt;" map tp :tabprevious&lt;cr&gt;" map td :tabnew .&lt;cr&gt;" map te :tabedit" map tc :tabclose&lt;cr&gt;"窗口分割时,进行切换的按键热键需要连接两次,比如从下方窗口移动"光标到上方窗口,需要&lt;c-w&gt;&lt;c-w&gt;k,非常麻烦,现在重映射为&lt;c-k&gt;,切换的"时候会变得非常方便.nnoremap &lt;C-h&gt; &lt;C-w&gt;hnnoremap &lt;C-j&gt; &lt;C-w&gt;jnnoremap &lt;C-k&gt; &lt;C-w&gt;knnoremap &lt;C-l&gt; &lt;C-w&gt;l"一些不错的映射转换语法（如果在一个文件中混合了不同语言时有用）nnoremap &lt;leader&gt;1 :set filetype=xhtml&lt;CR&gt;nnoremap &lt;leader&gt;2 :set filetype=css&lt;CR&gt;nnoremap &lt;leader&gt;3 :set filetype=javascript&lt;CR&gt;nnoremap &lt;leader&gt;4 :set filetype=php&lt;CR&gt;" set fileformats=unix,dos,mac" nmap &lt;leader&gt;fd :se fileformat=dos&lt;CR&gt;" nmap &lt;leader&gt;fu :se fileformat=unix&lt;CR&gt;" use Ctrl+[l|n|p|cc] to list|next|previous|jump to count the result" map &lt;C-x&gt;l &lt;ESC&gt;:cl&lt;CR&gt;" map &lt;C-x&gt;n &lt;ESC&gt;:cn&lt;CR&gt;" map &lt;C-x&gt;p &lt;ESC&gt;:cp&lt;CR&gt;" map &lt;C-x&gt;c &lt;ESC&gt;:cc&lt;CR&gt;" 让 Tohtml 产生有 CSS 语法的 html" syntax/2html.vim，可以用:runtime! syntax/2html.vimlet html_use_css=1" Python 文件的一般设置，比如不要 tab 等autocmd FileType python set tabstop=4 shiftwidth=4 expandtabautocmd FileType python map &lt;F12&gt; :!python %&lt;CR&gt;" 选中状态下 Ctrl+c 复制vmap &lt;C-c&gt; "+y" 打开javascript折叠let b:javascript_fold=1" 打开javascript对dom、html和css的支持let javascript_enable_domhtmlcss=1" 设置字典 ~/.vim/dict/文件的路径autocmd filetype javascript set dictionary=$VIMFILES/dict/javascript.dictautocmd filetype css set dictionary=$VIMFILES/dict/css.dictautocmd filetype php set dictionary=$VIMFILES/dict/php.dict"-----------------------------------------------------------------" plugin - bufexplorer.vim Buffers切换" \be 全屏方式查看全部打开的文件列表" \bv 左右方式查看 \bs 上下方式查看"-----------------------------------------------------------------"-----------------------------------------------------------------" plugin - taglist.vim 查看函数列表，需要ctags程序" F4 打开隐藏taglist窗口"-----------------------------------------------------------------if MySys() == "windows" " 设定windows系统中ctags程序的位置let Tlist_Ctags_Cmd = '"'.$VIMRUNTIME.'/ctags.exe"'elseif MySys() == "linux" " 设定windows系统中ctags程序的位置let Tlist_Ctags_Cmd = '/usr/bin/ctags'endifnnoremap &lt;silent&gt;&lt;F4&gt; :TlistToggle&lt;CR&gt;let Tlist_Show_One_File = 1 " 不同时显示多个文件的tag，只显示当前文件的let Tlist_Exit_OnlyWindow = 1 " 如果taglist窗口是最后一个窗口，则退出vimlet Tlist_Use_Right_Window = 1 " 在右侧窗口中显示taglist窗口let Tlist_File_Fold_Auto_Close=1 " 自动折叠当前非编辑文件的方法列表let Tlist_Auto_Open = 0let Tlist_Auto_Update = 1let Tlist_Hightlight_Tag_On_BufEnter = 1let Tlist_Enable_Fold_Column = 0let Tlist_Process_File_Always = 1let Tlist_Display_Prototype = 0let Tlist_Compact_Format = 1"-----------------------------------------------------------------" plugin - mark.vim 给各种tags标记不同的颜色，便于观看调式的插件。" \m mark or unmark the word under (or before) the cursor" \r manually input a regular expression. 用于搜索." \n clear this mark (i.e. the mark under the cursor), or clear all highlighted marks ." \* 当前MarkWord的下一个 \# 当前MarkWord的上一个" \/ 所有MarkWords的下一个 \? 所有MarkWords的上一个"-----------------------------------------------------------------"-----------------------------------------------------------------" plugin - NERD_tree.vim 以树状方式浏览系统中的文件和目录" :ERDtree 打开NERD_tree :NERDtreeClose 关闭NERD_tree" o 打开关闭文件或者目录 t 在标签页中打开" T 在后台标签页中打开 ! 执行此文件" p 到上层目录 P 到根目录" K 到第一个节点 J 到最后一个节点" u 打开上层目录 m 显示文件系统菜单（添加、删除、移动操作）" r 递归刷新当前目录 R 递归刷新当前根目录"-----------------------------------------------------------------" F3 NERDTree 切换map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;imap &lt;F3&gt; &lt;ESC&gt;:NERDTreeToggle&lt;CR&gt;"-----------------------------------------------------------------" plugin - NERD_commenter.vim 注释代码用的，" [count],cc 光标以下count行逐行添加注释(7,cc)" [count],cu 光标以下count行逐行取消注释(7,cu)" [count],cm 光标以下count行尝试添加块注释(7,cm)" ,cA 在行尾插入 ,并且进入插入模式。 这个命令方便写注释。" 注：count参数可选，无则默认为选中行或当前行"-----------------------------------------------------------------let NERDSpaceDelims=1 " 让注释符与语句之间留一个空格let NERDCompactSexyComs=1 " 多行注释时样子更好看"-----------------------------------------------------------------" plugin - DoxygenToolkit.vim 由注释生成文档，并且能够快速生成函数标准注释"-----------------------------------------------------------------let g:DoxygenToolkit_authorName="Asins - asinsimple AT gmail DOT com"let g:DoxygenToolkit_briefTag_funcName="yes"map &lt;leader&gt;da :DoxAuthor&lt;CR&gt;map &lt;leader&gt;df :Dox&lt;CR&gt;map &lt;leader&gt;db :DoxBlock&lt;CR&gt;map &lt;leader&gt;dc a &lt;LEFT&gt;&lt;LEFT&gt;&lt;LEFT&gt;"-----------------------------------------------------------------" plugin – ZenCoding.vim 很酷的插件，HTML代码生成" 插件最新版：http://github.com/mattn/zencoding-vim" 常用命令可看：http://nootn.com/blog/Tool/23/"-----------------------------------------------------------------"-----------------------------------------------------------------" plugin – checksyntax.vim JavaScript常见语法错误检查" 默认快捷方式为 F5"-----------------------------------------------------------------let g:checksyntax_auto = 0 " 不自动检查"-----------------------------------------------------------------" plugin - NeoComplCache.vim 自动补全插件"-----------------------------------------------------------------let g:AutoComplPop_NotEnableAtStartup = 1let g:NeoComplCache_EnableAtStartup = 1let g:NeoComplCache_SmartCase = 1let g:NeoComplCache_TagsAutoUpdate = 1let g:NeoComplCache_EnableInfo = 1let g:NeoComplCache_EnableCamelCaseCompletion = 1let g:NeoComplCache_MinSyntaxLength = 3let g:NeoComplCache_EnableSkipCompletion = 1let g:NeoComplCache_SkipInputTime = '0.5'let g:NeoComplCache_SnippetsDir = $VIMFILES.'/snippets'" &lt;TAB&gt; completion.inoremap &lt;expr&gt;&lt;TAB&gt; pumvisible() ? "\&lt;C-n&gt;" : "\&lt;TAB&gt;"" snippets expand keyimap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)smap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)"-----------------------------------------------------------------" plugin - matchit.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转" % 正向匹配 g% 反向匹配" [% 定位块首 ]% 定位块尾"-----------------------------------------------------------------"-----------------------------------------------------------------" plugin - vcscommand.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转" SVN/git管理工具"-----------------------------------------------------------------"-----------------------------------------------------------------" plugin – a.vim"----------------------------------------------------------------- 设置颜色主题进入对应目录准备颜色文件，没有就创建对应目录和文件 1234567daihui@daihuideMBP ~ cd .vim/colorsdaihui@daihuideMBP ~/.vim/colors pwd/Users/daihui/.vim/colors# 在~/.vim/colors目录下新建一个颜色文件daihui@daihuideMBP ~/.vim/colors touch molokai.vim molokai.vim 文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212" Vim color file"" Author: Tomas Restrepo &lt;tomas@winterdom.com&gt;"" Note: Based on the monokai theme for textmate" by Wimer Hazenberg and its darker variant" by Hamish Stuart Macpherson"hi clearset background=darkif version &gt; 580 " no guarantees for version 5.8 and below, but this makes it stop " complaining hi clear if exists("syntax_on") syntax reset endifendiflet g:colors_name="molokai"if exists("g:molokai_original") let s:molokai_original = g:molokai_originalelse let s:molokai_original = 0endifhi Boolean guifg=#AE81FFhi Character guifg=#E6DB74hi Number guifg=#AE81FFhi String guifg=#E6DB74hi Conditional guifg=#F92672 gui=boldhi Constant guifg=#AE81FF gui=boldhi Cursor guifg=#000000 guibg=#F8F8F0hi Debug guifg=#BCA3A3 gui=boldhi Define guifg=#66D9EFhi Delimiter guifg=#8F8F8Fhi DiffAdd guibg=#13354Ahi DiffChange guifg=#89807D guibg=#4C4745hi DiffDelete guifg=#960050 guibg=#1E0010hi DiffText guibg=#4C4745 gui=italic,boldhi Directory guifg=#A6E22E gui=boldhi Error guifg=#960050 guibg=#1E0010hi ErrorMsg guifg=#F92672 guibg=#232526 gui=boldhi Exception guifg=#A6E22E gui=boldhi Float guifg=#AE81FFhi FoldColumn guifg=#465457 guibg=#000000hi Folded guifg=#465457 guibg=#000000hi Function guifg=#A6E22Ehi Identifier guifg=#FD971Fhi Ignore guifg=#808080 guibg=bghi IncSearch guifg=#C4BE89 guibg=#000000hi Keyword guifg=#F92672 gui=boldhi Label guifg=#E6DB74 gui=nonehi Macro guifg=#C4BE89 gui=italichi SpecialKey guifg=#66D9EF gui=italichi MatchParen guifg=#000000 guibg=#FD971F gui=boldhi ModeMsg guifg=#E6DB74hi MoreMsg guifg=#E6DB74hi Operator guifg=#F92672" complete menuhi Pmenu guifg=#66D9EF guibg=#000000hi PmenuSel guibg=#808080hi PmenuSbar guibg=#080808hi PmenuThumb guifg=#66D9EFhi PreCondit guifg=#A6E22E gui=boldhi PreProc guifg=#A6E22Ehi Question guifg=#66D9EFhi Repeat guifg=#F92672 gui=boldhi Search guifg=#FFFFFF guibg=#455354" marks columnhi SignColumn guifg=#A6E22E guibg=#232526hi SpecialChar guifg=#F92672 gui=boldhi SpecialComment guifg=#465457 gui=boldhi Special guifg=#66D9EF guibg=bg gui=italichi SpecialKey guifg=#888A85 gui=italicif has("spell") hi SpellBad guisp=#FF0000 gui=undercurl hi SpellCap guisp=#7070F0 gui=undercurl hi SpellLocal guisp=#70F0F0 gui=undercurl hi SpellRare guisp=#FFFFFF gui=undercurlendifhi Statement guifg=#F92672 gui=boldhi StatusLine guifg=#455354 guibg=fghi StatusLineNC guifg=#808080 guibg=#080808hi StorageClass guifg=#FD971F gui=italichi Structure guifg=#66D9EFhi Tag guifg=#F92672 gui=italichi Title guifg=#ef5939hi Todo guifg=#FFFFFF guibg=bg gui=boldhi Typedef guifg=#66D9EFhi Type guifg=#66D9EF gui=nonehi Underlined guifg=#808080 gui=underlinehi VertSplit guifg=#808080 guibg=#080808 gui=boldhi VisualNOS guibg=#403D3Dhi Visual guibg=#403D3Dhi WarningMsg guifg=#FFFFFF guibg=#333333 gui=boldhi WildMenu guifg=#66D9EF guibg=#000000if s:molokai_original == 1 hi Normal guifg=#F8F8F2 guibg=#272822 hi Comment guifg=#75715E hi CursorLine guibg=#3E3D32 hi CursorColumn guibg=#3E3D32 hi LineNr guifg=#BCBCBC guibg=#3B3A32 hi NonText guifg=#BCBCBC guibg=#3B3A32else hi Normal guifg=#F8F8F2 guibg=#1B1D1E hi Comment guifg=#465457 hi CursorLine guibg=#293739 hi CursorColumn guibg=#293739 hi LineNr guifg=#BCBCBC guibg=#232526 hi NonText guifg=#BCBCBC guibg=#232526end"" Support for 256-color terminal"if &amp;t_Co &gt; 255 hi Boolean ctermfg=135 hi Character ctermfg=144 hi Number ctermfg=135 hi String ctermfg=144 hi Conditional ctermfg=161 cterm=bold hi Constant ctermfg=135 cterm=bold hi Cursor ctermfg=16 ctermbg=253 hi Debug ctermfg=225 cterm=bold hi Define ctermfg=81 hi Delimiter ctermfg=241 hi DiffAdd ctermbg=24 hi DiffChange ctermfg=181 ctermbg=239 hi DiffDelete ctermfg=162 ctermbg=53 hi DiffText ctermbg=102 cterm=bold hi Directory ctermfg=118 cterm=bold hi Error ctermfg=219 ctermbg=89 hi ErrorMsg ctermfg=199 ctermbg=16 cterm=bold hi Exception ctermfg=118 cterm=bold hi Float ctermfg=135 hi FoldColumn ctermfg=67 ctermbg=16 hi Folded ctermfg=67 ctermbg=16 hi Function ctermfg=118 hi Identifier ctermfg=208 hi Ignore ctermfg=244 ctermbg=232 hi IncSearch ctermfg=193 ctermbg=16 hi Keyword ctermfg=161 cterm=bold hi Label ctermfg=229 cterm=none hi Macro ctermfg=193 hi SpecialKey ctermfg=81 hi MatchParen ctermfg=16 ctermbg=208 cterm=bold hi ModeMsg ctermfg=229 hi MoreMsg ctermfg=229 hi Operator ctermfg=161 " complete menu hi Pmenu ctermfg=81 ctermbg=16 hi PmenuSel ctermbg=244 hi PmenuSbar ctermbg=232 hi PmenuThumb ctermfg=81 hi PreCondit ctermfg=118 cterm=bold hi PreProc ctermfg=118 hi Question ctermfg=81 hi Repeat ctermfg=161 cterm=bold hi Search ctermfg=253 ctermbg=66 " marks column hi SignColumn ctermfg=118 ctermbg=235 hi SpecialChar ctermfg=161 cterm=bold hi SpecialComment ctermfg=245 cterm=bold hi Special ctermfg=81 ctermbg=232 hi SpecialKey ctermfg=245 hi Statement ctermfg=161 cterm=bold hi StatusLine ctermfg=238 ctermbg=253 hi StatusLineNC ctermfg=244 ctermbg=232 hi StorageClass ctermfg=208 hi Structure ctermfg=81 hi Tag ctermfg=161 hi Title ctermfg=166 hi Todo ctermfg=231 ctermbg=232 cterm=bold hi Typedef ctermfg=81 hi Type ctermfg=81 cterm=none hi Underlined ctermfg=244 cterm=underline hi VertSplit ctermfg=244 ctermbg=232 cterm=bold hi VisualNOS ctermbg=238 hi Visual ctermbg=235 hi WarningMsg ctermfg=231 ctermbg=238 cterm=bold hi WildMenu ctermfg=81 ctermbg=16 hi Normal ctermfg=252 ctermbg=233 hi Comment ctermfg=59 hi CursorLine ctermbg=234 cterm=none hi CursorColumn ctermbg=234 hi LineNr ctermfg=250 ctermbg=234 hi NonText ctermfg=250 ctermbg=234end 重启vim再进来看看原文]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下删除launchpad还有残留图标的应用]]></title>
    <url>%2F2018%2F05%2F16%2FMac%E4%B8%8B%E5%88%A0%E9%99%A4launchpad%E8%BF%98%E6%9C%89%E6%AE%8B%E7%95%99%E5%9B%BE%E6%A0%87%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[有时候用户在删除自己应用的时候在应用程序里直接右键“移到废纸楼”，有的应用这样删除后在launchpad里还有残留的图标，按住option键也没有删除标记可以删除该图标。这让人很蛋疼，但是可以通过下面这个小技巧将该图标删除，方法如下： 打开launchpad下列三个放都可以打开launchpad fn + F4（F1-F12是正常使用情况） F4（F1-F12使用需要借助fn键使用） 四个指头抓一下 具体操作1. 长按control+option+command，看到图标抖动2. 单击待删除图标，图标中心出现白色问号3. 松开按住的三个快捷键（control+option+command）4. 再次按下这三个快捷键，图标左上角会出现“✘”，点击删除]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac删除</tag>
        <tag>launchpad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git简明指南]]></title>
    <url>%2F2018%2F04%2F24%2FGit%E7%AE%80%E6%98%8E%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[安装下载 git OSX 版下载 git Windows 版下载 git Linux 版创建新仓库创建新文件夹，打开，然后执行1git init 以创建新的 git 仓库。 检出仓库执行如下命令以创建一个本地仓库的克隆版本：1git clone /path/to/repository 如果是远端服务器上的仓库，你的命令会是这个样子：1git clone username@host:/path/to/repository 工作流你的本地仓库由 git 维护的三棵“树”组成。第一个是你的工作目录，它持有实际文件；第二个是暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。 添加和提交你可以提出更改（把它们添加到暂存区），使用如下命令：12git add &lt;filename&gt;git add * 这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：1git commit -m &quot;代码提交信息&quot; 现在，你的改动已经提交到了HEAD，但是还没到你的远端仓库。 推送改动你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：1git push origin master 可以把 master 换成你想要推送的任何分支。 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：1git remote add origin &lt;server&gt; 如此你就能够将你的改动推送到所添加的服务器上去了。 分支分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。 创建一个叫做“feature_x”的分支，并切换过去：1git checkout -b feature_x 切换回主分支：1git checkout master 再把新建的分支删掉：1git branch -d feature_x 除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：1git push origin &lt;branch&gt; 更新与合并要更新你的本地仓库至最新改动，执行：1git pull 以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。要合并其他分支到你的当前分支（例如 master），执行：1git merge &lt;branch&gt; 在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。这时候就需要你修改这些文件来手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功：1git add &lt;filename&gt; 在合并改动之前，你可以使用如下命令预览差异：1git diff &lt;source_branch&gt; &lt;target_branch&gt; 标签为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 1.0.0 的标签：1git tag 1.0.0 1b2e1d63ff 1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID：1git log 你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。 log如果你想了解本地仓库的历史记录，最简单的命令就是使用:1git log 你可以添加一些参数来修改他的输出，从而得到自己想要的结果。 只看某一个人的提交记录:1git log --author=bob 一个压缩后的每一条提交记录只占一行的输出:1git log --pretty=oneline 或者你想通过ASCII艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签:1git log --graph --oneline --decorate --all 看看哪些文件改变了:1git log --name-status 这些只是你可以使用的参数中很小的一部分。更多的信息，参考：1git log --help 替换本地改动假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：1git checkout -- &lt;filename&gt; 此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。 假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：12git fetch origingit reset --hard origin/master 实用小贴士内建的图形化 git：1gitk 彩色的 git 输出：1git config color.ui true 显示历史记录时，每个提交的信息只显示一行：1git config format.pretty oneline 交互式添加文件到暂存区：1git add -i 链接与资源图形化客户端GitX (L) (OSX, 开源软件)Tower (OSX)Source Tree (OSX, 免费)GitHub for Mac (OSX, 免费)GitBox (OSX, App Store) 指南和手册Git 社区参考书专业 Git像 git 那样思考GitHub 帮助图解 Git git命令大全：]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios基本使用说明]]></title>
    <url>%2F2018%2F04%2F11%2FAxios%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[Axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 特点 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 浏览器支持 Latest ✔ Latest ✔ Latest ✔ Latest ✔ Latest ✔ 8+ ✔ 安装使用 npm: 1$ npm install axios 使用 bower: 1$ bower install axios 使用 cdn: 1&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; 示例执行 GET 请求 12345678910111213141516171819202122232425262728293031// 为给定 ID 的 user 创建请求axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 可选地，上面的请求可以这样做axios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 想使用异步/等待？将`async`关键字添加到外部函数/方法中。async function getUser() &#123; try &#123; const response = await axios.get('/user?ID=12345'); console.log(response); &#125; catch (error) &#123; console.error(error); &#125;&#125; 注意: async/await是ECMAScript 2017的一部分，在Internet Explorer和旧版浏览器中不支持，因此请谨慎使用。 执行 POST 请求 12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行多个并发请求 123456789101112function getUserAccount() &#123; return axios.get('/user/12345');&#125;function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; //两个请求均已完成 &#125;)); axios API请求可以通过传递相关配置来完成 axios. axios(config) 123456789// 发送一个POST请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;); 123456789// GET请求远程图像axios(&#123; method:'get', url:'http://bit.ly/2mTM3nY', responseType:'stream'&#125;) .then(function(response) &#123; response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))&#125;); axios(url[, config]) 12// 发送GET请求（默认方法）axios('/user/12345'); 请求方法别名为方便起见，为所有支持的请求方法提供了别名 axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.options(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]]) 注意: 在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 并发处理并发请求的助手函数 axios.all(iterable)axios.spread(callback) 创建一个实例您可以使用自定义配置创建一个新的axios实例。 axios.create([config]) 12345const instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-Custom-Header': 'foobar'&#125;&#125;); 实例方法以下是可用的实例方法。指定的配置将与实例的配置合并 axios#request(config)axios#get(url[, config])axios#delete(url[, config])axios#head(url[, config])axios#options(url[, config])axios#post(url[, data[, config]])axios#put(url[, data[, config]])axios#patch(url[, data[, config]]) 请求配置这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&#123; // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // 默认 // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream // 您可以修改headers对象。 transformRequest: [function (data, headers) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个普通对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (例如： https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属： FormData, File, Blob // - Node专属: Stream, Buffer data: &#123; firstName: 'Fred' &#125;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 adapter: function (config) &#123; /* ... */ &#125;, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: 'janedoe', password: 's00pers3cret' &#125;, // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // 默认 // `responseEncoding` 表示用于解码响应的编码 // 注意：忽略'stream'或客户端请求的`responseType` responseEncoding: 'utf8', // 默认 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // 默认 // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // 默认 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。 // 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)， // promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认 &#125;, // `maxRedirects` 定义在 node.js 中遵循的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // default // `socketPath` 定义了一个在Socket.js中使用的UNIX套接字。 // 例如'/var/run/docker.sock'发送请求到docker守护进程。 // 只能指定`socketPath`或`proxy`。 // 如果两者都指定，则使用`socketPath`。 socketPath: null, // 默认 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 'proxy' 定义代理服务器的主机名称和端口 // 使用'false'来禁用代理，忽略环境变量。 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: '127.0.0.1', port: 9000, auth: &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 响应结构某个请求的响应包含以下信息 123456789101112131415161718192021&#123; // `data` 由服务器提供的响应 data: &#123;&#125;, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: 'OK', // `headers` t服务器响应的头 // 所有的 header 都是小写 headers: &#123;&#125;, // `config` 是为请求提供给`axios`的配置 config: &#123;&#125;, // `request` 是生成此响应的请求 // 它是node.js中的最后一个ClientRequest实例和浏览器请求的XMLHttpRequest实例 request: &#123;&#125;&#125; 使用 then 时，你将接收下面这样的响应： 12345678axios.get('/user/12345') .then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); &#125;); 在使用 catch 时，或传递rejection callback 作为 then 的第二个参数时, 响应可以通过 error 对象可被使用，正如在错误处理 这一节所讲. 配置的默认值/defaults你可以指定将被用在各个请求的配置默认值 全局axios默认值123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 自定义实例默认值1234567// 创建实例时设置配置的默认值const instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);// 在实例已创建后修改默认值instance.defaults.headers.common['Authorization'] = AUTH_TOKEN; 配置的优先顺序配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子： 123456789101112// 使用由库提供的配置的默认值来创建实例// 此时超时配置的默认值是 `0`const instance = axios.create();// 覆写库的超时默认值// 现在，在超时前，所有请求都会等待 2.5 秒instance.defaults.timeout = 2500;// 为已知需要花费很长时间的请求覆写超时设置instance.get('/longRequest', &#123; timeout: 5000&#125;); 拦截器在请求或响应被 then 或 catch 处理前拦截它们。 1234567891011121314151617// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); 如果你想在稍后移除拦截器，可以这样： 12const myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器 12const instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 错误处理1234567891011121314151617axios.get('/user/12345') .catch(function (error) &#123; if (error.response) &#123; // 请求已发出，但服务器响应的状态码不在 2xx 范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); &#125; else if (error.request) &#123; // 请求被提出，但没有接收到响应 // `error.request`是在浏览器中一个XMLHttpRequest的实例和node.js中http.ClientRequest的实例 console.log(error.request); &#125; else &#123; // 设置触发错误 console.log('Error', error.message); &#125; console.log(error.config); &#125;); 您可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。 12345axios.get('/user/12345', &#123; validateStatus: function (status) &#123; return status &lt; 500; // 仅当状态码大于或等于500时才拒绝 &#125;&#125;) 取消使用 cancel token 取消请求 Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。 可以使用 CancelToken.source 工厂创建取消令牌，如下所示： 123456789101112131415161718192021const CancelToken = axios.CancelToken;const source = CancelToken.source();axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;);axios.post('/user/12345', &#123; name: 'new name'&#125;, &#123; cancelToken: source.token&#125;)// 取消请求（消息参数是可选的）source.cancel('Operation canceled by the user.'); 还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token： 123456789101112const CancelToken = axios.CancelToken;let cancel;axios.get('/user/12345', &#123; cancelToken: new CancelToken(function executor(c) &#123; // executor 函数接收一个 cancel 函数作为参数 cancel = c; &#125;)&#125;);// 取消请求cancel(); 注意: 可以使用同一个 cancel token 取消多个请求 使用 application/x-www-form-urlencoded 格式默认情况下，axios将JavaScript对象序列化为JSON。要以application/x-www-form-urlencoded 格式发送数据，您可以使用以下选项之一。 浏览器在浏览器中，您可以使用以下URLSearchParams API: 1234const params = new URLSearchParams();params.append('param1', 'value1');params.append('param2', 'value2');axios.post('/foo', params); 请注意， URLSearchParams 并非所有浏览器都支持(请参阅 caniuse.com), 但可以使用 polyfill(请确保填充全局环境)。或者，您可以使用qs 库对数据进行编码： 12const qs = require('qs');axios.post('/foo', qs.stringify(&#123; 'bar': 123 &#125;)); 或者以另一种方式（ES6）， 123456789import qs from 'qs';const data = &#123; 'bar': 123 &#125;;const options = &#123; method: 'POST', headers: &#123; 'content-type': 'application/x-www-form-urlencoded' &#125;, data: qs.stringify(data), url,&#125;;axios(options); Node.js在node.js中，您可以querystring按如下方式使用模块： 12const querystring = require('querystring');axios.post('http://something.com/', querystring.stringify(&#123; foo: 'bar' &#125;)); 您也可以使用该qs库. Semver在axios达到1.0 发布之前，将通过新的次要版本发布重大更改。例如 0.5.1, 和 0.5.4将具有相同的API, 但 0.6.0 会有重大更改。 承诺aaxios依赖于原生ES6 Promise实现的支持。如果您的环境不支持ES6 Promise，则可以polyfill。 TypeScriptaxios包括TypeScript定义。12import axios from 'axios';axios.get('/user?ID=12345'); 资源 更新日志 升级指南 生态系统 C参与指南 行为守则]]></content>
      <categories>
        <category>翻译</category>
        <category>README</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTerm 2和Oh My Zsh代替自带terminal教程简单整理]]></title>
    <url>%2F2018%2F04%2F02%2FiTerm-2%E5%92%8COh-My-Zsh%E4%BB%A3%E6%9B%BF%E8%87%AA%E5%B8%A6terminal%E6%95%99%E7%A8%8B%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[最终效果图大概是这个样子： 但是如果你有用到Atom编辑器的控制台插件的话可能会由于字体原因特殊的符号显示不了，就像我这样： 1. 首先下载iterm22. 打开iTerm 23. 输入下面指令安装oh-my-zsh curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh 4. 接下来安装Powerline在官网有教程，我们只需要执行官网第一条安装指令就行 如果你的终端能够正常执行pip指令，那么直接执行下面的指令可以完成安装 pip install powerline-status 如果没有，则先执行安装pip指令 sudo easy_install pip 5. 下载、安装库字体库1）将工程下载下来后cd到install.sh文件所在目录 2）执行指令安装字体库 执行./install.sh指令安装所有Powerline字体 安装完成后提示所有字体均已下载到/Users/superdanny/Library/Fonts路径下 All Powerline fonts installed to /Users/superdanny/Library/Fonts 6. 设置iTerm 2的Regular Font 和 Non-ASCII Font安装完字体库之后，把iTerm 2的设置里的Profile中的Text 选项卡中里的Regular Font和Non-ASCII Font的字体都设置成 Powerline的字体，我这里设置的字体是12pt Meslo LG S DZ Regular for Powerline 设置iTerm 2设置iTerm 2 7. 配色方案1）安装配色方案 进入刚刚下载的工程的solarized/iterm2-colors-solarized下双击Solarized Dark.itermcolors和Solarized Light.itermcolors两个文件就可以把配置文件导入到 iTerm2 里 2）配置配色方案 通过load presets选择刚刚安装的配色主题即可 配色方案配色方案 8. 使用agnoster主题1）下载agnoster主题 到下载的工程里面运行install文件,主题将安装到~/.oh-my-zsh/themes目录下 2）设置该主题进入~/.zshrc打开.zshrc文件，然后将ZSH_THEME后面的字段改为agnoster。ZSH_THEME=”agnoster”（agnoster即为要设置的主题） 9. 增加指令高亮效果——zsh-syntax-highlighting指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮 1）首先在~/.oh-my-zsh/custom/plugins/路径下执行git clone https://github.com/zsh-users/zsh-syntax-highlighting.git到了此路径:~/.oh-my-zsh/custom/plugins/ 2）然后在~/.zshrc最后添加了下面两句：“plugins=(zsh-syntax-highlighting)source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh” 3）最后执行 source ~/.zshrc 这样就同时配置好了zsh和oh-my-zsh。有两点需要注意(摘自官网):Note the source command must be at the end of ~/.zshrc.Note that zsh-syntax-highlighting must be the last plugin sourced, so make it the last element of the $plugins array. 问题解答区 启动iTerm 2 默认使用dash改用zsh解决方法： chsh -s /bin/zsh 如果想切换回原来的dash： chsh -s /bin/bash 卸载oh my zsh，在命令行输入如下命令，回车即可： uninstall_oh_my_zsh 执行指令pip install powerline-status出错解决方法：需要下载苹果官方的Command line。必須官方工具下载最新版 Command Line ⌘+Q关闭iTerm 2 时每次弹窗提示问题：iTerm 2 中，进入Preference-General-Closing栏目，将Confirm “Quit iTerm2(⌘Q)” command选项勾选去掉就行 找不到.zshrc文件问题：我这里将原作者的.zshrc文件分享出来。供大家下载网盘 路径前缀的XX@XX太长，缩短问题：在此感谢评论区的朋友提供的解决方案。在~/.oh-my-zsh/themes路径下找到agnoster.zsh-theme文件，可使用文本工具打开，将里面的build_prompt下的prompt_context字段在前面加#注释掉即可。 执行指令pip install powerline-status出错，下载了Command Line也没有办法,是权限原因造成的,执行: pip install powerline-status –user 原文]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>iTerm 2</tag>
        <tag>Oh My Zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下安装mysql5.7完整步骤及问题整理]]></title>
    <url>%2F2018%2F03%2F19%2FMac%E4%B8%8B%E5%AE%89%E8%A3%85mysql5-7%E5%AE%8C%E6%95%B4%E6%AD%A5%E9%AA%A4%E5%8F%8A%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[安装参考以下这个博客: Mac下安装mysql5.7完整步骤 问题 “MAC下安装Mysql找不到my.cnf配置文件的问题”，参考：MAC 安装MySQL的my.cnf配置文件 “Warning: World-writable config file ‘/etc/my.cnf’ is ignored”，参考：World-writable]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac安装Mysql</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10下.Net Framework 3.5无法安装【错误代码0x800F081F】]]></title>
    <url>%2F2018%2F03%2F18%2FWin10%E4%B8%8B-Net-Framework-3-5%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[首先下载 .Net Framework 3.5. 将下载的文件复制到复制到 【C盘】 的 【Windows】 文件夹，然后后在“命令提示符（管理员）”中执行下面的命令： dism /online /Enable-Feature /FeatureName:NetFx3 /Source:”%windir%” /LimitAccess 其他: Windows 10下安装有的软件需要 .Net Framework 3.5的环境。默认是没有开启的，一般情况下可以【右键开始】菜单，选择【程序和功能】然后再选择【启用或关闭Windows功能】里的第一项【.Net Framework 3.5(包括.NET 2.0和3.0) 再一个就是去官网下一个手动安装一下也行，这两种方法都不行再用上面那个方法，这样大部分人的问题应该都可以解决了。]]></content>
      <categories>
        <category>OS</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Framework3.5无法安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机VirtualBox中挂载新硬盘]]></title>
    <url>%2F2018%2F03%2F18%2F%E8%99%9A%E6%8B%9F%E6%9C%BAVirtualBox%E4%B8%AD%E6%8C%82%E8%BD%BD%E6%96%B0%E7%A1%AC%E7%9B%98%2F</url>
    <content type="text"><![CDATA[在VirtualBox中装好Linux后，发现硬盘空间太小，怎样才能增加硬盘容量？那就是再建一个硬盘： 添加新硬盘 设置 -&gt; Storage(存储) -&gt; SATA控制器-&gt;右击，选择”添加虚拟硬盘”然后，根据需求创建合适的硬盘 重启虚拟机 查看现有系统的磁盘空间 sudo fdisk -l 可看到新加的虚拟硬盘，一般名为：Disk /dev/sdb 给新加的硬盘分区 fdisk /dev/sdb 键入m,可看到帮助信息 command (m for help):m 增加新分区 command (m for help):n 选择基本分区，输入：p 建一个分区 Partition number(1-4): 回车 First cylinder (1-15908,default 1):Enter 写入并退出 command (m for help):w 格式化磁盘分区 用ext4格式对/dev/sdb1进入格式化 sudo mkfs.ext4 /dev/sdb1 挂载分区 创建新的挂载点 sudo mkdir /work 将新磁盘分区挂载到/work目录下 sudo mount -t ext4 /dev/sdb1 /work 查看挂载 df -h 可以看到新加的硬盘：/dev/sdb1 开机自动挂载 修改文件 sudo vim /etc/fstab 在最后一行加入： /dev/sdb1 /work ext4 errors=remount-ro 0 1 完成! 补充：为挂载点扩容假设之前我们有一个挂载点为 /mydata ，但该 /mydata 已经写满，但依然想在 /mydata 下添加新的数据，这时可以使用软链接将 /mydata 软链接到一个新挂载的磁盘分区上以实现扩容。具体步骤如下。 1. 创建一个目录，以便稍后作为挂载点： mkdir /newdata 2. 将 /dev/sdb1 分区挂载到 /newdata 下： mount /dev/sdb1 /newdata 3. 新建 /mydata 到 /newdata 的软链接： ln -s /newdata /mydata 此时在 /mydata 目录下会有一个软链接文件 newdata 指向 /newdata/ ，即 newdata-&gt; /newdata/ 。这样一来，只要我们向 /mydata/newdata 下写文件，实际就写入了 /newdata/ 目录下，相当于我们为原 /mydata 挂载点新增加了一部分使用空间。 也可以手动指定该软链接文件的名称： ln -s /newdata /mydata/customed_name 这样就有 /mydata/customed_name -&gt; /newdata 注： 我们也可以利用软链接的这一用途，将比较大的日志文件链接到存储空间充足的磁盘分区的挂载点上。 举例来说，如果 /opt/tomcat/logs/catalina.out 日志文件输入很多，占用空间很大，而 /opt 挂载点中所剩空间已经不多，存在溢出风险，通过下面两步就可以将该日志文件软链接到另一个磁盘分区的挂载点上： touch /newdata/catalina_link.outln -sf /newdata/catalina_link.out /opt/tomcat/logs/catalina.out 这里还需要注意三点： 一是必须先创建一个被链接的文件，否则软链接后失败； 二是强制软链接会清空之前 /opt/tomcat/logs/catalina.out 日志文件中的全部内容清空； 三是需要重启 tomcat 目录后才能继续向 /opt/tomcat/logs/catalina.out 写入。]]></content>
      <categories>
        <category>OS</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>Linux挂载硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常见异常总结]]></title>
    <url>%2F2018%2F03%2F18%2FJava%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[java.lang.NullPointerException(空指针异常) 调用了未经初始化的对象或者是不存在的对象 经常出现在创建图片，调用数组这些操作中，比如图片未经初始化，或者图片创建时的路径错误等等。对数组操作中出现空指针，即把数组的初始化和数组元素的初始化混淆起来了。数组的初始化是对数组分配需要的空间，而初始化后的数组，其中的元素并没有实例化，依然是空的，所以还需要对每个元素都进行初始化（如果要调用的话）。 java.lang.ClassNotFoundException 指定的类不存在 这里主要考虑一下类的名称和路径是否正确即可，通常都是程序试图通过字符串来加载某个类时可能引发 异常 比如：调用Class.forName(); 或者调用ClassLoad的finaSystemClass();或者LoadClass(); java.lang.NumberFormatException 字符串转换为数字异常 当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常.如现在讲字符型的数据“123456”转换为数值型数据时，是允许的。但是如果字符型数据中包含了非数字型的字符，如123#56，此时转换为数值型时就会出现异常。系统就会捕捉到这个异常，并进行处理. java.lang.IndexOutOfBoundsException 数组下标越界异常 查看调用的数组或者字符串的下标值是不是超出了数组的范围，一般来说，显示（即直接用常数当下标）调用不太容易出这样的错，但隐式（即用变量表示下标）调用就经常出错了，还有一种情况，是程序中定义的数组的长度是通过某些特定方法决定的，不是事先声明的，这个时候，最好先查看一下数组的length，以免出现这个异常。 java.lang.IllegalArgumentException 方法的参数错误 比如g.setColor(int red,int green,int blue)这个方法中的三个值，如果有超过２５５的也会出现这个异常，因此一旦发现这个异常，我们要做的，就是赶紧去检查一下方法调用中的参数传递是不是出现了错误。 java.lang.IllegalAccessException 没有访问权限 当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。对程序中用了Package的情况下要注意这个异常 java.lang.ArithmeticException 数学运算异常 当算术运算中出现了除以零这样的运算就会出这样的异常。 java.lang.ClassCastException 数据类型转换异常 当试图将对某个对象强制执行向下转型，但该对象又不可转换又不可转换为其子类的实例时将引发该异常，如下列代码。 123Object obj = new Integer(0);String str = obj;java.lang.FileNotFoundException java.lang.FileNotFoundException 文件未找到异常 当程序试图打开一个不存在的文件进行读写时将会引发该异常。该异常由FileInputStream,FileOutputStream,RandomAccessFile的构造器声明抛出即使被操作的文件存在，但是由于某些原因不可访问，比如打开一个只读文件进行写入，这些构造方法仍然会引发异常 java.lang.ArrayStoreException 数组存储异常 当试图将类型不兼容类型的对象存入一个Object[]数组时将引发异常 123Object[] obj = new String[3];obj[0] = new Integer(0);java.lang.NoSuchMethodException java.lang.NoSuchMethodException 方法不存在异常 当程序试图通过反射来创建对象，访问(修改或读取)某个方法，但是该方法不存在就会引发异常 java.lang.NoSuchFiledException 方法不存在异常 当程序试图通过反射来创建对象，访问(修改或读取)某个filed，但是该filed不存在就会引发异常 java.lang.EOFException 文件已结束异常 当程序在输入的过程中遇到文件或流的结尾时，引发异常。因此该异常用于检查是否达到文件或流的结尾 java.lang.InstantiationException 实例化异常 当试图通过Class的newInstance()方法创建某个类的实例,但程序无法通过该构造器来创建该对象时引发Class对象表示一个抽象类，接口，数组类，基本类型该Class表示的类没有对应的构造器 java.lang.InterruptedException 被中止异常 当某个线程处于长时间的等待、休眠或其他暂停状态，而此时其他的线程通过Thread的interrupt方法终止该线程时抛出该异常。 java.lang.CloneNotSupportedException 不支持克隆异常 当没有实现Cloneable接口或者不支持克隆方法时,调用其clone()方法则抛出该异常。 java.lang.OutOfMemoryException 内存不足错误 当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。 java.lang.NoClassDefFoundException 未找到类定义错误 当Java虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误。 违背安全原则异常：SecturityException 操作数据库异常：SQLException 输入输出异常：IOException 通信异常：SocketException]]></content>
      <categories>
        <category>Java</category>
        <category>异常</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop伪分布式搭建-(4)]]></title>
    <url>%2F2018%2F03%2F18%2FHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-4%2F</url>
    <content type="text"><![CDATA[生成ssh免登陆密钥 进入到/dh/下的home目录(隐藏) cd ~/.sshssh-keygen -t rsa （一直回车） 执行完这个命令后，会生成两个文件id_rsa（私钥）、id_rsa.pub（公钥） 将公钥拷贝到要免登陆的机器上 ssh-copy-id -i localhost (ssh-copy-id -i 要免登陆的机器的IP)或者cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop伪分布式搭建-(3)]]></title>
    <url>%2F2018%2F03%2F18%2FHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-3%2F</url>
    <content type="text"><![CDATA[安装hadoop2.4.1（或其他更高版本&lt;最好用更高的64位版本，免得重新编译&gt;）注意：hadoop2.x的配置文件$HADOOP_HOME/etc/hadoop伪分布式需要修改5个配置文件 上传hadoop并解压到指定目录同jdk一样,上传Hadoop的包到本目录,并在root目录下创建/dh/这个目录,将Hadoop解压到该目录 配置hadoop hadoop-env.sh文件 vim hadoop-env.sh 1export JAVA_HOME=/usr/java/jdk1.7.0_79 core-site.xml文件 vim core-site.xml 12345678910&lt;!--设定NameNode地址 --&gt;&lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://dh01:9000&lt;/value&gt; &lt;!--或者把dh01换成对应IP--&gt;&lt;/property&gt;&lt;!-- 指定hadoop运行时产生文件的存储目录 --&gt;&lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/dh/hadoop-2.4.1/tmp&lt;/value&gt;&lt;/property&gt; hdfs-site.xml文件 vim hdfs-site.xml 12345&lt;!-- 指定HDFS副本的数量 --&gt;&lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt;&lt;!--因为为伪分布式,所以只有一个副本--&gt;&lt;/property&gt; mapred-site.xml文件 #重命名mv mapred-site.xml.template mapred-site.xml#打开重命名后的文件vim mapred-site.xml 12345&lt;!-- 指定mapreduce运行在YARN上 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt; yarn-site.xml文件 12345678910&lt;!-- 指定YARN的老大（ResourceManager）的地址 --&gt;&lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;dh01&lt;/value&gt;&lt;/property&gt;&lt;!-- mapreduce获取数据的方式 --&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt; 将hadoop添加到环境变量 vim /etc/proflie 123export JAVA_HOME=/usr/java/jdk1.7.0_79export HADOOP_HOME=/dh/hadoop-2.4.1export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$HADOOP_HOME/lib 刷新配置文件 source /etc/profile 格式化namenode（是对namenode进行初始化） hdfs namenode -format (hadoop namenode -format) 启动hadoop先启动HDFS sbin/start-dfs.sh 再启动YARN sbin/start-yarn.sh 验证是否启动成功使用jps命令验证 jsp 12345627408 NameNode28218 Jps27643 SecondaryNameNode28066 NodeManager27803 ResourceManager27512 DataNode http://192.168.8.88:50070 （HDFS管理界面） 在这个文件中添加linux主机名和IP的映射关系C:\Windows\System32\drivers\etc\hosts下添加:1192.168.1.66 dh01 打开：http://192.168.8.88:8088验证 （mapreduce管理界面）]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop伪分布式搭建-(2)]]></title>
    <url>%2F2018%2F03%2F18%2FHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-2%2F</url>
    <content type="text"><![CDATA[安装JDK 从Windows上传jdk到虚拟机 你可以用FlashFXP/FileZilla/SecureCRT将jdk-7u79-linux-x64.gz传到Linux上。假设现在你已经传到了虚拟机的root目录下 解压jdk mkdir /usr/javatar -zxvf jdk-7u79-linux-x64.gz -C /usr/java/ 将java添加到环境变量中 vim /etc/profile 12export JAVA_HOME=/usr/java/jdk1.7.0_79 export PATH=$PATH:$JAVA_HOME/bin 刷新配置 source /etc/profile]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop伪分布式搭建-(1)]]></title>
    <url>%2F2018%2F03%2F18%2FHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-1%2F</url>
    <content type="text"><![CDATA[配置虚拟机子网网段(hostonly模式时) 配置网段 点击VMware快捷方式，右键打开文件所在位置 -&gt; 双击vmnetcfg.exe -&gt; VMnet1 host-only -&gt;修改subnet ip 设置网段：192.168.8.0 子网掩码：255.255.255.0 -&gt; apply -&gt; ok 设置本地机器IP 回到windows –&gt; 打开网络和共享中心 -&gt; 更改适配器设置 -&gt; 右键VMnet1 -&gt; 属性 -&gt; 双击IPv4 -&gt;设置windows的IP：192.168.8.100 子网掩码：255.255.255.0 -&gt; 点击确定 设置为hostonly模式 在虚拟软件上 –My Computer -&gt; 选中虚拟机 -&gt; 右键 -&gt; settings -&gt; network adapter -&gt; host only -&gt; ok 另:桥接模式 桥接模式直接将本地机器的当前正在使用的网卡(无线/非无线网卡)IP改为静态IP即可.设置windows的IP：192.168.8.100 子网掩 码：255.255.255.0 -&gt; 网关:192.168.1.1 -&gt; 若为无线网卡,设置前先查看路由分配的DNS是多少,直接照着填进来就行.-&gt;点击确定 修改主机名 vim /etc/sysconfig/network 12NETWORKING=yesHOSTNAME=dh01 #随便设置一个名字 修改虚拟机IP(这里是centos7)两种方式： 第一种：通过Linux图形界面进行修改（推荐） 进入Linux图形界面 -&gt; 右键点击右上方的两个小电脑 -&gt;点击Edit connections -&gt; 选中当前网络System eth0 -&gt;点击edit按钮 -&gt; 选择IPv4 -&gt; method选择为manual -&gt;点击add按钮 -&gt;添加IP：192.168.8.88子网掩码：255.255.255.0 网关：192.168.8.1 -&gt; apply 第二种：修改配置文件方式 vim /etc/sysconfig/network-scripts/ifcfg-eth0 (不一定一定是ifcfg-eth0) 1234567891011DEVICE=&quot;eth0&quot;BOOTPROTO=&quot;static&quot; #修改HWADDR=&quot;00:0C:29:3C:BF:E7&quot;IPV6INIT=&quot;yes&quot;NM_CONTROLLED=&quot;yes&quot;ONBOOT=&quot;yes&quot;TYPE=&quot;Ethernet&quot;UUID=&quot;ce22eeca-ecde-4536-8cc2-ef0dc36d4a8c&quot;IPADDR=&quot;192.168.8.88&quot; #修改NETMASK=&quot;255.255.255.0&quot; #修改GATEWAY=&quot;192.168.8.1&quot; #修改 修改主机名和IP的映射关系 vim /etc/hosts 1192.168.8.88 dh01 关闭防火墙(以下为centos7以前命令,centos7) #查看防火墙状态service iptables status #关闭防火墙service iptables stop #查看防火墙开机启动状态chkconfig iptables –list #关闭防火墙开机启动chkconfig iptables off CentOS 7.0默认使用的是firewall作为防火墙 systemctl start firewalld.service #启动firewallsystemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动 也可以改成使用iptables：systemctl start iptables.service 重启Linux reboot]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse下JSP中使用UEditor（以富文本编辑器为例）]]></title>
    <url>%2F2017%2F02%2F20%2FEclipse%E4%B8%8BJSP%E4%B8%AD%E4%BD%BF%E7%94%A8UEditor(%E4%BB%A5%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%BA%E4%BE%8B)%2F</url>
    <content type="text"><![CDATA[1.下载UEditorhttp://ueditor.baidu.com/website/download.html 版本如下： 2.解压，简单暴力地将\ueditor1_4_3-utf8-jsp\jsp\lib目录下的文件拷贝到项目的/WEB-INF/lib目录下如图所示： 3.将除index.html文件外的文件拷贝到项目中，例如： 4.在要使用富文本编辑器的页面引入脚本：12345&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&lt;%=path%&gt;/js/ueditor/ueditor.config.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&lt;%=path%&gt;/js/ueditor/ueditor.all.min.js&quot;&gt; &lt;/script&gt;&lt;!--建议手动加在语言，避免在ie下有时因为加载语言失败导致编辑器加载失败--&gt;&lt;!--这里加载的语言文件会覆盖你在配置项目里添加的语言类型，比如你在配置项目里配置的是英文，这里加载的中文，那最后就是中文--&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&lt;%=path%&gt;/js/ueditor/lang/zh-cn/zh-cn.js&quot;&gt;&lt;/script&gt; 如图： 5.在需要用富文本编辑器的区域添加以下脚本：1&lt;script id=&quot;editor&quot; type=&quot;text/plain&quot; style=&quot;width:486px;height:300px;&quot;&gt;&lt;/script&gt; 如图： 6.在页面最下端写以下javascript脚本：12345&lt;script type=&quot;text/javascript&quot;&gt; //实例化编辑器 //建议使用工厂方法getEditor创建和引用编辑器实例，如果在某个闭包下引用该编辑器，直接调用UE.getEditor(&apos;editor&apos;)就能拿到相关的实例 var ue = UE.getEditor(&apos;editor&apos;);&lt;/script&gt; 如图： 7.添加提交按钮的js脚本，用来提交内容脚本文件：代码：12345678function check_post_msg_valid()&#123; if(false==UE.getEditor(&apos;editor&apos;).hasContents())&#123; alert(&apos;请输入内容！&apos;); return false; &#125; document.getElementById(&quot;msg&quot;).value=UE.getEditor(&apos;editor&apos;).getContent(); document.forms[0].submit(); &#125; 8.其他：]]></content>
      <categories>
        <category>Java</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>UEditor</tag>
        <tag>富文本编辑器</tag>
      </tags>
  </entry>
</search>
