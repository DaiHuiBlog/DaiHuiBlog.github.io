<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo下NexT主题添加Gitment评论插件]]></title>
    <url>%2F2018%2F06%2F20%2FHexo%E4%B8%8BNexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Gitment%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最终效果图大概是这个样子： Gitment 是作者imsun实现的一款基于 GitHub Issues 的评论系统。 支持在前端直接引入， 不需要任何后端代码。 可以在页面进行登录， 查看，评论，点赞等操作。 同时有完整的 Markdown / GFM 和代码高亮支持。 尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 这篇文章仅介绍如果在 hexo-NexT 中添加 Gitment 评论插件，并且增加一个点开显示评论的按钮，对于 Gitment 的使用请参考 imsun 的博客。 另外，本教程的按钮样式和代码均直接取自 ehlxr 博主。 注册OAuth Application因为 Gitment 评论插件是基于Github Issues评论系统，这类评论系统都需要一个OAuth Application，所以咱们没有注册OAuth Application的同学先注册一个。博客咱们已经有啦，例如我的：DaiHuiBlog.github.io。没有的同学以自己GitHub用户新建一个仓库就行：你的用户名.github.io接下来创建 OAuth Application，没有的同学可以新建一个。 其中 Application name 为仓库名，例：DaiHuiBlog.github.io Homepage URL 填你的博客网址，例：blog.daihui888.com Application description 描述，随便写 Authorization callback URL 填你的博客网址，例：blog.daihui888.com 完成后会生成相应的 clientID 和 clientSecret。 接下来开始配置Gitment “显示 Gitment 评论” 的按钮样式在 next/source/css/_common/components 目录中新建一个 gitment.styl 的 css 样式文件, 复制以下代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.gitment_title:hover &#123; color: #fff; background: #0a9caf; background-image: initial; background-position-x: initial; background-position-y: initial; background-size: initial; background-repeat-x: initial; background-repeat-y: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: rgb(10, 156, 175);&#125;.gitment_title &#123; border: 1px solid #0a9caf; border-top-color: rgb(10, 156, 175); border-top-style: solid; border-top-width: 1px; border-right-color: rgb(10, 156, 175); border-right-style: solid; border-right-width: 1px; border-bottom-color: rgb(10, 156, 175); border-bottom-style: solid; border-bottom-width: 1px; border-left-color: rgb(10, 156, 175); border-left-style: solid; border-left-width: 1px; border-image-source: initial; border-image-slice: initial; border-image-width: initial; border-image-outset: initial; border-image-repeat: initial; border-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px;&#125;.gitment_title &#123; display: inline-block; padding: 0 15px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; color: #0a9caf; cursor: pointer; font-size: 14px;&#125; 然后打开同目录中的 components.styl 文件, 找个顺眼的位置添加一句 1@import &quot;gitment&quot; 添加 Gitment 插件打开 /next/layout/_partials/comments.swig 文件, 在最后一个 elseif 代码块下面添加 Gitment 的内容. 1234567891011121314151617181920212223242526272829303132333435363738// 前面的略... ...&#123;% elseif theme.changyan.appid and theme.changyan.appkey %&#125; &lt;div id=&quot;SOHUCS&quot;&gt;&lt;/div&gt;&#123;% elseif theme.gitment.enable %&#125; &lt;div onclick=&quot;showGitment()&quot; id=&quot;gitment_title&quot; class=&quot;gitment_title&quot;&gt;显示 Gitment 评论&lt;/div&gt; &lt;div id=&quot;container&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt; &lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const myTheme = &#123; render(state, instance) &#123; const container = document.createElement(&apos;div&apos;); container.lang = &quot;en-US&quot;; container.className = &apos;gitment-container gitment-root-container&apos;; container.appendChild(instance.renderHeader(state, instance)); container.appendChild(instance.renderEditor(state, instance)); container.appendChild(instance.renderComments(state, instance)); container.appendChild(instance.renderFooter(state, instance)); return container; &#125; &#125; function showGitment() &#123; $(&quot;#gitment_title&quot;).attr(&quot;style&quot;, &quot;display:none&quot;); $(&quot;#container&quot;).attr(&quot;style&quot;, &quot;&quot;).addClass(&quot;gitment_container&quot;); var gitment = new Gitment(&#123; id: decodeURI(window.location.pathname), theme: myTheme, owner: &apos;&#123;&#123; theme.gitment.owner &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitment.repo &#125;&#125;&apos;, oauth: &#123; client_id: &apos;&#123;&#123; theme.gitment.client_id &#125;&#125;&apos;, client_secret: &apos;&#123;&#123; theme.gitment.client_secret &#125;&#125;&apos; &#125; &#125;); gitment.render(&apos;container&apos;); &#125; &lt;/script&gt;&#123;% endif %&#125; 然后打开 NexT 主题的_config.yml 文件，在评论相关设置的区域添加下面的代码，并根据 Gitment 文档说明来添加相应的值 12345678# Gitment commentsgitment: enable: true owner: xxx repo: xxx client_id: xxx client_secret: xxx lazy: true #lazy属性为是否直接显示评论模块，true会显示”显示评论”按钮，false会直接显示 另外，Gitment需要自己手动初始化一下来创建一个issues，不喜欢他的同学可以用Gtalk]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Gitment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置mac自带的vim语法高亮]]></title>
    <url>%2F2018%2F06%2F15%2F%E8%AE%BE%E7%BD%AEmac%E8%87%AA%E5%B8%A6%E7%9A%84vim%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[最终效果图大概是这个样子： 设置vimrcvimrc文件是vim的环境设置文件。整体的vim的设置是在 /etc/vimrc 文件中。不建议修改/etc/vimrc 文件，每个用户可以在用户根目录中设置vim，新建 ~/.vimrc touch .vimrc 在.vimrc中添加以下内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285"=========================================================================" DesCRiption: 适合自己使用的vimrc文件，for Mac/Linux/Windows, GUI/Console"" Last Change: 2017年09月11日 "" Version: 1.80""=========================================================================set nocompatible " 关闭 vi 兼容模式syntax on " 自动语法高亮colorscheme molokai " 设定配色方案set number " 显示行号set cursorline " 突出显示当前行set ruler " 打开状态栏标尺set shiftwidth=4 " 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4set softtabstop=4 " 使得按退格键时可以一次删掉 4 个空格set tabstop=4 " 设定 tab 长度为 4set nobackup " 覆盖文件时不备份set autochdir " 自动切换当前目录为当前文件所在的目录filetype plugin indent on " 开启插件set backupcopy=yes " 设置备份时的行为为覆盖set ignorecase smartcase " 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感set nowrapscan " 禁止在搜索到文件两端时重新搜索set incsearch " 输入搜索内容时就显示搜索结果set hlsearch " 搜索时高亮显示被找到的文本set noerrorbells " 关闭错误信息响铃set novisualbell " 关闭使用可视响铃代替呼叫set t_vb= " 置空错误铃声的终端代码" set showmatch " 插入括号时，短暂地跳转到匹配的对应括号" set matchtime=2 " 短暂跳转到匹配括号的时间set magic " 设置魔术set hidden " 允许在有未保存的修改时切换缓冲区，此时的修改由 vim 负责保存set guioptions-=T " 隐藏工具栏set guioptions-=m " 隐藏菜单栏set smartindent " 开启新行时使用智能自动缩进set backspace=indent,eol,start" 不设定在插入状态无法用退格键和 Delete 键删除回车符set cmdheight=1 " 设定命令行的行数为 1set laststatus=2 " 显示状态栏 (默认值为 1, 无法显示状态栏)set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\" 设置在状态行显示的信息set foldenable " 开始折叠set foldmethod=syntax " 设置语法折叠set foldcolumn=0 " 设置折叠区域的宽度setlocal foldlevel=1 " 设置折叠层数为" set foldclose=all " 设置为自动关闭折叠" nnoremap &lt;space&gt; @=((foldclosed(line('.')) &lt; 0) ? 'zc' : 'zo')&lt;CR&gt;" 用空格键来开关折叠" return OS type, eg: windows, or linux, mac, et.st..function! MySys()if has("win16") || has("win32") || has("win64") || has("win95")return "windows"elseif has("unix")return "linux"endifendfunction" 用户目录变量$VIMFILESif MySys() == "windows"let $VIMFILES = $VIM.'/vimfiles'elseif MySys() == "linux"let $VIMFILES = $HOME.'/.vim'endif" 设定doc文档目录let helptags=$VIMFILES.'/doc'" 设置字体 以及中文支持if has("win32")set guifont=Inconsolata:h12:cANSIendif" 配置多语言环境if has("multi_byte")" UTF-8 编码set encoding=utf-8set termencoding=utf-8set formatoptions+=mMset fencs=utf-8,gbkif v:lang =~? '^\(zh\)\|\(ja\)\|\(ko\)'set ambiwidth=doubleendifif has("win32")source $VIMRUNTIME/delmenu.vimsource $VIMRUNTIME/menu.vimlanguage messages zh_CN.utf-8endifelseechoerr "Sorry, this version of (g)vim was not compiled with +multi_byte"endif" Buffers操作快捷方式!nnoremap &lt;C-RETURN&gt; :bnext&lt;CR&gt;nnoremap &lt;C-S-RETURN&gt; :bprevious&lt;CR&gt;" Tab操作快捷方式!nnoremap &lt;C-TAB&gt; :tabnext&lt;CR&gt;nnoremap &lt;C-S-TAB&gt; :tabprev&lt;CR&gt;"关于tab的快捷键" map tn :tabnext&lt;cr&gt;" map tp :tabprevious&lt;cr&gt;" map td :tabnew .&lt;cr&gt;" map te :tabedit" map tc :tabclose&lt;cr&gt;"窗口分割时,进行切换的按键热键需要连接两次,比如从下方窗口移动"光标到上方窗口,需要&lt;c-w&gt;&lt;c-w&gt;k,非常麻烦,现在重映射为&lt;c-k&gt;,切换的"时候会变得非常方便.nnoremap &lt;C-h&gt; &lt;C-w&gt;hnnoremap &lt;C-j&gt; &lt;C-w&gt;jnnoremap &lt;C-k&gt; &lt;C-w&gt;knnoremap &lt;C-l&gt; &lt;C-w&gt;l"一些不错的映射转换语法（如果在一个文件中混合了不同语言时有用）nnoremap &lt;leader&gt;1 :set filetype=xhtml&lt;CR&gt;nnoremap &lt;leader&gt;2 :set filetype=css&lt;CR&gt;nnoremap &lt;leader&gt;3 :set filetype=javascript&lt;CR&gt;nnoremap &lt;leader&gt;4 :set filetype=php&lt;CR&gt;" set fileformats=unix,dos,mac" nmap &lt;leader&gt;fd :se fileformat=dos&lt;CR&gt;" nmap &lt;leader&gt;fu :se fileformat=unix&lt;CR&gt;" use Ctrl+[l|n|p|cc] to list|next|previous|jump to count the result" map &lt;C-x&gt;l &lt;ESC&gt;:cl&lt;CR&gt;" map &lt;C-x&gt;n &lt;ESC&gt;:cn&lt;CR&gt;" map &lt;C-x&gt;p &lt;ESC&gt;:cp&lt;CR&gt;" map &lt;C-x&gt;c &lt;ESC&gt;:cc&lt;CR&gt;" 让 Tohtml 产生有 CSS 语法的 html" syntax/2html.vim，可以用:runtime! syntax/2html.vimlet html_use_css=1" Python 文件的一般设置，比如不要 tab 等autocmd FileType python set tabstop=4 shiftwidth=4 expandtabautocmd FileType python map &lt;F12&gt; :!python %&lt;CR&gt;" 选中状态下 Ctrl+c 复制vmap &lt;C-c&gt; "+y" 打开javascript折叠let b:javascript_fold=1" 打开javascript对dom、html和css的支持let javascript_enable_domhtmlcss=1" 设置字典 ~/.vim/dict/文件的路径autocmd filetype javascript set dictionary=$VIMFILES/dict/javascript.dictautocmd filetype css set dictionary=$VIMFILES/dict/css.dictautocmd filetype php set dictionary=$VIMFILES/dict/php.dict"-----------------------------------------------------------------" plugin - bufexplorer.vim Buffers切换" \be 全屏方式查看全部打开的文件列表" \bv 左右方式查看 \bs 上下方式查看"-----------------------------------------------------------------"-----------------------------------------------------------------" plugin - taglist.vim 查看函数列表，需要ctags程序" F4 打开隐藏taglist窗口"-----------------------------------------------------------------if MySys() == "windows" " 设定windows系统中ctags程序的位置let Tlist_Ctags_Cmd = '"'.$VIMRUNTIME.'/ctags.exe"'elseif MySys() == "linux" " 设定windows系统中ctags程序的位置let Tlist_Ctags_Cmd = '/usr/bin/ctags'endifnnoremap &lt;silent&gt;&lt;F4&gt; :TlistToggle&lt;CR&gt;let Tlist_Show_One_File = 1 " 不同时显示多个文件的tag，只显示当前文件的let Tlist_Exit_OnlyWindow = 1 " 如果taglist窗口是最后一个窗口，则退出vimlet Tlist_Use_Right_Window = 1 " 在右侧窗口中显示taglist窗口let Tlist_File_Fold_Auto_Close=1 " 自动折叠当前非编辑文件的方法列表let Tlist_Auto_Open = 0let Tlist_Auto_Update = 1let Tlist_Hightlight_Tag_On_BufEnter = 1let Tlist_Enable_Fold_Column = 0let Tlist_Process_File_Always = 1let Tlist_Display_Prototype = 0let Tlist_Compact_Format = 1"-----------------------------------------------------------------" plugin - mark.vim 给各种tags标记不同的颜色，便于观看调式的插件。" \m mark or unmark the word under (or before) the cursor" \r manually input a regular expression. 用于搜索." \n clear this mark (i.e. the mark under the cursor), or clear all highlighted marks ." \* 当前MarkWord的下一个 \# 当前MarkWord的上一个" \/ 所有MarkWords的下一个 \? 所有MarkWords的上一个"-----------------------------------------------------------------"-----------------------------------------------------------------" plugin - NERD_tree.vim 以树状方式浏览系统中的文件和目录" :ERDtree 打开NERD_tree :NERDtreeClose 关闭NERD_tree" o 打开关闭文件或者目录 t 在标签页中打开" T 在后台标签页中打开 ! 执行此文件" p 到上层目录 P 到根目录" K 到第一个节点 J 到最后一个节点" u 打开上层目录 m 显示文件系统菜单（添加、删除、移动操作）" r 递归刷新当前目录 R 递归刷新当前根目录"-----------------------------------------------------------------" F3 NERDTree 切换map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;imap &lt;F3&gt; &lt;ESC&gt;:NERDTreeToggle&lt;CR&gt;"-----------------------------------------------------------------" plugin - NERD_commenter.vim 注释代码用的，" [count],cc 光标以下count行逐行添加注释(7,cc)" [count],cu 光标以下count行逐行取消注释(7,cu)" [count],cm 光标以下count行尝试添加块注释(7,cm)" ,cA 在行尾插入 ,并且进入插入模式。 这个命令方便写注释。" 注：count参数可选，无则默认为选中行或当前行"-----------------------------------------------------------------let NERDSpaceDelims=1 " 让注释符与语句之间留一个空格let NERDCompactSexyComs=1 " 多行注释时样子更好看"-----------------------------------------------------------------" plugin - DoxygenToolkit.vim 由注释生成文档，并且能够快速生成函数标准注释"-----------------------------------------------------------------let g:DoxygenToolkit_authorName="Asins - asinsimple AT gmail DOT com"let g:DoxygenToolkit_briefTag_funcName="yes"map &lt;leader&gt;da :DoxAuthor&lt;CR&gt;map &lt;leader&gt;df :Dox&lt;CR&gt;map &lt;leader&gt;db :DoxBlock&lt;CR&gt;map &lt;leader&gt;dc a &lt;LEFT&gt;&lt;LEFT&gt;&lt;LEFT&gt;"-----------------------------------------------------------------" plugin – ZenCoding.vim 很酷的插件，HTML代码生成" 插件最新版：http://github.com/mattn/zencoding-vim" 常用命令可看：http://nootn.com/blog/Tool/23/"-----------------------------------------------------------------"-----------------------------------------------------------------" plugin – checksyntax.vim JavaScript常见语法错误检查" 默认快捷方式为 F5"-----------------------------------------------------------------let g:checksyntax_auto = 0 " 不自动检查"-----------------------------------------------------------------" plugin - NeoComplCache.vim 自动补全插件"-----------------------------------------------------------------let g:AutoComplPop_NotEnableAtStartup = 1let g:NeoComplCache_EnableAtStartup = 1let g:NeoComplCache_SmartCase = 1let g:NeoComplCache_TagsAutoUpdate = 1let g:NeoComplCache_EnableInfo = 1let g:NeoComplCache_EnableCamelCaseCompletion = 1let g:NeoComplCache_MinSyntaxLength = 3let g:NeoComplCache_EnableSkipCompletion = 1let g:NeoComplCache_SkipInputTime = '0.5'let g:NeoComplCache_SnippetsDir = $VIMFILES.'/snippets'" &lt;TAB&gt; completion.inoremap &lt;expr&gt;&lt;TAB&gt; pumvisible() ? "\&lt;C-n&gt;" : "\&lt;TAB&gt;"" snippets expand keyimap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)smap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)"-----------------------------------------------------------------" plugin - matchit.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转" % 正向匹配 g% 反向匹配" [% 定位块首 ]% 定位块尾"-----------------------------------------------------------------"-----------------------------------------------------------------" plugin - vcscommand.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转" SVN/git管理工具"-----------------------------------------------------------------"-----------------------------------------------------------------" plugin – a.vim"----------------------------------------------------------------- 设置颜色主题进入对应目录准备颜色文件，没有就创建对应目录和文件 1234567daihui@daihuideMBP ~ cd .vim/colorsdaihui@daihuideMBP ~/.vim/colors pwd/Users/daihui/.vim/colors# 在~/.vim/colors目录下新建一个颜色文件daihui@daihuideMBP ~/.vim/colors touch molokai.vim molokai.vim 文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212" Vim color file"" Author: Tomas Restrepo &lt;tomas@winterdom.com&gt;"" Note: Based on the monokai theme for textmate" by Wimer Hazenberg and its darker variant" by Hamish Stuart Macpherson"hi clearset background=darkif version &gt; 580 " no guarantees for version 5.8 and below, but this makes it stop " complaining hi clear if exists("syntax_on") syntax reset endifendiflet g:colors_name="molokai"if exists("g:molokai_original") let s:molokai_original = g:molokai_originalelse let s:molokai_original = 0endifhi Boolean guifg=#AE81FFhi Character guifg=#E6DB74hi Number guifg=#AE81FFhi String guifg=#E6DB74hi Conditional guifg=#F92672 gui=boldhi Constant guifg=#AE81FF gui=boldhi Cursor guifg=#000000 guibg=#F8F8F0hi Debug guifg=#BCA3A3 gui=boldhi Define guifg=#66D9EFhi Delimiter guifg=#8F8F8Fhi DiffAdd guibg=#13354Ahi DiffChange guifg=#89807D guibg=#4C4745hi DiffDelete guifg=#960050 guibg=#1E0010hi DiffText guibg=#4C4745 gui=italic,boldhi Directory guifg=#A6E22E gui=boldhi Error guifg=#960050 guibg=#1E0010hi ErrorMsg guifg=#F92672 guibg=#232526 gui=boldhi Exception guifg=#A6E22E gui=boldhi Float guifg=#AE81FFhi FoldColumn guifg=#465457 guibg=#000000hi Folded guifg=#465457 guibg=#000000hi Function guifg=#A6E22Ehi Identifier guifg=#FD971Fhi Ignore guifg=#808080 guibg=bghi IncSearch guifg=#C4BE89 guibg=#000000hi Keyword guifg=#F92672 gui=boldhi Label guifg=#E6DB74 gui=nonehi Macro guifg=#C4BE89 gui=italichi SpecialKey guifg=#66D9EF gui=italichi MatchParen guifg=#000000 guibg=#FD971F gui=boldhi ModeMsg guifg=#E6DB74hi MoreMsg guifg=#E6DB74hi Operator guifg=#F92672" complete menuhi Pmenu guifg=#66D9EF guibg=#000000hi PmenuSel guibg=#808080hi PmenuSbar guibg=#080808hi PmenuThumb guifg=#66D9EFhi PreCondit guifg=#A6E22E gui=boldhi PreProc guifg=#A6E22Ehi Question guifg=#66D9EFhi Repeat guifg=#F92672 gui=boldhi Search guifg=#FFFFFF guibg=#455354" marks columnhi SignColumn guifg=#A6E22E guibg=#232526hi SpecialChar guifg=#F92672 gui=boldhi SpecialComment guifg=#465457 gui=boldhi Special guifg=#66D9EF guibg=bg gui=italichi SpecialKey guifg=#888A85 gui=italicif has("spell") hi SpellBad guisp=#FF0000 gui=undercurl hi SpellCap guisp=#7070F0 gui=undercurl hi SpellLocal guisp=#70F0F0 gui=undercurl hi SpellRare guisp=#FFFFFF gui=undercurlendifhi Statement guifg=#F92672 gui=boldhi StatusLine guifg=#455354 guibg=fghi StatusLineNC guifg=#808080 guibg=#080808hi StorageClass guifg=#FD971F gui=italichi Structure guifg=#66D9EFhi Tag guifg=#F92672 gui=italichi Title guifg=#ef5939hi Todo guifg=#FFFFFF guibg=bg gui=boldhi Typedef guifg=#66D9EFhi Type guifg=#66D9EF gui=nonehi Underlined guifg=#808080 gui=underlinehi VertSplit guifg=#808080 guibg=#080808 gui=boldhi VisualNOS guibg=#403D3Dhi Visual guibg=#403D3Dhi WarningMsg guifg=#FFFFFF guibg=#333333 gui=boldhi WildMenu guifg=#66D9EF guibg=#000000if s:molokai_original == 1 hi Normal guifg=#F8F8F2 guibg=#272822 hi Comment guifg=#75715E hi CursorLine guibg=#3E3D32 hi CursorColumn guibg=#3E3D32 hi LineNr guifg=#BCBCBC guibg=#3B3A32 hi NonText guifg=#BCBCBC guibg=#3B3A32else hi Normal guifg=#F8F8F2 guibg=#1B1D1E hi Comment guifg=#465457 hi CursorLine guibg=#293739 hi CursorColumn guibg=#293739 hi LineNr guifg=#BCBCBC guibg=#232526 hi NonText guifg=#BCBCBC guibg=#232526end"" Support for 256-color terminal"if &amp;t_Co &gt; 255 hi Boolean ctermfg=135 hi Character ctermfg=144 hi Number ctermfg=135 hi String ctermfg=144 hi Conditional ctermfg=161 cterm=bold hi Constant ctermfg=135 cterm=bold hi Cursor ctermfg=16 ctermbg=253 hi Debug ctermfg=225 cterm=bold hi Define ctermfg=81 hi Delimiter ctermfg=241 hi DiffAdd ctermbg=24 hi DiffChange ctermfg=181 ctermbg=239 hi DiffDelete ctermfg=162 ctermbg=53 hi DiffText ctermbg=102 cterm=bold hi Directory ctermfg=118 cterm=bold hi Error ctermfg=219 ctermbg=89 hi ErrorMsg ctermfg=199 ctermbg=16 cterm=bold hi Exception ctermfg=118 cterm=bold hi Float ctermfg=135 hi FoldColumn ctermfg=67 ctermbg=16 hi Folded ctermfg=67 ctermbg=16 hi Function ctermfg=118 hi Identifier ctermfg=208 hi Ignore ctermfg=244 ctermbg=232 hi IncSearch ctermfg=193 ctermbg=16 hi Keyword ctermfg=161 cterm=bold hi Label ctermfg=229 cterm=none hi Macro ctermfg=193 hi SpecialKey ctermfg=81 hi MatchParen ctermfg=16 ctermbg=208 cterm=bold hi ModeMsg ctermfg=229 hi MoreMsg ctermfg=229 hi Operator ctermfg=161 " complete menu hi Pmenu ctermfg=81 ctermbg=16 hi PmenuSel ctermbg=244 hi PmenuSbar ctermbg=232 hi PmenuThumb ctermfg=81 hi PreCondit ctermfg=118 cterm=bold hi PreProc ctermfg=118 hi Question ctermfg=81 hi Repeat ctermfg=161 cterm=bold hi Search ctermfg=253 ctermbg=66 " marks column hi SignColumn ctermfg=118 ctermbg=235 hi SpecialChar ctermfg=161 cterm=bold hi SpecialComment ctermfg=245 cterm=bold hi Special ctermfg=81 ctermbg=232 hi SpecialKey ctermfg=245 hi Statement ctermfg=161 cterm=bold hi StatusLine ctermfg=238 ctermbg=253 hi StatusLineNC ctermfg=244 ctermbg=232 hi StorageClass ctermfg=208 hi Structure ctermfg=81 hi Tag ctermfg=161 hi Title ctermfg=166 hi Todo ctermfg=231 ctermbg=232 cterm=bold hi Typedef ctermfg=81 hi Type ctermfg=81 cterm=none hi Underlined ctermfg=244 cterm=underline hi VertSplit ctermfg=244 ctermbg=232 cterm=bold hi VisualNOS ctermbg=238 hi Visual ctermbg=235 hi WarningMsg ctermfg=231 ctermbg=238 cterm=bold hi WildMenu ctermfg=81 ctermbg=16 hi Normal ctermfg=252 ctermbg=233 hi Comment ctermfg=59 hi CursorLine ctermbg=234 cterm=none hi CursorColumn ctermbg=234 hi LineNr ctermfg=250 ctermbg=234 hi NonText ctermfg=250 ctermbg=234end 重启vim再进来看看原文]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下删除launchpad还有残留图标的应用]]></title>
    <url>%2F2018%2F05%2F16%2FMac%E4%B8%8B%E5%88%A0%E9%99%A4launchpad%E8%BF%98%E6%9C%89%E6%AE%8B%E7%95%99%E5%9B%BE%E6%A0%87%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[有时候用户在删除自己应用的时候在应用程序里直接右键“移到废纸楼”，有的应用这样删除后在launchpad里还有残留的图标，按住option键也没有删除标记可以删除该图标。这让人很蛋疼，但是可以通过下面这个小技巧将该图标删除，方法如下： 打开launchpad下列三个放都可以打开launchpad fn + F4（F1-F12是正常使用情况） F4（F1-F12使用需要借助fn键使用） 四个指头抓一下 具体操作1. 长按control+option+command，看到图标抖动2. 单击待删除图标，图标中心出现白色问号3. 松开按住的三个快捷键（control+option+command）4. 再次按下这三个快捷键，图标左上角会出现“✘”，点击删除]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac删除</tag>
        <tag>launchpad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git简明指南]]></title>
    <url>%2F2018%2F04%2F24%2FGit%E7%AE%80%E6%98%8E%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[安装下载 git OSX 版下载 git Windows 版下载 git Linux 版创建新仓库创建新文件夹，打开，然后执行1git init 以创建新的 git 仓库。 检出仓库执行如下命令以创建一个本地仓库的克隆版本：1git clone /path/to/repository 如果是远端服务器上的仓库，你的命令会是这个样子：1git clone username@host:/path/to/repository 工作流你的本地仓库由 git 维护的三棵“树”组成。第一个是你的工作目录，它持有实际文件；第二个是暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。 添加和提交你可以提出更改（把它们添加到暂存区），使用如下命令：12git add &lt;filename&gt;git add * 这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：1git commit -m &quot;代码提交信息&quot; 现在，你的改动已经提交到了HEAD，但是还没到你的远端仓库。 推送改动你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：1git push origin master 可以把 master 换成你想要推送的任何分支。 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：1git remote add origin &lt;server&gt; 如此你就能够将你的改动推送到所添加的服务器上去了。 分支分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。 创建一个叫做“feature_x”的分支，并切换过去：1git checkout -b feature_x 切换回主分支：1git checkout master 再把新建的分支删掉：1git branch -d feature_x 除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：1git push origin &lt;branch&gt; 更新与合并要更新你的本地仓库至最新改动，执行：1git pull 以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。要合并其他分支到你的当前分支（例如 master），执行：1git merge &lt;branch&gt; 在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。这时候就需要你修改这些文件来手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功：1git add &lt;filename&gt; 在合并改动之前，你可以使用如下命令预览差异：1git diff &lt;source_branch&gt; &lt;target_branch&gt; 标签为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 1.0.0 的标签：1git tag 1.0.0 1b2e1d63ff 1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID：1git log 你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。 log如果你想了解本地仓库的历史记录，最简单的命令就是使用:1git log 你可以添加一些参数来修改他的输出，从而得到自己想要的结果。 只看某一个人的提交记录:1git log --author=bob 一个压缩后的每一条提交记录只占一行的输出:1git log --pretty=oneline 或者你想通过ASCII艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签:1git log --graph --oneline --decorate --all 看看哪些文件改变了:1git log --name-status 这些只是你可以使用的参数中很小的一部分。更多的信息，参考：1git log --help 替换本地改动假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：1git checkout -- &lt;filename&gt; 此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。 假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：12git fetch origingit reset --hard origin/master 实用小贴士内建的图形化 git：1gitk 彩色的 git 输出：1git config color.ui true 显示历史记录时，每个提交的信息只显示一行：1git config format.pretty oneline 交互式添加文件到暂存区：1git add -i 链接与资源图形化客户端GitX (L) (OSX, 开源软件)Tower (OSX)Source Tree (OSX, 免费)GitHub for Mac (OSX, 免费)GitBox (OSX, App Store) 指南和手册Git 社区参考书专业 Git像 git 那样思考GitHub 帮助图解 Git git命令大全：]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios基本使用说明]]></title>
    <url>%2F2018%2F04%2F11%2FAxios%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[Axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 特点 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 浏览器支持 Latest ✔ Latest ✔ Latest ✔ Latest ✔ Latest ✔ 8+ ✔ 安装使用 npm: 1$ npm install axios 使用 bower: 1$ bower install axios 使用 cdn: 1&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; 示例执行 GET 请求 12345678910111213141516171819202122232425262728293031// 为给定 ID 的 user 创建请求axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 可选地，上面的请求可以这样做axios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 想使用异步/等待？将`async`关键字添加到外部函数/方法中。async function getUser() &#123; try &#123; const response = await axios.get('/user?ID=12345'); console.log(response); &#125; catch (error) &#123; console.error(error); &#125;&#125; 注意: async/await是ECMAScript 2017的一部分，在Internet Explorer和旧版浏览器中不支持，因此请谨慎使用。 执行 POST 请求 12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行多个并发请求 123456789101112function getUserAccount() &#123; return axios.get('/user/12345');&#125;function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; //两个请求均已完成 &#125;)); axios API请求可以通过传递相关配置来完成 axios. axios(config) 123456789// 发送一个POST请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;); 123456789// GET请求远程图像axios(&#123; method:'get', url:'http://bit.ly/2mTM3nY', responseType:'stream'&#125;) .then(function(response) &#123; response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))&#125;); axios(url[, config]) 12// 发送GET请求（默认方法）axios('/user/12345'); 请求方法别名为方便起见，为所有支持的请求方法提供了别名 axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.options(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]]) 注意: 在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 并发处理并发请求的助手函数 axios.all(iterable)axios.spread(callback) 创建一个实例您可以使用自定义配置创建一个新的axios实例。 axios.create([config]) 12345const instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-Custom-Header': 'foobar'&#125;&#125;); 实例方法以下是可用的实例方法。指定的配置将与实例的配置合并 axios#request(config)axios#get(url[, config])axios#delete(url[, config])axios#head(url[, config])axios#options(url[, config])axios#post(url[, data[, config]])axios#put(url[, data[, config]])axios#patch(url[, data[, config]]) 请求配置这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&#123; // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // 默认 // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream // 您可以修改headers对象。 transformRequest: [function (data, headers) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个普通对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (例如： https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属： FormData, File, Blob // - Node专属: Stream, Buffer data: &#123; firstName: 'Fred' &#125;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 adapter: function (config) &#123; /* ... */ &#125;, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: 'janedoe', password: 's00pers3cret' &#125;, // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // 默认 // `responseEncoding` 表示用于解码响应的编码 // 注意：忽略'stream'或客户端请求的`responseType` responseEncoding: 'utf8', // 默认 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // 默认 // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // 默认 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。 // 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)， // promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认 &#125;, // `maxRedirects` 定义在 node.js 中遵循的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // default // `socketPath` 定义了一个在Socket.js中使用的UNIX套接字。 // 例如'/var/run/docker.sock'发送请求到docker守护进程。 // 只能指定`socketPath`或`proxy`。 // 如果两者都指定，则使用`socketPath`。 socketPath: null, // 默认 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 'proxy' 定义代理服务器的主机名称和端口 // 使用'false'来禁用代理，忽略环境变量。 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: '127.0.0.1', port: 9000, auth: &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 响应结构某个请求的响应包含以下信息 123456789101112131415161718192021&#123; // `data` 由服务器提供的响应 data: &#123;&#125;, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: 'OK', // `headers` t服务器响应的头 // 所有的 header 都是小写 headers: &#123;&#125;, // `config` 是为请求提供给`axios`的配置 config: &#123;&#125;, // `request` 是生成此响应的请求 // 它是node.js中的最后一个ClientRequest实例和浏览器请求的XMLHttpRequest实例 request: &#123;&#125;&#125; 使用 then 时，你将接收下面这样的响应： 12345678axios.get('/user/12345') .then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); &#125;); 在使用 catch 时，或传递rejection callback 作为 then 的第二个参数时, 响应可以通过 error 对象可被使用，正如在错误处理 这一节所讲. 配置的默认值/defaults你可以指定将被用在各个请求的配置默认值 全局axios默认值123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 自定义实例默认值1234567// 创建实例时设置配置的默认值const instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);// 在实例已创建后修改默认值instance.defaults.headers.common['Authorization'] = AUTH_TOKEN; 配置的优先顺序配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子： 123456789101112// 使用由库提供的配置的默认值来创建实例// 此时超时配置的默认值是 `0`const instance = axios.create();// 覆写库的超时默认值// 现在，在超时前，所有请求都会等待 2.5 秒instance.defaults.timeout = 2500;// 为已知需要花费很长时间的请求覆写超时设置instance.get('/longRequest', &#123; timeout: 5000&#125;); 拦截器在请求或响应被 then 或 catch 处理前拦截它们。 1234567891011121314151617// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); 如果你想在稍后移除拦截器，可以这样： 12const myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器 12const instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 错误处理1234567891011121314151617axios.get('/user/12345') .catch(function (error) &#123; if (error.response) &#123; // 请求已发出，但服务器响应的状态码不在 2xx 范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); &#125; else if (error.request) &#123; // 请求被提出，但没有接收到响应 // `error.request`是在浏览器中一个XMLHttpRequest的实例和node.js中http.ClientRequest的实例 console.log(error.request); &#125; else &#123; // 设置触发错误 console.log('Error', error.message); &#125; console.log(error.config); &#125;); 您可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。 12345axios.get('/user/12345', &#123; validateStatus: function (status) &#123; return status &lt; 500; // 仅当状态码大于或等于500时才拒绝 &#125;&#125;) 取消使用 cancel token 取消请求 Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。 可以使用 CancelToken.source 工厂创建取消令牌，如下所示： 123456789101112131415161718192021const CancelToken = axios.CancelToken;const source = CancelToken.source();axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;);axios.post('/user/12345', &#123; name: 'new name'&#125;, &#123; cancelToken: source.token&#125;)// 取消请求（消息参数是可选的）source.cancel('Operation canceled by the user.'); 还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token： 123456789101112const CancelToken = axios.CancelToken;let cancel;axios.get('/user/12345', &#123; cancelToken: new CancelToken(function executor(c) &#123; // executor 函数接收一个 cancel 函数作为参数 cancel = c; &#125;)&#125;);// 取消请求cancel(); 注意: 可以使用同一个 cancel token 取消多个请求 使用 application/x-www-form-urlencoded 格式默认情况下，axios将JavaScript对象序列化为JSON。要以application/x-www-form-urlencoded 格式发送数据，您可以使用以下选项之一。 浏览器在浏览器中，您可以使用以下URLSearchParams API: 1234const params = new URLSearchParams();params.append('param1', 'value1');params.append('param2', 'value2');axios.post('/foo', params); 请注意， URLSearchParams 并非所有浏览器都支持(请参阅 caniuse.com), 但可以使用 polyfill(请确保填充全局环境)。或者，您可以使用qs 库对数据进行编码： 12const qs = require('qs');axios.post('/foo', qs.stringify(&#123; 'bar': 123 &#125;)); 或者以另一种方式（ES6）， 123456789import qs from 'qs';const data = &#123; 'bar': 123 &#125;;const options = &#123; method: 'POST', headers: &#123; 'content-type': 'application/x-www-form-urlencoded' &#125;, data: qs.stringify(data), url,&#125;;axios(options); Node.js在node.js中，您可以querystring按如下方式使用模块： 12const querystring = require('querystring');axios.post('http://something.com/', querystring.stringify(&#123; foo: 'bar' &#125;)); 您也可以使用该qs库. Semver在axios达到1.0 发布之前，将通过新的次要版本发布重大更改。例如 0.5.1, 和 0.5.4将具有相同的API, 但 0.6.0 会有重大更改。 承诺aaxios依赖于原生ES6 Promise实现的支持。如果您的环境不支持ES6 Promise，则可以polyfill。 TypeScriptaxios包括TypeScript定义。12import axios from 'axios';axios.get('/user?ID=12345'); 资源 更新日志 升级指南 生态系统 C参与指南 行为守则]]></content>
      <categories>
        <category>翻译</category>
        <category>README</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTerm 2和Oh My Zsh代替自带terminal教程简单整理]]></title>
    <url>%2F2018%2F04%2F02%2FiTerm-2%E5%92%8COh-My-Zsh%E4%BB%A3%E6%9B%BF%E8%87%AA%E5%B8%A6terminal%E6%95%99%E7%A8%8B%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[最终效果图大概是这个样子： 但是如果你有用到Atom编辑器的控制台插件的话可能会由于字体原因特殊的符号显示不了，就像我这样： 1. 首先下载iterm22. 打开iTerm 23. 输入下面指令安装oh-my-zsh curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh 4. 接下来安装Powerline在官网有教程，我们只需要执行官网第一条安装指令就行 如果你的终端能够正常执行pip指令，那么直接执行下面的指令可以完成安装 pip install powerline-status 如果没有，则先执行安装pip指令 sudo easy_install pip 5. 下载、安装库字体库1）将工程下载下来后cd到install.sh文件所在目录 2）执行指令安装字体库 执行./install.sh指令安装所有Powerline字体 安装完成后提示所有字体均已下载到/Users/superdanny/Library/Fonts路径下 All Powerline fonts installed to /Users/superdanny/Library/Fonts 6. 设置iTerm 2的Regular Font 和 Non-ASCII Font安装完字体库之后，把iTerm 2的设置里的Profile中的Text 选项卡中里的Regular Font和Non-ASCII Font的字体都设置成 Powerline的字体，我这里设置的字体是12pt Meslo LG S DZ Regular for Powerline 设置iTerm 2设置iTerm 2 7. 配色方案1）安装配色方案 进入刚刚下载的工程的solarized/iterm2-colors-solarized下双击Solarized Dark.itermcolors和Solarized Light.itermcolors两个文件就可以把配置文件导入到 iTerm2 里 2）配置配色方案 通过load presets选择刚刚安装的配色主题即可 配色方案配色方案 8. 使用agnoster主题1）下载agnoster主题 到下载的工程里面运行install文件,主题将安装到~/.oh-my-zsh/themes目录下 2）设置该主题进入~/.zshrc打开.zshrc文件，然后将ZSH_THEME后面的字段改为agnoster。ZSH_THEME=”agnoster”（agnoster即为要设置的主题） 9. 增加指令高亮效果——zsh-syntax-highlighting指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮 1）首先在~/.oh-my-zsh/custom/plugins/路径下执行git clone https://github.com/zsh-users/zsh-syntax-highlighting.git到了此路径:~/.oh-my-zsh/custom/plugins/ 2）然后在~/.zshrc最后添加了下面两句：“plugins=(zsh-syntax-highlighting)source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh” 3）最后执行 source ~/.zshrc 这样就同时配置好了zsh和oh-my-zsh。有两点需要注意(摘自官网):Note the source command must be at the end of ~/.zshrc.Note that zsh-syntax-highlighting must be the last plugin sourced, so make it the last element of the $plugins array. 问题解答区 启动iTerm 2 默认使用dash改用zsh解决方法： chsh -s /bin/zsh 如果想切换回原来的dash： chsh -s /bin/bash 卸载oh my zsh，在命令行输入如下命令，回车即可： uninstall_oh_my_zsh 执行指令pip install powerline-status出错解决方法：需要下载苹果官方的Command line。必須官方工具下载最新版 Command Line ⌘+Q关闭iTerm 2 时每次弹窗提示问题：iTerm 2 中，进入Preference-General-Closing栏目，将Confirm “Quit iTerm2(⌘Q)” command选项勾选去掉就行 找不到.zshrc文件问题：我这里将原作者的.zshrc文件分享出来。供大家下载网盘 路径前缀的XX@XX太长，缩短问题：在此感谢评论区的朋友提供的解决方案。在~/.oh-my-zsh/themes路径下找到agnoster.zsh-theme文件，可使用文本工具打开，将里面的build_prompt下的prompt_context字段在前面加#注释掉即可。 执行指令pip install powerline-status出错，下载了Command Line也没有办法,是权限原因造成的,执行: pip install powerline-status –user 原文]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>iTerm 2</tag>
        <tag>Oh My Zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下安装mysql5.7完整步骤及问题整理]]></title>
    <url>%2F2018%2F03%2F19%2FMac%E4%B8%8B%E5%AE%89%E8%A3%85mysql5-7%E5%AE%8C%E6%95%B4%E6%AD%A5%E9%AA%A4%E5%8F%8A%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[安装参考以下这个博客: Mac下安装mysql5.7完整步骤 问题 “MAC下安装Mysql找不到my.cnf配置文件的问题”，参考：MAC 安装MySQL的my.cnf配置文件 “Warning: World-writable config file ‘/etc/my.cnf’ is ignored”，参考：World-writable]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac安装Mysql</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10下.Net Framework 3.5无法安装【错误代码0x800F081F】]]></title>
    <url>%2F2018%2F03%2F18%2FWin10%E4%B8%8B-Net-Framework-3-5%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[首先下载 .Net Framework 3.5. 将下载的文件复制到复制到 【C盘】 的 【Windows】 文件夹，然后后在“命令提示符（管理员）”中执行下面的命令： dism /online /Enable-Feature /FeatureName:NetFx3 /Source:”%windir%” /LimitAccess 其他: Windows 10下安装有的软件需要 .Net Framework 3.5的环境。默认是没有开启的，一般情况下可以【右键开始】菜单，选择【程序和功能】然后再选择【启用或关闭Windows功能】里的第一项【.Net Framework 3.5(包括.NET 2.0和3.0) 再一个就是去官网下一个手动安装一下也行，这两种方法都不行再用上面那个方法，这样大部分人的问题应该都可以解决了。]]></content>
      <categories>
        <category>OS</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Framework3.5无法安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机VirtualBox中挂载新硬盘]]></title>
    <url>%2F2018%2F03%2F18%2F%E8%99%9A%E6%8B%9F%E6%9C%BAVirtualBox%E4%B8%AD%E6%8C%82%E8%BD%BD%E6%96%B0%E7%A1%AC%E7%9B%98%2F</url>
    <content type="text"><![CDATA[在VirtualBox中装好Linux后，发现硬盘空间太小，怎样才能增加硬盘容量？那就是再建一个硬盘： 添加新硬盘 设置 -&gt; Storage(存储) -&gt; SATA控制器-&gt;右击，选择”添加虚拟硬盘”然后，根据需求创建合适的硬盘 重启虚拟机 查看现有系统的磁盘空间 sudo fdisk -l 可看到新加的虚拟硬盘，一般名为：Disk /dev/sdb 给新加的硬盘分区 fdisk /dev/sdb 键入m,可看到帮助信息 command (m for help):m 增加新分区 command (m for help):n 选择基本分区，输入：p 建一个分区 Partition number(1-4): 回车 First cylinder (1-15908,default 1):Enter 写入并退出 command (m for help):w 格式化磁盘分区 用ext4格式对/dev/sdb1进入格式化 sudo mkfs.ext4 /dev/sdb1 挂载分区 创建新的挂载点 sudo mkdir /work 将新磁盘分区挂载到/work目录下 sudo mount -t ext4 /dev/sdb1 /work 查看挂载 df -h 可以看到新加的硬盘：/dev/sdb1 开机自动挂载 修改文件 sudo vim /etc/fstab 在最后一行加入： /dev/sdb1 /work ext4 errors=remount-ro 0 1 完成! 补充：为挂载点扩容假设之前我们有一个挂载点为 /mydata ，但该 /mydata 已经写满，但依然想在 /mydata 下添加新的数据，这时可以使用软链接将 /mydata 软链接到一个新挂载的磁盘分区上以实现扩容。具体步骤如下。 1. 创建一个目录，以便稍后作为挂载点： mkdir /newdata 2. 将 /dev/sdb1 分区挂载到 /newdata 下： mount /dev/sdb1 /newdata 3. 新建 /mydata 到 /newdata 的软链接： ln -s /newdata /mydata 此时在 /mydata 目录下会有一个软链接文件 newdata 指向 /newdata/ ，即 newdata-&gt; /newdata/ 。这样一来，只要我们向 /mydata/newdata 下写文件，实际就写入了 /newdata/ 目录下，相当于我们为原 /mydata 挂载点新增加了一部分使用空间。 也可以手动指定该软链接文件的名称： ln -s /newdata /mydata/customed_name 这样就有 /mydata/customed_name -&gt; /newdata 注： 我们也可以利用软链接的这一用途，将比较大的日志文件链接到存储空间充足的磁盘分区的挂载点上。 举例来说，如果 /opt/tomcat/logs/catalina.out 日志文件输入很多，占用空间很大，而 /opt 挂载点中所剩空间已经不多，存在溢出风险，通过下面两步就可以将该日志文件软链接到另一个磁盘分区的挂载点上： touch /newdata/catalina_link.outln -sf /newdata/catalina_link.out /opt/tomcat/logs/catalina.out 这里还需要注意三点： 一是必须先创建一个被链接的文件，否则软链接后失败； 二是强制软链接会清空之前 /opt/tomcat/logs/catalina.out 日志文件中的全部内容清空； 三是需要重启 tomcat 目录后才能继续向 /opt/tomcat/logs/catalina.out 写入。]]></content>
      <categories>
        <category>OS</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>Linux挂载硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常见异常总结]]></title>
    <url>%2F2018%2F03%2F18%2FJava%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[java.lang.NullPointerException(空指针异常) 调用了未经初始化的对象或者是不存在的对象 经常出现在创建图片，调用数组这些操作中，比如图片未经初始化，或者图片创建时的路径错误等等。对数组操作中出现空指针，即把数组的初始化和数组元素的初始化混淆起来了。数组的初始化是对数组分配需要的空间，而初始化后的数组，其中的元素并没有实例化，依然是空的，所以还需要对每个元素都进行初始化（如果要调用的话）。 java.lang.ClassNotFoundException 指定的类不存在 这里主要考虑一下类的名称和路径是否正确即可，通常都是程序试图通过字符串来加载某个类时可能引发 异常 比如：调用Class.forName(); 或者调用ClassLoad的finaSystemClass();或者LoadClass(); java.lang.NumberFormatException 字符串转换为数字异常 当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常.如现在讲字符型的数据“123456”转换为数值型数据时，是允许的。但是如果字符型数据中包含了非数字型的字符，如123#56，此时转换为数值型时就会出现异常。系统就会捕捉到这个异常，并进行处理. java.lang.IndexOutOfBoundsException 数组下标越界异常 查看调用的数组或者字符串的下标值是不是超出了数组的范围，一般来说，显示（即直接用常数当下标）调用不太容易出这样的错，但隐式（即用变量表示下标）调用就经常出错了，还有一种情况，是程序中定义的数组的长度是通过某些特定方法决定的，不是事先声明的，这个时候，最好先查看一下数组的length，以免出现这个异常。 java.lang.IllegalArgumentException 方法的参数错误 比如g.setColor(int red,int green,int blue)这个方法中的三个值，如果有超过２５５的也会出现这个异常，因此一旦发现这个异常，我们要做的，就是赶紧去检查一下方法调用中的参数传递是不是出现了错误。 java.lang.IllegalAccessException 没有访问权限 当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。对程序中用了Package的情况下要注意这个异常 java.lang.ArithmeticException 数学运算异常 当算术运算中出现了除以零这样的运算就会出这样的异常。 java.lang.ClassCastException 数据类型转换异常 当试图将对某个对象强制执行向下转型，但该对象又不可转换又不可转换为其子类的实例时将引发该异常，如下列代码。 123Object obj = new Integer(0);String str = obj;java.lang.FileNotFoundException java.lang.FileNotFoundException 文件未找到异常 当程序试图打开一个不存在的文件进行读写时将会引发该异常。该异常由FileInputStream,FileOutputStream,RandomAccessFile的构造器声明抛出即使被操作的文件存在，但是由于某些原因不可访问，比如打开一个只读文件进行写入，这些构造方法仍然会引发异常 java.lang.ArrayStoreException 数组存储异常 当试图将类型不兼容类型的对象存入一个Object[]数组时将引发异常 123Object[] obj = new String[3];obj[0] = new Integer(0);java.lang.NoSuchMethodException java.lang.NoSuchMethodException 方法不存在异常 当程序试图通过反射来创建对象，访问(修改或读取)某个方法，但是该方法不存在就会引发异常 java.lang.NoSuchFiledException 方法不存在异常 当程序试图通过反射来创建对象，访问(修改或读取)某个filed，但是该filed不存在就会引发异常 java.lang.EOFException 文件已结束异常 当程序在输入的过程中遇到文件或流的结尾时，引发异常。因此该异常用于检查是否达到文件或流的结尾 java.lang.InstantiationException 实例化异常 当试图通过Class的newInstance()方法创建某个类的实例,但程序无法通过该构造器来创建该对象时引发Class对象表示一个抽象类，接口，数组类，基本类型该Class表示的类没有对应的构造器 java.lang.InterruptedException 被中止异常 当某个线程处于长时间的等待、休眠或其他暂停状态，而此时其他的线程通过Thread的interrupt方法终止该线程时抛出该异常。 java.lang.CloneNotSupportedException 不支持克隆异常 当没有实现Cloneable接口或者不支持克隆方法时,调用其clone()方法则抛出该异常。 java.lang.OutOfMemoryException 内存不足错误 当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。 java.lang.NoClassDefFoundException 未找到类定义错误 当Java虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误。 违背安全原则异常：SecturityException 操作数据库异常：SQLException 输入输出异常：IOException 通信异常：SocketException]]></content>
      <categories>
        <category>Java</category>
        <category>异常</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop伪分布式搭建-(4)]]></title>
    <url>%2F2018%2F03%2F18%2FHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-4%2F</url>
    <content type="text"><![CDATA[生成ssh免登陆密钥 进入到/dh/下的home目录(隐藏) cd ~/.sshssh-keygen -t rsa （一直回车） 执行完这个命令后，会生成两个文件id_rsa（私钥）、id_rsa.pub（公钥） 将公钥拷贝到要免登陆的机器上 ssh-copy-id -i localhost (ssh-copy-id -i 要免登陆的机器的IP)或者cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop伪分布式搭建-(3)]]></title>
    <url>%2F2018%2F03%2F18%2FHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-3%2F</url>
    <content type="text"><![CDATA[安装hadoop2.4.1（或其他更高版本&lt;最好用更高的64位版本，免得重新编译&gt;）注意：hadoop2.x的配置文件$HADOOP_HOME/etc/hadoop伪分布式需要修改5个配置文件 上传hadoop并解压到指定目录同jdk一样,上传Hadoop的包到本目录,并在root目录下创建/dh/这个目录,将Hadoop解压到该目录 配置hadoop hadoop-env.sh文件 vim hadoop-env.sh 1export JAVA_HOME=/usr/java/jdk1.7.0_79 core-site.xml文件 vim core-site.xml 12345678910&lt;!--设定NameNode地址 --&gt;&lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://dh01:9000&lt;/value&gt; &lt;!--或者把dh01换成对应IP--&gt;&lt;/property&gt;&lt;!-- 指定hadoop运行时产生文件的存储目录 --&gt;&lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/dh/hadoop-2.4.1/tmp&lt;/value&gt;&lt;/property&gt; hdfs-site.xml文件 vim hdfs-site.xml 12345&lt;!-- 指定HDFS副本的数量 --&gt;&lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt;&lt;!--因为为伪分布式,所以只有一个副本--&gt;&lt;/property&gt; mapred-site.xml文件 #重命名mv mapred-site.xml.template mapred-site.xml#打开重命名后的文件vim mapred-site.xml 12345&lt;!-- 指定mapreduce运行在YARN上 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt; yarn-site.xml文件 12345678910&lt;!-- 指定YARN的老大（ResourceManager）的地址 --&gt;&lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;dh01&lt;/value&gt;&lt;/property&gt;&lt;!-- mapreduce获取数据的方式 --&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt; 将hadoop添加到环境变量 vim /etc/proflie 123export JAVA_HOME=/usr/java/jdk1.7.0_79export HADOOP_HOME=/dh/hadoop-2.4.1export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$HADOOP_HOME/lib 刷新配置文件 source /etc/profile 格式化namenode（是对namenode进行初始化） hdfs namenode -format (hadoop namenode -format) 启动hadoop先启动HDFS sbin/start-dfs.sh 再启动YARN sbin/start-yarn.sh 验证是否启动成功使用jps命令验证 jsp 12345627408 NameNode28218 Jps27643 SecondaryNameNode28066 NodeManager27803 ResourceManager27512 DataNode http://192.168.8.88:50070 （HDFS管理界面） 在这个文件中添加linux主机名和IP的映射关系C:\Windows\System32\drivers\etc\hosts下添加:1192.168.1.66 dh01 打开：http://192.168.8.88:8088验证 （mapreduce管理界面）]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop伪分布式搭建-(2)]]></title>
    <url>%2F2018%2F03%2F18%2FHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-2%2F</url>
    <content type="text"><![CDATA[安装JDK 从Windows上传jdk到虚拟机 你可以用FlashFXP/FileZilla/SecureCRT将jdk-7u79-linux-x64.gz传到Linux上。假设现在你已经传到了虚拟机的root目录下 解压jdk mkdir /usr/javatar -zxvf jdk-7u79-linux-x64.gz -C /usr/java/ 将java添加到环境变量中 vim /etc/profile 12export JAVA_HOME=/usr/java/jdk1.7.0_79 export PATH=$PATH:$JAVA_HOME/bin 刷新配置 source /etc/profile]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop伪分布式搭建-(1)]]></title>
    <url>%2F2018%2F03%2F18%2FHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-1%2F</url>
    <content type="text"><![CDATA[配置虚拟机子网网段(hostonly模式时) 配置网段 点击VMware快捷方式，右键打开文件所在位置 -&gt; 双击vmnetcfg.exe -&gt; VMnet1 host-only -&gt;修改subnet ip 设置网段：192.168.8.0 子网掩码：255.255.255.0 -&gt; apply -&gt; ok 设置本地机器IP 回到windows –&gt; 打开网络和共享中心 -&gt; 更改适配器设置 -&gt; 右键VMnet1 -&gt; 属性 -&gt; 双击IPv4 -&gt;设置windows的IP：192.168.8.100 子网掩码：255.255.255.0 -&gt; 点击确定 设置为hostonly模式 在虚拟软件上 –My Computer -&gt; 选中虚拟机 -&gt; 右键 -&gt; settings -&gt; network adapter -&gt; host only -&gt; ok 另:桥接模式 桥接模式直接将本地机器的当前正在使用的网卡(无线/非无线网卡)IP改为静态IP即可.设置windows的IP：192.168.8.100 子网掩 码：255.255.255.0 -&gt; 网关:192.168.1.1 -&gt; 若为无线网卡,设置前先查看路由分配的DNS是多少,直接照着填进来就行.-&gt;点击确定 修改主机名 vim /etc/sysconfig/network 12NETWORKING=yesHOSTNAME=dh01 #随便设置一个名字 修改虚拟机IP(这里是centos7)两种方式： 第一种：通过Linux图形界面进行修改（推荐） 进入Linux图形界面 -&gt; 右键点击右上方的两个小电脑 -&gt;点击Edit connections -&gt; 选中当前网络System eth0 -&gt;点击edit按钮 -&gt; 选择IPv4 -&gt; method选择为manual -&gt;点击add按钮 -&gt;添加IP：192.168.8.88子网掩码：255.255.255.0 网关：192.168.8.1 -&gt; apply 第二种：修改配置文件方式 vim /etc/sysconfig/network-scripts/ifcfg-eth0 (不一定一定是ifcfg-eth0) 1234567891011DEVICE=&quot;eth0&quot;BOOTPROTO=&quot;static&quot; #修改HWADDR=&quot;00:0C:29:3C:BF:E7&quot;IPV6INIT=&quot;yes&quot;NM_CONTROLLED=&quot;yes&quot;ONBOOT=&quot;yes&quot;TYPE=&quot;Ethernet&quot;UUID=&quot;ce22eeca-ecde-4536-8cc2-ef0dc36d4a8c&quot;IPADDR=&quot;192.168.8.88&quot; #修改NETMASK=&quot;255.255.255.0&quot; #修改GATEWAY=&quot;192.168.8.1&quot; #修改 修改主机名和IP的映射关系 vim /etc/hosts 1192.168.8.88 dh01 关闭防火墙(以下为centos7以前命令,centos7) #查看防火墙状态service iptables status #关闭防火墙service iptables stop #查看防火墙开机启动状态chkconfig iptables –list #关闭防火墙开机启动chkconfig iptables off CentOS 7.0默认使用的是firewall作为防火墙 systemctl start firewalld.service #启动firewallsystemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动 也可以改成使用iptables：systemctl start iptables.service 重启Linux reboot]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse下JSP中使用UEditor（以富文本编辑器为例）]]></title>
    <url>%2F2017%2F02%2F20%2FEclipse%E4%B8%8BJSP%E4%B8%AD%E4%BD%BF%E7%94%A8UEditor(%E4%BB%A5%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%BA%E4%BE%8B)%2F</url>
    <content type="text"><![CDATA[1.下载UEditorhttp://ueditor.baidu.com/website/download.html 版本如下： 2.解压，简单暴力地将\ueditor1_4_3-utf8-jsp\jsp\lib目录下的文件拷贝到项目的/WEB-INF/lib目录下如图所示： 3.将除index.html文件外的文件拷贝到项目中，例如： 4.在要使用富文本编辑器的页面引入脚本：12345&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&lt;%=path%&gt;/js/ueditor/ueditor.config.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&lt;%=path%&gt;/js/ueditor/ueditor.all.min.js&quot;&gt; &lt;/script&gt;&lt;!--建议手动加在语言，避免在ie下有时因为加载语言失败导致编辑器加载失败--&gt;&lt;!--这里加载的语言文件会覆盖你在配置项目里添加的语言类型，比如你在配置项目里配置的是英文，这里加载的中文，那最后就是中文--&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&lt;%=path%&gt;/js/ueditor/lang/zh-cn/zh-cn.js&quot;&gt;&lt;/script&gt; 如图： 5.在需要用富文本编辑器的区域添加以下脚本：1&lt;script id=&quot;editor&quot; type=&quot;text/plain&quot; style=&quot;width:486px;height:300px;&quot;&gt;&lt;/script&gt; 如图： 6.在页面最下端写以下javascript脚本：12345&lt;script type=&quot;text/javascript&quot;&gt; //实例化编辑器 //建议使用工厂方法getEditor创建和引用编辑器实例，如果在某个闭包下引用该编辑器，直接调用UE.getEditor(&apos;editor&apos;)就能拿到相关的实例 var ue = UE.getEditor(&apos;editor&apos;);&lt;/script&gt; 如图： 7.添加提交按钮的js脚本，用来提交内容脚本文件：代码：12345678function check_post_msg_valid()&#123; if(false==UE.getEditor(&apos;editor&apos;).hasContents())&#123; alert(&apos;请输入内容！&apos;); return false; &#125; document.getElementById(&quot;msg&quot;).value=UE.getEditor(&apos;editor&apos;).getContent(); document.forms[0].submit(); &#125; 8.其他：]]></content>
      <categories>
        <category>Java</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>UEditor</tag>
        <tag>富文本编辑器</tag>
      </tags>
  </entry>
</search>
